




=======================================================
что такое children?

если родительский компонент содержит разметку, то эта разметка доступна внутри дочернего компонента через props.

родительский компонент:

	function WelcomeDialog() {
	  return (
	    <FancyBorde>
	      <h1>qwerty</h1>
	    </FancyBorder>
	  );
	}

дочерний компонент:

	function FancyBorder(props) {
	  return (
	    <div>
	      {props.children}
	    </div>
	  );
	}


=======================================================
что такое управляемые компоненты?

элементы форм в реакте обычно делаются так, что их содержимое хранится в локальном стейте или в сторе. с каждым элементом формы связан обработчик, который обновляет состояние, после этого обновляется видимое в элементе значение.

невозможно обновить значение в элементе, не изменив при этом стейт.

=======================================================
что такое HOC?

это компоннет, который принимает компонеет и возвращает новый. в этом новом посредством props появляются дополнительные входящие данные.

пример HOC это connect из redux

=======================================================
что такое хуки?

хуки позволяют заменить методы жизненного цикла и использовать локальное состояние. хуки работают только внутри функций. 

=======================================================
что такое порталы?

Обычно, когда вы возвращаете элемент из рендер-метода компонента, он монтируется в DOM как дочерний элемент ближайшего родительского узла. Но иногда требуется поместить потомка в другое место в DOM:

	render() {
	  return ReactDOM.createPortal(
	    this.props.children,
	    domNode
	  );
	}

при этом всплытие событий и контекст работают обычным образом. то есть как будто элемент был встроен в родительский компонент.

=======================================================
что такое flux-архитектура?

это паттерн, который направляет данные компонента в одну сторону. суть в том, что каждый элемент связан с состоянием. элемент можно изменить только изменив состояние. таким образом элемент может изменять себя сам или его могут изменять другие элементы, но в любом случае актуальное значение элемент будет получать единственным способом из состояния.

такой подход упрощает отладку кода и уменьшает хаос изменения данных.

Flux - это подход к проектированию. А redux - конкретная библиотека, реализующая данный подход.

=======================================================
что такое мемоизация?

допустим имеем родительский компонент, который получает пропсы и дочерний компонент, который не получает пропсы. 

мемоизация это проверка поступивших в родительский компонент данных. если они действительно новые, то перерисовка беспропсового компонента происходит. а если те же самые, то перерисовки не происходит.

	import React from 'react'

	function Page11(props) {
	  console.log('11')
	  return(
	    <>
	      page11
	    </>
	  )
	}

	export default React.memo(Page11);


хук useMemo работает так же, но на уровне вложенных функций.

=======================================================
=======================================================
что такое react?

это библиотека для отрисовки пользовательского интерфейса. 

=======================================================
Какие библиотеки в основном используете вместе в React?

react-redux - для организации потоков данных.

react-router-dom - для организации роутинга.

axios - для отправки запросов.

redux-thunk - для использования thunk

=======================================================
State и props, в чем их разница?

props это входные данные, которые получает функциональный компонент для отрисовки. в классовом компоненте используется this.props.

state это внутреннее сосотояние компонента, которое не связано в глобальным состоянием. в функциональном компоненте state управляется при помощи хука useState. в классовом компоненте хуков нет поэтому используется this.state

=======================================================
Какие методы жизненного цикла вы знаете? 

в классовом компоннете существуют методы цикла:
	componentDidMount,
	componentDidUpdate,
	componentWillUnmount

они срабатывают соответственно при создании, обновлении, удалении компонента.

кроме того в классовом компоненте есть:
	constructor(props),
	render()

в функциональном компоненте удобно использовать хук useEffect(). его можно настроить на единичное срабатывание или срабатывание после обновления определённых данных.

в общем случае последовательность методов жизненного цикла такая:
constructor
render
componentDidMount

shouldComponentUpdate
render
componentDidUpdate

componentWillUnmount


=======================================================
В чем разница между Component и PureComponent?

в классовых компонентах существует хук shouldComponentUpdate. он проверяет старый стейт и новый стейт. в результате возвращает булево значение. на основе которого происходит или не проиходит перерисовка компонента.

в более поздних версиях можно вместо shouldComponentUpdate использовать class TestC extends React.PureComponent. он делает то же самое, но незаметно.

для функциональных компонентов можно использовать React.memo(comp). смысл такой же.

PureComponent не срабатывает для случая стрелочных функций и bind(). потому что они при каждом выполнении возвращают новый экземпляп функции.

=======================================================
В чем отличие между функциональным компонентом и компонентов в виде класса?

функциональный компонент представляет из себя обычную js-функцию, которая возвращает jsx. она использует хуки для управления состоянием и жизненным циклом. 

классовый компонент это js-класс. он может наследоваться от других компонент. в нём есть спец. методы для управления жизненным циклом, инициализации и отрисовки jsx.

=======================================================
Какие виды компонентов ты знаешь? С какими приходилось работать? (function, class, HOC)

существуют функциональные компоненты, классовые компоненты и компоненты высшего порядка. HOC принимает компонент и возвращает компонент, при этом передавая в возвращаемый компонент дополнительные входные данные.


=======================================================
Что такое неконтролируемые компоненты?

НК не используют flux-подход. то есть перерисовка конкретного в них не осуществляется после изменения в глобальном глобальном или локальном хранилище. примером может служить input, не связанный со стором или стейтом. его значение изменяется после внесения изменений пользователем, глобальный или локальный стор про это не знает

=======================================================
Что такое refs? Какой параметр принимает? Для чего они используются?

refs используются для создания ссылки на DOM-узел. это аналог getElementById.

this.myRef = React.createRef();
return <div ref={this.myRef} />;
this.myRef.focus();

refs можно использовать и в классовых компонентах, и в функциональных.

=======================================================
Какой метод жизненного цикла есть у React, чтобы отлавливать ошибки? 

ComponentDidCatch, getDerrivedStateFromError работают как сблоки try/catch и только в классовых компонентах.

getDerrivedStateFromError срабатывает когда ошибка случается на этапе рендера. используется для подмены части DOM:

	export default class App extends Component { 
	  state = { 
	    error: false
	  }; 
	  
	  static getDerivedStateFromError(error) { 
	    return { 
	      error: true, 
	    }; 
	  } 
	  
	  render() { 
	    return ( 
	      <React.StrictMode> 
	        <div> 
	          {this.state.error ? <div>Some error</div> : <GFGComponent />} 
	        </div> 
	      </React.StrictMode> 
	    ); 
	  } 
	} 
	  
	class GFGComponent extends Component { 
		render() { 
			return <h1>qwerty</h1>; 
		} 
	} 



componentDidCatch срабатывает после рендера, то есть на этапе ожидания пользоватльского ввода. используется для фиксации ошибок в логе.


=======================================================
Основная причина проблем с производительностью в React?

после рендера родительского компонента происходит перерендер дочерних компонентов(даже если в дочерних ничего не менялось). чтобы этого избежать нужно использовать механиз мемоизации. в частности хук useMemo и React.memo

=======================================================
Расскажите подробнее о getDerrivedStateFromProps?


=======================================================
что такое PropertyKey? зачем использовать key в цикле вывода элементов?

это необходимо для оптимизации производительности рендера элементов. например, есть список из двух элементов:

	<ul>
	  <li>Санкт-Петербург</li>
	  <li>Москва</li>
	</ul>

если добавить элемент в начало списка, 

	<ul>
	  <li>Ростов-на-Дону</li>
	  <li>Санкт-Петербург</li>
	  <li>Москва</li>
	</ul>

то остальные элементы тоже перерисуются. при наличии key дополнительной перерисовки не произойдёт.

однако, если вставить элемент в конец списка, то остальные элементы не будут перерисовываться даже в случае отсутствия key.

нежелательно в качестве key использовать index цикла.

=======================================================
Как работает Virtual DOM? что такое виртуальный DOM?

это промежуточный слой между реальным DOM-деревом и реактом. реальное DOM-дерево изменять очень затратно с точки зрения производительности. виртуальный DOM отправляет изменения пакетами, кроме того он представляет из себя набор упрощенных элементов-объектов поэтому изменять его из реакта можно быстро и просто.

после изменения virtual DOM происходит сверка. то есть процесс, который сравнивает новое дерево и изменённым. если изменён корневой узел, то он перерисовывается полностью(включая дочерние элементы). но если изменены только некоторые дочерние элементы в корневом узле, то реальный DOM перерисовывается частично. это улучшает производительность.

=======================================================
Можно ли использовать virtual DOM с другими библиотеками?

можно. потому что virtualDOM это просто один из способов взаимодействия с реальным DOM. он появился потому что реальный DOM не был задуман как часто обновляемая структура. в результате постоянно перерисовывать реальный дом это дорогая процедура с точки зрения производительности.

=======================================================
Что произойдет если в ComponentDidUpdate вызвать setState({});?

setState() всегда приводит к повторному рендеру. setState() необходимо обернуть в условие, как в примере выше, чтобы не возник бесконечный цикл.


=======================================================
Рассказать про flux. Что это, какие минусы и плюсы есть. Рассматривали какие-то другие реализации flux.

flux это архитектура, в соответствии с ней данные двигаются в одном направлении.

1. в представлении происходит событие
2. создаётся экшен
3. диспетчер отправляет экшен в стор
4. стор изменяет состояние и отправляет сигнал всем представлениям
5. представления получают сигнал и перерисовывают страницу
6 представления ждут новых событий

минус в том, что высокий порог вхождения. кроме того приходится писать много бойлерплэёт кода.

плюсы в том, что отлаживать приложение становится проще потому что легко отслеживаются все последовательности событий, которые привели к багу. к тому же код компонентов становится более кратким.


=======================================================
что такое контекст?

контекст позволяет избежать передачи через props данных в глубокие компоненты. это делает код чище, хотя по сути появляется глобальная переменная.

внешний файл:

	const ThemeContext = React.createContext('light');

	<ThemeContext.Provider value="dark">
		<Toolbar />
	</ThemeContext.Provider>

глубоко вложенный файл:

	static contextType = ThemeContext;
	render() {
		return <Button theme={this.context} />;
	}

вышеприведённый способ работает только для классовых компонентов. для функциональных компонент нужно использовать <ThemeContext.Consumer> в инструкции return.

=======================================================
Что такое редьюсеры в Redux?

редюсеры принимают данные и команду, сообщающую что с ними делать. затем на основе команды редюсер изменяет определённую часть стейта. внутри редюсера есть условый оператор, который анализирует команду и выполняет нужное действие со стейтом.

=======================================================
Connect это higher order component?

connect это функция, которая помогает получать актуальные данные из стора и работать  ними при помощи thunks или actions. она является компонентом высшего порядка.


=======================================================
Что такое middleware для redux? Приведи пример известных.

миддлвар это промежуточный обработчик для какого-либо действия. в случае redux миддлвары выполняют дополнительное действие перед стартом редюсера. в частности он может сделать запрос на сервер и по его результатам решить изменять стор или нет. 

миддлвары можно объединять в цепочки.

=======================================================
Когда стоит использовать Redux, а когда он будет избыточным в приложении? Почему?

redux нужно использовать когда необходимо хранить данные в глобальном стейте и когда необходимо иметь доступ к этим данным в компоненте любого уровня вложенности.

если приложение простое и не требуетпостоянного проброса данных, то redux будет избыточен потому что для него приходится писать много обслуживающего кода.


=======================================================
Как работает библиотека Reselect, что это такое и как она решает проблемы с производительностью? 

если используется redux, то в mapStateToProps обновляется значение селекторов даже если в сторе произошли изменения, не связанные с этими селекторами. в результате срабатывает рендер. хорошо бы отменить срабатывание рендера, если конкретные селекторы не изменили своих значений.

для этого используется мемоизация селекторов при помощи reselect. для этого в mapStateToProps значение селектора оборачивается в createSelector.


=======================================================
SSR, что это и как работает? Если работали с ним, расскажите как реализовывали?

это технология формирования разметки на стороне сервера. в результате клиент получает html в готовом виде, в нагрузка на браузер уменьшается. также важно, что поисковые системы могут лучше индексировать сайт потому что вместо <div id="root"/> они видят реальный html.

=======================================================
React Hooks(зачем перешли, какие проблемы решают)
Какая цель отказаться от Class'ов(в чем плюсы)

1. позволяют управлять локальным стейтом компонента(альтернатива классовому стейту)
2. позволяют частично отказаться от HOC, тем самым уменьшая wrap hell
3. можно извлекать логику работы с состоянием из компонента и переиспользовать её.
4. методы жизненнго цикла классовых компонент содержали разнотипную логику, которую сложно тестировать. хуки позволяют разбить её
5. классы труднее пониимаются разработчиками поэтому в приоритете постепенный переход на функциональные компоненты.
6. в реакте классы не являются полноценными. отсутствует множетсвенное наследование, инкапсуляция. поэтому выгоднее перейти на функции.


=======================================================
Styled Components(зачем он, какие проблемы решает, и его аналоги)

это компонент, на основе которого можно генерировать и стилизовать элементы. кроме того он предоставляет возможности наследования.

	const Button = styled.button`
		font-size: 1.5em;
		background-color: black;
		color: white;
	`;

также можно использовать css-модули. это файл, содержащий css. область видимости - локальная. его нужно импортировать и только после этого использовать:

	import styles from ‘./styles.css’;
	<p className={styles.error-message}>I am an error message</p>

 

=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================