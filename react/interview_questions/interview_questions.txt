зачем использовать key в цикле вывода элементов?

это необходимо для оптимизации производительности рендера элементов. например, есть список из двух элементов:

	<ul>
	  <li>Санкт-Петербург</li>
	  <li>Москва</li>
	</ul>

если добавить элемент в начало списка, 

	<ul>
	  <li>Ростов-на-Дону</li>
	  <li>Санкт-Петербург</li>
	  <li>Москва</li>
	</ul>

то остальные элементы тоже перерисуются. при наличии key дополнительной перерисовки не произойдёт.

однако, если вставить элемент в конец списка, то остальные элементы не будут перерисовываться даже в случае отсутствия key.

нежелательно в качестве key использовать index цикла.

=======================================================
что такое контекст?

контекст позволяет избежать передачи через props данных в глубокие компоненты. это делает код чище, хотя по сути появляется глобальная переменная.

внешний файл:

	const ThemeContext = React.createContext('light');

	<ThemeContext.Provider value="dark">
		<Toolbar />
	</ThemeContext.Provider>

глубоко вложенный файл:

	static contextType = ThemeContext;
	render() {
		return <Button theme={this.context} />;
	}


=======================================================
что такое виртуальный DOM?

это промежуточный слой между реальным DOM-деревом и реактом. реальное DOM-дерево изменять очень затратно с точки зрения производительности. виртуальный DOM отправляет изменения пакетами, кроме того он представляет из себя набор упрощенных элементов-объектов поэтому изменять его из реакта можно быстро и просто.

после изменения virtual DOM происходит сверка. то есть процесс, который сравнивает новое дерево и изменённым. если изменён корневой узел, то он перерисовывается полностью(включая дочерние элементы). но если изменены только некоторые дочерние элементы в корневом узле, то реальный DOM перерисовывается частично. это улучшает производительность.

=======================================================
что такое children?

если родительский компонент содержит разметку, то эта разметка доступна внутри дочернего компонента через props.

родительский компонент:

	function WelcomeDialog() {
	  return (
	    <FancyBorde>
	      <h1>qwerty</h1>
	    </FancyBorder>
	  );
	}

дочерний компонент:

	function FancyBorder(props) {
	  return (
	    <div>
	      {props.children}
	    </div>
	  );
	}


=======================================================
что такое управляемые компоненты?

элементы форм в реакте обычно делаются так, что их содержимое хранится в локальном стейте или в сторе. с каждым элементом формы связан обработчик, который обновляет состояние, после этого обновляется видимое в элементе значение.

невозможно обновить значение в элементе, не изменив при этом стейт.

=======================================================
что такое HOC?

это компоннет, который принимает компонеет и возвращает новый. в этом новом посредством props появляются дополнительные входящие данные.

пример HOC это connect из redux

=======================================================
что такое хуки?

хуки позволяют заменить методы жизненного цикла и использовать локальное состояние. хуки работают только внутри функций. 

=======================================================
что такое порталы?

Обычно, когда вы возвращаете элемент из рендер-метода компонента, он монтируется в DOM как дочерний элемент ближайшего родительского узла. Но иногда требуется поместить потомка в другое место в DOM:

	render() {
	  return ReactDOM.createPortal(
	    this.props.children,
	    domNode
	  );
	}

при этом всплытие событий и контекст работают обычным образом. то есть как будто элемент был встроен в родительский компонент.

=======================================================
что такое flux-архитектура?

это паттерн, который направляет данные компонента в одну сторону. суть в том, что каждый элемент связан с состоянием. элемент можно изменить только изменив состояние. таким образом элемент может изменять себя сам или его могут изменять другие элементы, но в любом случае актуальное значение элемент будет получать единственным способом из состояния.

такой подход упрощает отладку кода и уменьшает хаос изменения данных.

Flux - это подход к проектированию. А redux - конкретная библиотека, реализующая данный подход.

=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================