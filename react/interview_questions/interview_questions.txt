зачем использовать key в цикле вывода элементов?

это необходимо для оптимизации производительности рендера элементов. например, есть список из двух элементов:

	<ul>
	  <li>Санкт-Петербург</li>
	  <li>Москва</li>
	</ul>

если добавить элемент в начало списка, 

	<ul>
	  <li>Ростов-на-Дону</li>
	  <li>Санкт-Петербург</li>
	  <li>Москва</li>
	</ul>

то остальные элементы тоже перерисуются. при наличии key дополнительной перерисовки не произойдёт.

однако, если вставить элемент в конец списка, то остальные элементы не будут перерисовываться даже в случае отсутствия key.

нежелательно в качестве key использовать index цикла.

=======================================================
что такое контекст?

контекст позволяет избежать передачи через props данных в глубокие компоненты. это делает код чище, хотя по сути появляется глобальная переменная.

внешний файл:

	const ThemeContext = React.createContext('light');

	<ThemeContext.Provider value="dark">
		<Toolbar />
	</ThemeContext.Provider>

глубоко вложенный файл:

	static contextType = ThemeContext;
	render() {
		return <Button theme={this.context} />;
	}


=======================================================
что такое виртуальный DOM?

это промежуточный слой между реальным DOM-деревом и реактом. реальное DOM-дерево изменять очень затратно с точки зрения производительности. виртуальный DOM отправляет изменения пакетами, кроме того он представляет из себя набор упрощенных элементов-объектов поэтому изменять его из реакта можно быстро и просто.

после изменения virtual DOM происходит сверка. то есть процесс, который сравнивает новое дерево и изменённым. если изменён корневой узел, то он перерисовывается полностью(включая дочерние элементы). но если изменены только некоторые дочерние элементы в корневом узле, то реальный DOM перерисовывается частично. это улучшает производительность.

=======================================================
что такое children?

если родительский компонент содержит разметку, то эта разметка доступна внутри дочернего компонента через props.

родительский компонент:

	function WelcomeDialog() {
	  return (
	    <FancyBorde>
	      <h1>qwerty</h1>
	    </FancyBorder>
	  );
	}

дочерний компонент:

	function FancyBorder(props) {
	  return (
	    <div>
	      {props.children}
	    </div>
	  );
	}


=======================================================
что такое управляемые компоненты?

элементы форм в реакте обычно делаются так, что их содержимое хранится в локальном стейте или в сторе. с каждым элементом формы связан обработчик, который обновляет состояние, после этого обновляется видимое в элементе значение.

невозможно обновить значение в элементе, не изменив при этом стейт.

=======================================================
что такое HOC?

это компоннет, который принимает компонеет и возвращает новый. в этом новом посредством props появляются дополнительные входящие данные.

пример HOC это connect из redux

=======================================================
что такое хуки?

хуки позволяют заменить методы жизненного цикла и использовать локальное состояние. хуки работают только внутри функций. 

=======================================================
что такое порталы?

Обычно, когда вы возвращаете элемент из рендер-метода компонента, он монтируется в DOM как дочерний элемент ближайшего родительского узла. Но иногда требуется поместить потомка в другое место в DOM:

	render() {
	  return ReactDOM.createPortal(
	    this.props.children,
	    domNode
	  );
	}

при этом всплытие событий и контекст работают обычным образом. то есть как будто элемент был встроен в родительский компонент.

=======================================================
что такое flux-архитектура?

это паттерн, который направляет данные компонента в одну сторону. суть в том, что каждый элемент связан с состоянием. элемент можно изменить только изменив состояние. таким образом элемент может изменять себя сам или его могут изменять другие элементы, но в любом случае актуальное значение элемент будет получать единственным способом из состояния.

такой подход упрощает отладку кода и уменьшает хаос изменения данных.

Flux - это подход к проектированию. А redux - конкретная библиотека, реализующая данный подход.

=======================================================
что такое мемоизация?

допустим имеем родительский компонент, который получает пропсы и дочерний компонент, который не получает пропсы. 

мемоизация это проверка поступивших в родительский компонент данных. если они действительно новые, то перерисовка беспропсового компонента происходит. а если те же самые, то перерисовки не происходит.

	import React from 'react'

	function Page11(props) {
	  console.log('11')
	  return(
	    <>
	      page11
	    </>
	  )
	}

	export default React.memo(Page11);


хук useMemo работает так же, но на уровне вложенных функций.

=======================================================
=======================================================
что такое react?

это библиотека для отрисовки пользовательского интерфейса. 

=======================================================
Какие библиотеки в основном используете вместе в React?

react-redux - для организации потоков данных.

react-router-dom - для организации роутинга.

axios - для отправки запросов.

redux-thunk - для использования thunk

=======================================================
State и props, в чем их разница?

props это входные данные, которые получает функциональный компонент для отрисовки. в классовом компоненте используется this.props.

state это внутреннее сосотояние компонента, которое не связано в глобальным состоянием. в функциональном компоненте state управляется при помощи хука useState. в классовом компоненте хуков нет поэтому используется this.state

=======================================================
Какие методы жизненного цикла вы знаете? 

в классовом компоннете существуют методы цикла:
	componentDidMount,
	componentDidUpdate,
	componentWillUnmount

они срабатывают соответственно при создании, обновлении, удалении компонента.

кроме того в классовом компоненте есть:
	constructor(props),
	render()

в функциональном компоненте удобно использовать хук useEffect(). его можно настроить на единичное срабатывание или срабатывание после обновления определённых данных.

=======================================================
В чем разница между Component и PureComponent?

в классовых компонентах существует хук shouldComponentUpdate. он проверяет старый стейт и новый стейт. в результате возвращает булево значение. на основе которого происходит или не проиходит перерисовка компонента.

в более поздних версиях можно вместо shouldComponentUpdate использовать class TestC extends React.PureComponent. он делает то же самое, но незаметно.

для функциональных компонентов можно использовать React.memo(comp). смысл такой же.

PureComponent не срабатывает для случая стрелочных функций и bind(). потому что они при каждом выполнении возвращают новый экземпляп функции.

=======================================================
В чем отличие между функциональным компонентом и компонентов в виде класса?

функциональный компонент представляет из себя обычную js-функцию, которая возвращает jsx. она использует хуки для управления состоянием и жизненным циклом. 

классовый компонент это js-класс. он может наследоваться от других компонент. в нём есть спец. методы для управления жизненным циклом, инициализации и отрисовки jsx.

=======================================================
Какие виды компонентов ты знаешь? С какими приходилось работать? (function, class, HOC)

существуют функциональные компоненты, классовые компоненты и компоненты высшего порядка. HOC принимает компонент и возвращает компонент, при этом передавая в возвращаемый компонент дополнительные входные данные.


=======================================================
Что такое неконтролируемые компоненты?

НК не используют flux-подход. то есть перерисовка конкретного в них не осуществляется после изменения в глобальном глобальном или локальном хранилище. примером может служить input, не связанный со стором или стейтом. его значение изменяется после внесения изменений пользователем, глобальный или локальный стор про это не знает

=======================================================
Что такое refs? Какой параметр принимает? Для чего они используются?

refs используются для создания ссылки на DOM-узел. это аналог getElementById.

this.myRef = React.createRef();
return <div ref={this.myRef} />;
this.myRef.focus();

refs можно использовать и в классовых компонентах, и в функциональных.

=======================================================
Какой метод жизненного цикла есть у React, чтобы отлавливать ошибки? 

ComponentDidCatch, getDerrivedStateFromError работают как сблоки try/catch и только в классовых компонентах.

getDerrivedStateFromError срабатывает когда ошибка случается на этапе рендера. используется для подмены части DOM:

	export default class App extends Component { 
	  state = { 
	    error: false
	  }; 
	  
	  static getDerivedStateFromError(error) { 
	    return { 
	      error: true, 
	    }; 
	  } 
	  
	  render() { 
	    return ( 
	      <React.StrictMode> 
	        <div> 
	          {this.state.error ? <div>Some error</div> : <GFGComponent />} 
	        </div> 
	      </React.StrictMode> 
	    ); 
	  } 
	} 
	  
	class GFGComponent extends Component { 
		render() { 
			return <h1>qwerty</h1>; 
		} 
	} 



componentDidCatch срабатывает после рендера, то есть на этапе ожидания пользоватльского ввода. используется для фиксации ошибок в логе.


=======================================================
Основная причина проблем с производительностью в React?

после рендера родительского компонента происходит перерендер дочерних компонентов(даже если в дочерних ничего не менялось). чтобы этого избежать нужно использовать механиз мемоизации. в частности хук useMemo и React.memo

=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================