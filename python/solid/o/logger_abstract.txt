Самый простой пример нарушения принципа открытости/закрытости – использование конкретных объектов без абстракций. Предположим, что у нас есть объект SmtpMailer. Для логирования своих действий он использует Logger, который записывает информацию в текстовые файлы.


public class Logger
{
    public void Log(string logText)
    {
        // сохранить лог в файле
    }
}
  
public class SmtpMailer
{
    private readonly Logger logger;
  
    public SmtpMailer()
    {
        logger = new Logger();
    }
  
    public void SendMessage(string message)
    {
        // отсылка сообщения
  
        logger.Log(string.Format("Отправлено '{0}'", message));
    }
}


И тоже самое происходит в других классах, которые используют Logger. Такая конструкция вполне жизнеспособна до тех, пока мы не решим записывать лог SmptMailer'a в базу данных. Для этого нам надо создать класс, который будет записывать все логи не в текстовый файл, а в базу данных



Но ведь по принципу единственности ответственности не SmptMailer отвечает за логирование, почему изменения дошли и до него? Потому что нарушен наш принцип открытости/закрытости. SmptMailer не закрыт для модификации. Нам пришлось его изменить, чтобы поменять способ хранения его логов.


В данном случае защитить SmtpMailer поможет выделение абстракции. Пусть SmtpMailer зависит от интерфейса ILogger