python это много поточный язык. то есть одновременно могут выполняться несколько потоков(функций/программ)

import random
import time
from threading import Thread
 
class MyThread(Thread):  
    def __init__(self, name):
        Thread.__init__(self)
        self.name = name
    
    def run(self):
        amount = 3
        time.sleep(amount)
        msg = "%s is running" % self.name
        print(msg)
    
def create_threads():
    for i in range(5):
        name = "Thread #%s" % (i+1)
        my_thread = MyThread(name)
        my_thread.start()
 
 
if __name__ == "__main__":
    create_threads()

# пример запуска не через класс:

import threading
import time

running = True

def f(delay):
    while running:
        time.sleep(delay)

th = threading.Thread(target=f, args=(0.5,))
th.start()

for i in range(10):
    time.sleep(0.7)

running = False

th.join()

===============================
GIL это блокировщик птоков. если более одного потока имеют доступ к общим данным, то возможна ситуация когда они несогласованно будут менять эти данные.
GIL делает так чтобы в каждый период времени был активен только один поток, а остальные заморожены. эти периоды очень малы.

===============================
перед исполнением исходный код транслируется в байт-код, который хранится в .pyc-файлах. байт-код запускает интерпретатор.

JIT: но возможно во время исполнения программы байт-код компилировать в машинный код, это улучшает скорость выполнения. при этом файлы с машинным кодом в файловой системе не сохраняются и существуют в оперативной памяти только во время исполнения программы.

AOT: это вид компиляции, при которой создаются в файловой системе файлы с машинным кодом.



===============================
процессы выделяются ОС для программ. процесс может взаимодействовать только с дочерними процессами. под процесс выделяется определённое количество памяти.

потоки существуют внутри процесса. они пользуются памятью, которая есть в процессе. они могут взаимодействовать друг с другом.

существуют различные способы переключения потоков:
lock - в определённый момент активне только один поток, остальные запомнили своё состояние и уснули.
rlock - позволяет блокировать поток внутри уже блокированного потока

def get_both_parts():
    lock.acquire()
    try:
        first = get_first_part()    # внутри тоже есть lock.acquire()
        second = get_second_part()  # внутри тоже есть lock.acquire()
    finally:
        lock.release()
    return first, second


семафор - ограничивает число потоков, которые имеют доступ к ресурсу

Внутри семафора - счетчик, в отличии от объекта блокировки, в которой просто флажок. Семафор блокирует поток только когда более заданного числа потоков пытаются захватить семафор. Счетчик уменьшается когда семафор захватывается и увеличивается когда семафор освобождается.

например для семафора, инициализированного 5-кой, при очередном acquire цифра будет уменьшаться. а при очередном release - увеличиваться.
таким образом при нуле доступ к разделяемому ресурсу будет заблокирован.

BoundedSemaphore, который считает ошибкой вызовы release, для которых до этого не был вызван метод acquire. а обычный семафор не считает

===============================
есть ещё механизм преключения птоков, основанный на событиях.

import threading
import time
import logging

logging.basicConfig(level=logging.DEBUG,
                    format='(%(threadName)-9s) %(message)s',)
                    
def wait_for_event(e):
    logging.debug('wait_for_event starting')
    event_is_set = e.wait()
    logging.debug('event set: %s', event_is_set)

if __name__ == '__main__':
    e = threading.Event()
    t1 = threading.Thread(name='blocking', 
                      target=wait_for_event,
                      args=(e,))
    t1.start()

    logging.debug('Waiting before calling Event.set()')
    time.sleep(3)
    e.set()
    logging.debug('Event is set')


,здесь wait() останавливает выполнение до того того как сработает set().

clear() это обратная операция для set()

-----------------------------

однако возможно обойтись без set(), если указать время задержки в wait(3)

import threading
import time
import logging

logging.basicConfig(level=logging.DEBUG,
                    format='(%(threadName)-9s) %(message)s',)
                    
def wait_for_event(e):
    logging.debug('wait_for_event starting')
    event_is_set = e.wait(3)
    logging.debug('event set: %s', event_is_set)

if __name__ == '__main__':
    e = threading.Event()
    t1 = threading.Thread(name='blocking', 
                      target=wait_for_event,
                      args=(e,))
    t1.start()

    logging.debug('Waiting before calling Event.set()')
    logging.debug('Event is set')

===============================

операции исполняются в три этапа. В первом этапе, интерпретатор извлекает текущее значение счетчика, после чего подсчитывает новое значение, и наконец, вписывает новое значение обратно в переменную.

Атомарная операция – это операция, которая осуществляет только один этап выполнения задачи, без каких либо шансов того, что другой поток получит контроль.

===============================
в python потоки переключаются при помощи GIL. этот переключатель срабатывает каждые 5 милисекунд и переключает потоки по очереди. таким образом в определённый момент активен только единственный поток. 

GIL включен по умолчанию, но его можно отключить. в этом случае потоки смогут обращаться в одному ресурсу одновременно.

возможно программно ставить и снимать блокировки с потока. но важно не заблокировать все потоки(deadlock): ситуация, когда ни один поток не имеет права действовать и программа зависает или рушится.

для операций с файлами и сетевых операций GIL не действует потому что это системные объекты, а не питоновские.


===============================
1. процессы существуют на уровне операционной системы. она при создании очередного процесса выделяет ему ресурс, в первую очередь в виде кусочка оперативной памяти.

2. если в системе существуют несколько процессов, то они не могут взаимодействовать.

3. например если в одном процессе запущен браузер, а во втором процессе запущена игра, то игра никак не может узнать какие вкладки браузера открыты в данный момент.

4. при этом если процесс браузера породит дочерний поток(например в виде отдельного окна для диспетчера задач браузера), то они могут взаимодействовать потому что связаны отношением «родитель-наследник».

5. потоки создаются средствами языка программирования и существуют в пределах процесса.

6. при этом они могут взаимодействовать в пределах своего процесса.

7. например иметь доступ к переменной: менять её, удалять и т.д.

8. а также получать друг от друга сигналы типа mutex, semafor и т.д.

9. при этом потоки, которые живут в разных процессах не могут взаимодействовать.

10. если завершается процесс, то завершаются все его потоки тоже.

11. процессы выполняются по очереди. ОС выделяет каждому определённое время. в это время он выполняется, а остальные процессы не активны. далее по очереди каждый процесс становится активным, а остальные неактивными

12. ОС сама решает по какому принципу усыплять и оживлять процессы. в зависимости от типа ОС этот принцип бывает разный

===============================
когда интерпретатор python-а запускает программу, то выделяется отдельный процесс.
далее програмист средствами языка программирования может создать несколько потоков в этом процессе и загрузить их(потоки) вычислениями.
при этом не имеет значения количество ядер процессора - то есть ОС сама будет решать какие ядра использовать для вычислений.
вследствие этого невозможно простым способом предоставить первое ядро для вычисления только первого потока, а второе ядро для вычисления только второго потока.
после старта программы потоки могут иметь доступ к её переменным и менять их.
однако, это будет происходить последовательно потому что существует GIL.
GIL делит время исполнения на малые периоды(0.005сек.) и разрешает в каждый отдельный период быть активным только одному потоку, а остальные в это время неактивны. далее становится активным следующий поток, а остальные засыпают. и так далее...
если атомарная операция вычисления в потоке занимает времени меньше чем 0.005сек, то не имеет смысла делить вычисления на несколько потоков потому что в из-за большого количества переключений два потока выполнять задачу медленнее чем один поток.
верно и обратное: то есть если атомарная опреация занимает времени много больше чем 0.005сек, то вычисления в двух потоках выполнятся быстрее чем в одном.

===============================
Вы можете выполнить следующие шаги, чтобы реализовать новый поток, используя модуль <threading>

Построить подкласс от класса <Thread>.
Переопределение <__init__(self [,args])> как способ поставки аргументов в соответствии с требованиями.
Затем переопределить метод <run(self [,args])> для кодирования бизнес-логики потока.
После того, как вы определите новый подкласс <Thread>, вы должны создать экземпляр, чтобы начать новый поток. Затем, вызовите метод <start()>, чтобы инициировать его. Это в конечном счете вызовет метод <run()> для выполнения бизнес – логики.

===============================
.join() ждёт завершения потока.
принудительно завержиь поток невозможно.
чтобы завершить поток принудительно нужно использовать флаги
    class Task():
        def __init__(self):
            self.r = True

        def kill(self):
            self.r = False

        def run(self, n):
            whilw self.r:
                # some code

===============================
Python-приложение не завершается, пока работает хоть один его поток. Но есть особые потоки, которые не мешают закрытию программы и останавливается вместе с ней. Их называют демонами (daemons).

===============================
многопоточность может быть кооперативной и вытесняющей.
в кооперативной многопоточности потоки сами пеердают управление друг другу.
в вытесняющей многопоточности ОС по своему усмотрению переключает потоки.

===============================
асинхронность применима только к операциям воода-вывода.

===============================
многопроцессорность - многопоточность - асинхронность

===============================
1. реальная мультипроцессорномть использует для каждого процесса отдельное ядро
2. в python не существует реальной многопроцессорности, а используется модуль multiprocessing. который выполняет операции в различных процессах, но имеет каналы коммуникации между этими процессами.
3. при этом количество ядер, задействованных в вычислениях контролируется ОС и python на это повлиять не может
4. мультипоточность это когда вычисления производятся внутри процесса несколькими потоками
5. эти потоки имеют доступ к общим ресурсам и удобную коммуникацию между собой
6. существует набор моделей управления потоками: lock, semafor, events, etc. при их помощи потоки могут блокировать/освобождать соседние потоки.
7. эти модели реализуют модель кооперативной многозадачности
8. существует ещё вытесняющая много задачность. это когда ОС(или GIL) сама решает когда переключаться между потоками
9. в однопоточном приложении можно более эффективно работать с IObounded-операциями (например ожидание ответа http), если использовать асинхронность
10. таким образом для повышения эффективности программы удобно использовать(в порядке убывания): мультипроцессорность, мультипоточность, асинхронность

===============================
===============================
===============================
===============================
===============================
===============================
===============================
===============================
===============================
===============================
===============================
===============================
===============================