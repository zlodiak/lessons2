Асинхронное программирование — это потоковая обработка программного обеспечения / пользовательского пространства, где приложение, а не процессор, управляет потоками и переключением контекста. В асинхронном программировании контекст переключается только в заданных точках переключения, а не с периодичностью, определенной CPU.

======================================
Один человек ставит кастрюлю на плиту, ждёт пока она закипит, закидывает пельмени, ждёт пока сварятся, снимает, ставит вторую, ждёт пока закипит... - последовательное однопоточное выполнение.

Один человек ставит две кастрюли на плиту, как только одна из них закипела, забрасывает пельмени и т.д. - асинхронное выполнение.

Два человека ставят две кастрюли... - многопоточное выполнение.

======================================
на одном ядре возможно только конкурентность.
на множестве ядер возможен параллелизм.
в питоне потоки по очереди блокируютс GIL, они конкурируют между собой. GIL гарантирует, что потоки не будут выполняться параллельно.

======================================
======================================
Event loop позволяет организовать логику "когда произошло А, сделай В". Проше говоря, event loop наблюдает за тем, не произошло ли "что-то", за что он отвечает, и если это "что-то" случилось, он вызывает код, который должен обработать это событие. Python включил event loop в стандартную библиотеку в виде asyncio начиная с версии Python 3.4.

сопрограмма это объект, который реализует методы, добавленные генераторам в рамках PEP 342

функция, которая используется как сопрограмма помечается async. вместо yield используется return или await.

======================================
======================================
======================================
примеры:

блокирующий:

    import asyncio

    async def callee():
        print('Hello')

    async def caller():
        await callee()
        print('World')

    asyncio.run(caller())


неблокирующий:

    import asyncio

    async def callee():
        print('Hello')

    async def caller():
        asyncio.create_task(callee())
        print('World')

    asyncio.run(caller())


неблокирующий с несколькими задачами:

    import asyncio

    async def callee():
        print('Hello')

    async def caller():
        await callee()
        print('World')

    async def callee2():
        print('Hello2')

    async def caller2():
        await callee2()
        print('World2')

    async def main():
        asyncio.gather(
            asyncio.create_task(caller()),
            asyncio.create_task(caller2()),
        )

    asyncio.run(main())



======================================
======================================
про футуры здесь:
https://ru.stackoverflow.com/questions/902586/asyncio-%D0%9E%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-tasks-%D0%BE%D1%82-future

======================================
======================================
======================================
======================================
======================================
======================================
======================================
======================================
======================================
======================================
======================================
======================================
======================================
======================================
======================================