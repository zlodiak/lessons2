python это много поточный язык. то есть одновременно могут выполняться несколько потоков(функций/программ)

import random
import time
from threading import Thread
 
class MyThread(Thread):  
    def __init__(self, name):
        Thread.__init__(self)
        self.name = name
    
    def run(self):
        amount = 3
        time.sleep(amount)
        msg = "%s is running" % self.name
        print(msg)
    
def create_threads():
    for i in range(5):
        name = "Thread #%s" % (i+1)
        my_thread = MyThread(name)
        my_thread.start()
 
 
if __name__ == "__main__":
    create_threads()

# пример запуска не через класс:

import threading
import time

running = True

def f(delay):
    while running:
        time.sleep(delay)

th = threading.Thread(target=f, args=(0.5,))
th.start()

for i in range(10):
    time.sleep(0.7)

running = False

th.join()

===============================
GIL это блокировщик птоков. если более одного потока имеют доступ к общим данным, то возможна ситуация когда они несогласованно будут менять эти данные.
GIL делает так чтобы в каждый период времени был активен только один поток, а остальные заморожены. эти периоды очень малы.

===============================
перед исполнением исходный код транслируется в байт-код, который хранится в .pyc-файлах. байт-код запускает интерпретатор.

JIT: но возможно во время исполнения программы байт-код компилировать в машинный код, это улучшает скорость выполнения. при этом файлы с машинным кодом в файловой системе не сохраняются и существуют в оперативной памяти только во время исполнения программы.

AOT: это вид компиляции, при которой создаются в файловой системе файлы с машинным кодом.



===============================
процессы выделяются ОС для программ. процесс может взаимодействовать только с дочерними процессами. под процесс выделяется определённое количество памяти.

потоки существуют внутри процесса. они пользуются памятью, которая есть в процессе. они могут взаимодействовать друг с другом.

существуют различные способы переключения потоков:
mutex - в определённый момент активне только один поток, остальные запомнили своё состояние и уснули.
семафор - ограничивает число потоков, которые имеют доступ к ресурсу
событие - при наступлении события управление передаётся другому потоку

===============================
в python потоки переключаются при помощи GIL. этот переключатель срабатывает каждые 5 милисекунд и переключает потоки по очереди. таким образом в определённый момент активен только единственный поток. 

GIL включен по умолчанию, но его можно отключить. в этом случае потоки смогут обращаться в одному ресурсу одновременно.

возможно программно ставить и снимать блокировки с потока. но важно не заблокировать все потоки(deadlock): ситуация, когда ни один поток не имеет права действовать и программа зависает или рушится.


===============================
1. процессы существуют на уровне операционной системы. она при создании очередного потока выделяет ему ресурс, в первую очередь в виде кусочка оперативной памяти.

2. если в системе существуют несколько процессов, то они не могут взаимодействовать.

3. например если в одном процессе запущен браузер, а во втором процессе запущена игра, то игра никак не может узнать какие вкладки браузера открыты в данный момент.

4. при этом если процесс браузера породит дочерний поток(например в виде отдельного окна для диспетчера задач браузера), то они могут взаимодействовать потому что связаны отношением «родитель-наследник».

5. потоки создаются средствами языка программирования и существуют в пределах процесса.

6. при этом они могут взаимодействовать в пределах своего процесса.

7. например иметь доступ к переменной: менять её, удалять и т.д.

8. а также получать друг от друга сигналы типа mutex, semafor и т.д.

9. при этом потоки, которые живут в разных процессах не могут взаимодействовать.

10. если завершается процесс, то завершаются все его потоки тоже.

11. процессы выполняются по очереди. ОС выделяет каждому определённое время. в это время он выполняется, а остальные процессы не активны. далее по очереди каждый процесс становится активным, а остальные неактивными

12. ОС сама решает по какому принципу усыплять и оживлять процессы. в зависимости от типа ОС этот принцип бывает разный

===============================
когда интерпретатор python-а запускает программу, то выделяется отдельный процесс.
далее програмист средствами языка программирования может создать несколько потоков в этом процессе и загрузить их(потоки) вычислениями.
при этом не имеет значения количество ядер процессора - то есть ОС сама будет решать какие ядра использовать для вычислений.
вследствие этого невозможно простым способом предоставить первое ядро для вычисления только первого потока, а второе ядро для вычисления только второго потока.
после старта программы потоки могут иметь доступ к её переменным и менять их.
однако, это будет происходить последовательно потому что существует GIL.
GIL делит время исполнения на малые периоды(0.005сек.) и разрешает в каждый отдельный период быть активным только одному потоку, а остальные в это время неактивны. далее становится активным следующий поток, а остальные засыпают. и так далее...
если атомарная операция вычисления в потоке занимает времени меньше чем 0.005сек, то не имеет смысла делить вычисления на несколько потоков потому что в из-за большого количества переключений два потока выполнять задачу медленнее чем один поток.
верно и обратное: то есть если атомарная опреация занимает времени много больше чем 0.005сек, то вычисления в двух потоках выполнятся быстрее чем в одном.

===============================
Вы можете выполнить следующие шаги, чтобы реализовать новый поток, используя модуль <threading>

Построить подкласс от класса <Thread>.
Переопределение <__init__(self [,args])> как способ поставки аргументов в соответствии с требованиями.
Затем переопределить метод <run(self [,args])> для кодирования бизнес-логики потока.
После того, как вы определите новый подкласс <Thread>, вы должны создать экземпляр, чтобы начать новый поток. Затем, вызовите метод <start()>, чтобы инициировать его. Это в конечном счете вызовет метод <run()> для выполнения бизнес – логики.

===============================
===============================
===============================
===============================
===============================
===============================
===============================