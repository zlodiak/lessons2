словарь состоит из неупорядоченных пара: значение. ключом может быть только хэшируемый объект(встроенные неизменяемые типы). пользовательские типы(классы) технически тоже могут быть ключами, но использовать их можно на свой страх.

пользовательский тип, если реализует хэшируемость, то должен иметь методы: __hash__, __eq__. потому что если объекты равны, то должны быть равны хэши этих объектов.

почти во всех случаях сложность операций O(1). но в памяти словарь занимает много места потому что связан с хэш-таблицей.

ключ-значение хранятся в случайном порядке.

========================
можно создать свой словарь. и определить метод, который будет срабатывать когда не найдётся индекс и возвращать ключ/значение. об этом методе уже знает __getitem__

class myDict(dict):
    def __missing__(self, x):
        print('no key', str(x))
        self[x] = 'empty'
        return self[x]


my_dict = myDict()
my_dict['qwe'] = 123

print(my_dict['asd'])

но можно поступить проще:
a = {
    1: 111,
    2: 222
}
b = a.get(10, [])		# вернёт [], если нет такого ключа
print(b)

========================
a = {'q': 33, 1: 'w', 3: [1, 2, 3]}
print(a['q'])		# 33
a['q'] = 22 		# {'q': 22, 1: 'w', 3: [1, 2, 3]}
len(a)		# 3
1 in a 		# True

london2 = london.copy()  # делает копию по значению, но не по ссылке

{}   False
{.....}  True

keys() - запрашивает ключи
values() - запрашивает значения
items() - запрашивает (ключ: значение)

========================
словари и множества организованы на основе хэш-таблицы(ХТ).

ХТ это разреженный массив. примерно две трети состоит из пустых значений. По мере изменения размера он время от времени перестраивается в новый участок памяти, изменяя количество своих элементов. Поэтому изменять словарь в цикле плохая идея(Нужно сначала прогнать цикл, а затем внести изменения).

Хэш с одной стороны связан с ключом, с другой стороны связан со значением. Каким-то хитрым, но быстрым способом(подробности я не понял, но, думаю, можно их пропустить) при запросе элемента через ключ, ключ сопоставляется с хэшем. При этом если поиск не попал в пустую ячейку(я чуть выше писал, что ХТ приблизительно на две трети состоит из незаполненных значений) и если найдено соответствие, то выдаётся значение.
если возник конфликт, то он разрешается

Таким образом можно запросить значение по ключу: arr[key]. Поиск происходит очень быстро потому что не приходится перебирать все значения(пусть даже двоичным поиском) как например в случае со списком.

========================
========================
========================
========================
========================
========================
========================
========================
========================
========================
========================
========================
========================
========================
========================
========================
========================