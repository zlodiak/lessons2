функция является объектом. список его атрибутов можно посмотреть так: dir(func_name).

существуют функции высшего порядка, то есть которые могут принимать функцию в качестве аргумента и возвращать функцию(например декоратор).

если функция не заканчивается инструкцией return, то она возвращает None

=======================
map, filter, reduce можно заменить списковыми включениями:

def func(a): return a + 10

s = list(map(func, range(3)))
print(s)

d = [func(n) for n in range(3)]
print(d)

=======================

# map analog
q = [1,2,3,4]
b = [x+10 for x in q]
print(b)

# filter analog
q = [1,2,3,4]
b = [x for x in q if x > 2]
print(b)

# reduce analog
q = [1,2,3,4]
b = sum([x for x in q])
print(b)


=======================
лямбда-функция это короткая безымянная функция, по сути синтаксический сахар:
s = list(map(lambda n: n + 10, range(3)))
print(s)

=======================
если у объекта есть __call__, то его можно вызывать как функцию.

=======================
функции(и методы класса) можно вызывать динамически:

class Logger:
    def __init__(self, type):
        self.log = []
        self.type = type

    def makeLog(self, message):
        getattr(self, self.type)(message)

    def printLog(self, message):
        print('error: ', message)

    def fillLog(self, message):
        self.log.append(message)

=======================
=======================
аргументы функции бывают именованные и позиционные. 
вызывающая функция должны указывать именно то количество аргументов, которое принимает функция. или использовать *args, **kwargs. при этом при вызове сначала указываются обычные агрументы, а затем *аргументы, **аргументы

можно передать переменное количество аргументов двумя способами:
*args для неименованных аргументов;
**kwargs для именованных аргументов.

========================

def func(a, b, c, *args):
  print(a, b, c, args[0])
func(1, 2, 3, 4)

========================

def func(a, b, c, **kwargs):
  print(a, b, c, kwargs)
func(1, 2, 3, var=4)

========================
пример передачи только именованных аргументов:
def func(name, family):
  print(name, family)
func(family=456, name=123)

========================
все типы аргументов передаются так:
def func(a, b, c, *args, name, family, **kwargs):
  print(a, b, c)
  for arg in args: print(arg)
  print(name, family)
  for arg in kwargs.items(): print(arg)
func(1, 2, 3, 4, 5, name='serg', family='kalinin', var=6, vari=7)

========================
def func(a, *b, qqq, **www):
    print(a, b)
    print(qqq, www)

func(12, 13, 14, qqq=0, q=1, qq=2, w=3, ww=4)

# 12 (13, 14)
# 0 {'q': 1, 'w': 3, 'qq': 2, 'ww': 4}

=======================
просто звёздочка означает, что после идут именованные аргументы
def func(q, w, *, qwe):
  pass

=======================
=======================
Memoization – свойство функций сохранять (кешировать) результаты вычислений, дабы не вычислять в последствии повторно.

Допустим, у нас есть некая функция bigfunc, результат которой зависят только от переданных в нее аргументов, а сложность вычислений достаточно большая. Естественно нам не хотелось бы производить вычисления при каждом вызове bigfunc если она уже вызывалась ранее с теми же параметрами. Тут то нам на помощь и приходит memoization.

Для python декоратор для функции будет выглядеть следующим образом:

import cPickle
def memoized(func):
    memory = {}
    def memo(*args,**kwargs):
       hash = cPickle.dumps((args, sorted(kwargs.iteritems())))
       if hash not in memory:
           memory[hash] = func(*args,**kwargs)
       return memory[hash]
    return memo

Далее, нам достаточно объявить bigfunc как

@memoized
def bigfunc(…):
…

Или переопределить, если она уже объявлена:

bigfunc = memoized(bigfunc)

в результате создаётся объект, ключи которого являются хешам аргументов, а значения результатом функции


=======================
есть возможность частичного вызова функций:

from  functools import partial
def myfun(a, b): return a + b
myfun1 = partial(myfun, 1)
print myfun1(2)

=======================
Давайте разберемся сначала с самим какими побочными эффектами имеем дело. Напишем вот такую функцию:

def foo(param=[]):
    print(param)

>>> foo()
[]
Сколько ее не вызывай, значение выводимое на экран не изменится. Никаких побочных эффектов. Но если ее модифицировать вот так:

def foo(param=[]):
    param.append(1)
    print(param)
То обнаружим, что значение на экране будет меняться в зависимости от того сколько раз вызвана функция:

>>> foo()
[1]
>>> foo()
[1,1]
>>> foo()
[1,1,1]
Но мы ведь хотели не этого. Такое поведение функций - один из лидеров разного рода списков "Х самых странных вещей в Python". Хотя, если разобраться с внутренней кухней языка, то все встанет на свои места и "странность" превратится в логичное поведение.

Почему же так получилось? Все из-за того, что функция - это объект, как и все другие сущности в питоне. При создании объекта дефолтные значения параметров упаковались в tuple foo.func_defaults.

Списки в питоне - тип изменяемый. А объект функции создается один раз. Так что объект на который ссылается foo.func_defaults[0] и param внутри функции один и тот же.

=======================
=======================
=======================