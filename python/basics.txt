типы данных:

---------------------------
логический:
True/False

not
or
and

---------------------------
строчный:
строка неизменяема.
s = 'qwerty'
s[1] = 'x' #приведёт к ошибке

имеет методы:
s = 'qwerty'
d = s.upper()
print(d) 	#QWERTY

string1 = 'Hello, hello, hello, hello'
string1.count('hello')  		# 3

string1 = 'interface FastEthernet0/1'
string1.find('Fast') 		# 10

string1 = 'FastEthernet0/1'
string1.replace('Fast', 'Gigabit')   # 'GigabitEthernet0/1'

strip()
lstrip()
rstrip()

startswith()
endswith()

upper(), lower(), swapcase(), title()

Метод split() разбивает строку на части, возвращает список

>>> print('qwerty{0}---{1}'.format(333, 444))
qwerty333---444

>>> print("%s---%s---%s" % ('aaa', 'sss', 'ddd'))
aaa---sss---ddd



---------------------------
численный:
значение ограничено только объёмом оперативной памяти.
числа могут быть целые(23) или с плавающей точкой(23.5).
дробные значения представляются с отпределённой точностью: 
0.1 + 0.2 = 0.300000000004
0.1 + 0.1 = 0.2

int + float = float

Нулевые значения — ложь, 
ненулевые значения — истина, 
отрицательные значения - истина.

---------------------------
список:
аналогичен javascript-массиву: a = ['q', 'w', 4, [1, 2]]
значения упорядочены, сохраняют порядок всегда.
print(a[1])  # w

срез списка:
a = ['q', 'w', 4, [1, 2]]
print(a[0: 2])	# ['q', 'w']
print(a[:3])		# ['q', 'w', 4]
print(a[:])			# получим копию(передача по значению)

добавление:
a = ['q', 'w', 4, [1, 2]]
a.append(5)				# ['q', 'w', 4, [1, 2], 5]
a.extend([3, 4])	# ['q', 'w', 4, [1, 2], 5, 3, 4]
print(a + [5, 6])	# ['q', 'w', 4, [1, 2], 5, 3, 4, 5, 6]
a.insert(1, 9)		# ['q', 7, 9, 'w', 4, [1, 2], 5, 3, 4] происходит вставка 9 сдвиг после позиции 1

удаление:
a = ['q', 'w', 4, [1, 2], 'w', 2, 'w']
del a[1]			# ['q', 4, [1, 2], 'w', 2, 'w']
a.remove(1)		# ['q', 4, [1, 2], 2, 'w']  удаляет первое вхождение
b = a.pop()		# ['q', 4, [1, 2], 2]    вернёт удалённое значение
b = a.pop(2)	# [1, 2]


поиск:
a = ['q', 'w', 4, [1, 2], 'w']
a.count('w')			# 2 (первая позиция)
'w' in a 					# True
a.index('2')			# 1		если не найдёт, то выбрасывается исключение

[] - False
[....] True

сортировка:
a = [1, 50, 10, 15]
a.sort()
print(a)
# [1, 10, 15, 50]

Метод join() собирает список строк в одну строку с разделителем, который указан перед join:
vlans = ['10', '20', '30']
b = ','.join(vlans)
print(b)
# '10,20,30'

---------------------------
кортеж:
кортеж это неизменяемый список
a = (1, 2, 'w', [3, 4], 'w', 4)
a[2] 	# w
a[-1] 	# 4

но можно взять срез:
a[1:3]  # (2, 'w')

проверить вхождение:
a.index('w') 	# 2

() - False
(....) True

---------------------------
множество:
это список, который содежржит неупорядоченные уникальные значения
a = {1, 2, 'w'}
возможно создать множество из списка:
a = set([1, 2, 3])		# {1, 2, 3}
len(3)		# 3

Нельзя создать пустое множество с помощью литерала (так как в таком случае это будет не множество, а словарь):

изменение:
a = {1, 2, 3}
a.add(4)		# {1, 2, 3, 4}
a.update({666, 777})	# {1, 2, 3, 4, 777, 666}

удаление:
a = {1, 2, 3, 4, 777, 666}
a.discard(666)		# {1, 2, 3, 4, 777}
a.remove(666)  	 	# то же самое, но если такого элемента нет, то выбросится исключение
b = a.pop()  			# {2, 3, 4, 777}  удаляется произвольный элемент
a.clear()					# {}

основные операции:
a = {1, 2, 3, 4, 777, 666}
b = {2, 3, 4}
c = {6, 7}
3 in a 		# True
a.union(c)		#  {1, 2, 3, 4, 777, 666, 6, 7}
a.intersection(b) 		# {2, 3, 4}
a.symmetric_difference(b) 	# возвращает уникальные элементы из двух множеств
b.issubset(a) 		# True
a.issuperset(b)		# True

{} False
{...}  True

---------------------------
словарь:
Словарь — это неупорядоченное множество пар ключ—значение. значение должно быть задано
a = {'q': 33, 1: 'w', 3: [1, 2, 3]}
print(a['q'])		# 33
a['q'] = 22 		# {'q': 22, 1: 'w', 3: [1, 2, 3]}
len(a)		# 3
1 in a 		# True

london2 = london.copy()  # делает копию по значению, но не по ссылке

{}   False
{.....}  True

keys() - запрашивает ключи
values() - запрашивает значения
items() - запрашивает (ключ: значение)

---------------------------
байтовая стока:
хранит последовательность, каждому символу которой соответствует число из диапазона(0-255).
её невозможно изменить

b = b'qwerty'
print(b)
b'qwerty'
print(b[0])
113
print(chr(b[0]))
q

bytearray то же самое, но изменяется
b = bytearray(b'hello world!')
b[0] = 45
print(b)
bytearray(b'-ello world!')


---------------------------
+None:
пустое значение.
None == None 		# True
остальное False
В логическом контексте None всегда является ложью, а not None — истиной.


==============================================
приведение типов:
bool(x) - преобразование к типу bool,
int(a)   - приведение к целому числу.
float([X]) - преобразование к числу с плавающей точкой.
str([object], [кодировка], [ошибки]) - строковое представление объекта. Использует метод __str__.

tuple(obj) - преобразование к кортежу.
set([object]) - создает множество.
list([object]) - создает список.
dict([object]) - преобразование к словарю.
bytes([источник [, кодировка [ошибки]]]) - возвращает объект типа bytes.
bytearray([источник [, кодировка [ошибки]]]) - преобразование к bytearray.

isdigit() - состоит ли строка только из цифр?
isalpha() позволяет проверить, состоит ли строка из одних букв
isalnum() позволяет проверить, состоит ли строка из букв и цифр
type(object) - Возвращает тип объекта.
id(object) - Возвращает "адрес" объекта. 

==============================================
управляющие конструкции:

for item in range(4):
	print(item)
# 1 2 3 4 	

---------------------------
r1 = {1: 'q', 2: 'w'}
for key, value in r1.items():
  print(key + ' => ' + value)

---------------------------
for num in range(5):
  print(num)
else:
  print("Числа закончились")

если сработал break, то else не выполняется

---------------------------
a = 5
while a > 0:
	print(a)
	a -= 1
# 5 4 3 2 1

---------------------------
break, continue действуют для for и while

---------------------------
if a == 3:
	pass
else:
	pass

if a == 3:
	pass
elif a == 2:
	pass
else:
	pass	

---------------------------
try:
  a = input("Введите первое число: ")
  b = input("Введите второе число: ")
  print("Результат: ", int(a)/int(b))
except ValueError:
  print("Пожалуйста, вводите только числа")
except ZeroDivisionError:
  print("На ноль делить нельзя")
else:
	print('исключения не было')
finally:
	print('выполняется всегда')

==============================================
области видимости и замыкания:

Python ищет переменную в таком порядке по областям видимости (до первого совпадения):
L (local) - в локальной (внутри функции)
E (enclosing) - в локальной области объемлющих функций (это те функции, внутри которых находится наша функция)
G (global) - в глобальной (в скрипте)
B (built-in) - в встроенной (зарезервированные значения Python)

встроенная область видимости реализована как модуль стандартной библиотеки. следовательно его нужно импортировать так:
import builtins
>>> dir(builtins)

но если не импортировать, то доступ к его содержимому всё равно есть.

при этом внутри функций можно переорпеделять зарезервированные слова так:
def qw():
	int = 123
	print(int(5.6))
qw()		# TypeError: 'int' object is not callable

global x объявляет переменную x глобально
nonlocal x объявляет переменную x во внешней области видимости(и только в ней)

==============================================
==============================================
передавать имя файла как аргумент скрипта и затем использовать уже указанный файл.
В модуле sys есть очень простой и удобный способ для работы с аргументами - argv.

==============================================
работа с файлами:

file = open('file_name.txt', 'r')

r - открыть файл только для чтения (значение по умолчанию)
r+ - открыть файл для чтения и записи
w - открыть файл для записи
если файл существует, то его содержимое удаляется
если файл не существует, то создается новый
w+ - открыть файл для чтения и записи
если файл существует, то его содержимое удаляется
если файл не существует, то создается новый
a - открыть файл для дополнения записи. Данные добавляются в конец файла
a+ - открыть файл для чтения и записи. Данные добавляются в конец файла

-------------------------------
читать весь файл как одну строку:
f = open('pizza.py', 'r')
text = f.read()
print(text)

или читать каждуй строку файла:
f = open('pizza.py', 'r')
for line in f:
	print(line)

readlines(). Он считывает строки файла в список:
f = open('pizza.py', 'r')
text = f.readlines()
print(text)

-------------------------------
дописать в файл:
f = open('pizza.py', 'a')
f.write('gdfgdgdfgdg')
f.close()

Метод writelines() ожидает список строк, как аргумент.
f = open('pizza.py', 'a')
v = [
	'1212\n',
	'23232\n',
	'sdaasdf\n',
	'cxzcvxcv\n',
]
f.writelines(v)
f.close()

для закрытия файла удобнее использовать with:
with open('pizza.py', 'a') as f:
	v = [
		'1212\n',
		'23232\n',
		'sdaasdf\n',
		'cxzcvxcv\n',
	]
	f.writelines(v)

==============================================
генератор и итератор

генераторное выражение:
genexpr = (x*2 for x in range(10))
next(genexpr)	# 0
next(genexpr)	# 1

----------------------------------
genexpr = [x*2 for x in range(10)]
print(genexpr)
# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

----------------------------------
итератор это объект, который инициализируется перебираемым объектом, ставит указатель на первый элемент и при помощи метода next() возвращает этот элемент, увеличивая позицию указателя
lista = [1, 2, 3]
i = iter(lista)
next(i) # 1
next(i) # 2

==============================================
модули:

импортирование состоит из трёх этапов:
1. поиск модуля(согласно приоритету путей)
2. компилирование в байт-код
3. запуск одержимого модуля, в результате которого единожды создаётся с объект с атрибутами(переменными и функциями, которые объявлены только в корне модуля)

поиск существляется(по убыванию приоритета):
1. в каталоге, из которого запущен коревой файл проекта (или каталог откуда была запущена repl)
2. в переменной среды PYTHONPATH 
(~/.profile  export PYTHONPATH=$PYTHONPATH:/home:/home/kalinin: или в /etc/.profile). 
тут подробнее про переменные среды: http://blog.sedicomm.com/2017/11/13/kak-ustanovit-i-otklyuchit-peremennye-lokalnoj-polzovatelskoj-i-sistemnoj-sredy-v-linux/
3. в каталоге системных модулей стандартной библиотеки
4. в файлах с расширением .pht

проверить иерархию путей можно так:
import sys
sys.path

==============================================
разделяемые ссылки

переменные ничего не знают о типах. тип есть только у значения переменной. значение переменной это в любом случае объект. а переменная это всего лишь ссылка.

объекты собираются сборщиком мусора, если на них не ссылается ни одна переменная. но возможны циклические переменные.

>>> a = 3
>>> b = a
>>> a = ‘spam’
в результате a=‘spam’, b=3. здесь важно, что объекты неизменяемые

>>> L1 = [2, 3, 4]
>>> L2 = L1
>>> L1[0] = 24 
в результате L1 == L2 == [24, 3, 4]. здесь важно, что объекты изменяемые

==============================================
классы

class Manager(Person):				# Наследование
def giveRaise(self, ...): 		# Адаптация(тоже можно адаптировать конструктор)
def someThingElse(self, ...): # Расширение

----------------------
перегрузка методов.

class A:
    def go(self):
        print('A!')

class B(A):
    def go(self):
        print('B!')

в классе B go() должна была выводить A!, но благодяре перегрузке выводит B!

----------------------
инкапсуляция действует только на уровне соглашений. знач подчёркивания перед переменной говорит, что она псевдоприватная. то есть может изменяться только методами этого класса.

----------------------
наследование связывает классы. при этом потомок содержит все методы и свойства родителя.
самый верхний объект для классов это object. из него наследуются методы типа __init__()

----------------------
полиморфизм это когда в различных классах методы с одинаковыми названиями выполняют различноые действия. эти классы не обязательно должны быть связаны наследованием.
перегрузка операторов это частный случай полиморфизма.
например по умолчанию метод __str__() выводит содержимое объекта в специфическом формате. потому что этого метод определён в object. но если перегрузить этот метода так:
class qwert:
	def __str__(self):
		return 'hello'

, то print(qwert())		выведет hello. мы перегрузили __str__()

----------------------
----------------------
----------------------
----------------------
----------------------
----------------------
----------------------
----------------------

==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
условие if __name__ == '__main__' проверяет, был ли файл запущен напрямую.

==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================