типы данных:

---------------------------
логический:
True/False

not
or
and

---------------------------
строчный:
строка неизменяема.
s = 'qwerty'
s[1] = 'x' #приведёт к ошибке

имеет методы:
s = 'qwerty'
d = s.upper()
print(d) 	#QWERTY

string1 = 'Hello, hello, hello, hello'
string1.count('hello')  		# 3

string1 = 'interface FastEthernet0/1'
string1.find('Fast') 		# 10

string1 = 'FastEthernet0/1'
string1.replace('Fast', 'Gigabit')   # 'GigabitEthernet0/1'

strip()
lstrip()
rstrip()

startswith()
endswith()

upper(), lower(), swapcase(), title()

Метод split() разбивает строку на части, возвращает список

>>> print('qwerty{0}---{1}'.format(333, 444))
qwerty333---444

>>> print("%s---%s---%s" % ('aaa', 'sss', 'ddd'))
aaa---sss---ddd



---------------------------
численный:
значение ограничено только объёмом оперативной памяти.
числа могут быть целые(23) или с плавающей точкой(23.5).
дробные значения представляются с отпределённой точностью: 
0.1 + 0.2 = 0.300000000004
0.1 + 0.1 = 0.2

int + float = float

Нулевые значения — ложь, 
ненулевые значения — истина, 
отрицательные значения - истина.

---------------------------
список:
аналогичен javascript-массиву: a = ['q', 'w', 4, [1, 2]]
значения упорядочены, сохраняют порядок всегда.
print(a[1])  # w

срез списка:
a = ['q', 'w', 4, [1, 2]]
print(a[0: 2])	# ['q', 'w']
print(a[:3])		# ['q', 'w', 4]
print(a[:])			# получим копию(передача по значению)

добавление:
a = ['q', 'w', 4, [1, 2]]
a.append(5)				# ['q', 'w', 4, [1, 2], 5]
a.extend([3, 4])	# ['q', 'w', 4, [1, 2], 5, 3, 4]
print(a + [5, 6])	# ['q', 'w', 4, [1, 2], 5, 3, 4, 5, 6]
a.insert(1, 9)		# ['q', 7, 9, 'w', 4, [1, 2], 5, 3, 4] происходит вставка 9 сдвиг после позиции 1

удаление:
a = ['q', 'w', 4, [1, 2], 'w', 2, 'w']
del a[1]			# ['q', 4, [1, 2], 'w', 2, 'w']
a.remove(1)		# ['q', 4, [1, 2], 2, 'w']  удаляет первое вхождение
b = a.pop()		# ['q', 4, [1, 2], 2]    вернёт удалённое значение
b = a.pop(2)	# [1, 2]


поиск:
a = ['q', 'w', 4, [1, 2], 'w']
a.count('w')			# 2 (первая позиция)
'w' in a 					# True
a.index('2')			# 1		если не найдёт, то выбрасывается исключение

[] - False
[....] True

сортировка:
a = [1, 50, 10, 15]
a.sort()
print(a)
# [1, 10, 15, 50]

Метод join() собирает список строк в одну строку с разделителем, который указан перед join:
vlans = ['10', '20', '30']
b = ','.join(vlans)
print(b)
# '10,20,30'

---------------------------
кортеж:
кортеж это неизменяемый список
a = (1, 2, 'w', [3, 4], 'w', 4)
a[2] 	# w
a[-1] 	# 4

но можно взять срез:
a[1:3]  # (2, 'w')

проверить вхождение:
a.index('w') 	# 2

() - False
(....) True

---------------------------
множество:
это список, который содежржит неупорядоченные уникальные значения
a = {1, 2, 'w'}
возможно создать множество из списка:
a = set([1, 2, 3])		# {1, 2, 3}
len(3)		# 3

Нельзя создать пустое множество с помощью литерала (так как в таком случае это будет не множество, а словарь):

изменение:
a = {1, 2, 3}
a.add(4)		# {1, 2, 3, 4}
a.update({666, 777})	# {1, 2, 3, 4, 777, 666}

удаление:
a = {1, 2, 3, 4, 777, 666}
a.discard(666)		# {1, 2, 3, 4, 777}
a.remove(666)  	 	# то же самое, но если такого элемента нет, то выбросится исключение
b = a.pop()  			# {2, 3, 4, 777}  удаляется произвольный элемент
a.clear()					# {}

основные операции:
a = {1, 2, 3, 4, 777, 666}
b = {2, 3, 4}
c = {6, 7}
3 in a 		# True
a.union(c)		#  {1, 2, 3, 4, 777, 666, 6, 7}
a.intersection(b) 		# {2, 3, 4}
a.symmetric_difference(b) 	# возвращает уникальные элементы из двух множеств
b.issubset(a) 		# True
a.issuperset(b)		# True

{} False
{...}  True

---------------------------
словарь:
Словарь — это неупорядоченное множество пар ключ—значение. значение должно быть задано
a = {'q': 33, 1: 'w', 3: [1, 2, 3]}
print(a['q'])		# 33
a['q'] = 22 		# {'q': 22, 1: 'w', 3: [1, 2, 3]}
len(a)		# 3
1 in a 		# True

london2 = london.copy()  # делает копию по значению, но не по ссылке

{}   False
{.....}  True

keys() - запрашивает ключи
values() - запрашивает значения
items() - запрашивает (ключ: значение)

---------------------------
байтовая стока:
хранит последовательность, каждому символу которой соответствует число из диапазона(0-255).
её невозможно изменить

b = b'qwerty'
print(b)
b'qwerty'
print(b[0])
113
print(chr(b[0]))
q

bytearray то же самое, но изменяется
b = bytearray(b'hello world!')
b[0] = 45
print(b)
bytearray(b'-ello world!')


---------------------------
+None:
пустое значение.
None == None 		# True
остальное False
В логическом контексте None всегда является ложью, а not None — истиной.


==============================================
приведение типов:
bool(x) - преобразование к типу bool,
int(a)   - приведение к целому числу.
float([X]) - преобразование к числу с плавающей точкой.
str([object], [кодировка], [ошибки]) - строковое представление объекта. Использует метод __str__.

tuple(obj) - преобразование к кортежу.
set([object]) - создает множество.
list([object]) - создает список.
dict([object]) - преобразование к словарю.
bytes([источник [, кодировка [ошибки]]]) - возвращает объект типа bytes.
bytearray([источник [, кодировка [ошибки]]]) - преобразование к bytearray.

isdigit() - состоит ли строка только из цифр?
isalpha() позволяет проверить, состоит ли строка из одних букв
isalnum() позволяет проверить, состоит ли строка из букв и цифр
type(object) - Возвращает тип объекта.
id(object) - Возвращает "адрес" объекта. 

==============================================
управляющие конструкции:

for item in range(4):
	print(item)
# 1 2 3 4 	

---------------------------
r1 = {1: 'q', 2: 'w'}
for key, value in r1.items():
  print(key + ' => ' + value)

---------------------------
for num in range(5):
  print(num)
else:
  print("Числа закончились")

если сработал break, то else не выполняется

---------------------------
a = 5
while a > 0:
	print(a)
	a -= 1
# 5 4 3 2 1

---------------------------
break, continue действуют для for и while

---------------------------
if a == 3:
	pass
else:
	pass

if a == 3:
	pass
elif a == 2:
	pass
else:
	pass	

---------------------------


==============================================


==============================================
==============================================
передавать имя файла как аргумент скрипта и затем использовать уже указанный файл.
В модуле sys есть очень простой и удобный способ для работы с аргументами - argv.

==============================================
работа с файлами:

file = open('file_name.txt', 'r')

r - открыть файл только для чтения (значение по умолчанию)
r+ - открыть файл для чтения и записи
w - открыть файл для записи
если файл существует, то его содержимое удаляется
если файл не существует, то создается новый
w+ - открыть файл для чтения и записи
если файл существует, то его содержимое удаляется
если файл не существует, то создается новый
a - открыть файл для дополнения записи. Данные добавляются в конец файла
a+ - открыть файл для чтения и записи. Данные добавляются в конец файла

-------------------------------
читать весь файл как одну строку:
f = open('pizza.py', 'r')
text = f.read()
print(text)

или читать каждуй строку файла:
f = open('pizza.py', 'r')
for line in f:
	print(line)

readlines(). Он считывает строки файла в список:
f = open('pizza.py', 'r')
text = f.readlines()
print(text)

-------------------------------
дописать в файл:
f = open('pizza.py', 'a')
f.write('gdfgdgdfgdg')
f.close()

Метод writelines() ожидает список строк, как аргумент.
f = open('pizza.py', 'a')
v = [
	'1212\n',
	'23232\n',
	'sdaasdf\n',
	'cxzcvxcv\n',
]
f.writelines(v)
f.close()

для закрытия файла удобнее использовать with:
with open('pizza.py', 'a') as f:
	v = [
		'1212\n',
		'23232\n',
		'sdaasdf\n',
		'cxzcvxcv\n',
	]
	f.writelines(v)

==============================================
генератор и итератор

генераторное выражение:
genexpr = (x*2 for x in range(10))
next(genexpr)	# 0
next(genexpr)	# 1

----------------------------------
genexpr = [x*2 for x in range(10)]
print(genexpr)
# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

----------------------------------
итератор это объект, который инициализируется перебираемым объектом, ставит указатель на первый элемент и при помощи метода next() возвращает этот элемент, увеличивая позицию указателя
lista = [1, 2, 3]
i = iter(lista)
next(i) # 1
next(i) # 2

==============================================


==============================================


==============================================

----------------------
----------------------
----------------------
----------------------
----------------------
----------------------
----------------------
----------------------

==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
условие if __name__ == '__main__' проверяет, был ли файл запущен напрямую.

==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================