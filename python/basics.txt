типы данных:


bytearray то же самое, но изменяется
b = bytearray(b'hello world!')
b[0] = 45
print(b)
bytearray(b'-ello world!')


---------------------------
+None:
пустое значение.
None == None 		# True
остальное False
В логическом контексте None всегда является ложью, а not None — истиной.


==============================================
приведение типов:
bool(x) - преобразование к типу bool,
int(a)   - приведение к целому числу.
float([X]) - преобразование к числу с плавающей точкой.
str([object], [кодировка], [ошибки]) - строковое представление объекта. Использует метод __str__.

tuple(obj) - преобразование к кортежу.
set([object]) - создает множество.
list([object]) - создает список.
dict([object]) - преобразование к словарю.
bytes([источник [, кодировка [ошибки]]]) - возвращает объект типа bytes.
bytearray([источник [, кодировка [ошибки]]]) - преобразование к bytearray.

isdigit() - состоит ли строка только из цифр?
isalpha() позволяет проверить, состоит ли строка из одних букв
isalnum() позволяет проверить, состоит ли строка из букв и цифр
type(object) - Возвращает тип объекта.
id(object) - Возвращает "адрес" объекта. 

==============================================
управляющие конструкции:

for item in range(4):
	print(item)
# 1 2 3 4 	

---------------------------
r1 = {1: 'q', 2: 'w'}
for key, value in r1.items():
  print(key + ' => ' + value)

---------------------------
for num in range(5):
  print(num)
else:
  print("Числа закончились")

если сработал break, то else не выполняется

---------------------------
a = 5
while a > 0:
	print(a)
	a -= 1
# 5 4 3 2 1

---------------------------
break, continue действуют для for и while

---------------------------
if a == 3:
	pass
else:
	pass

if a == 3:
	pass
elif a == 2:
	pass
else:
	pass	

---------------------------


==============================================


==============================================
==============================================
передавать имя файла как аргумент скрипта и затем использовать уже указанный файл.
В модуле sys есть очень простой и удобный способ для работы с аргументами - argv.

==============================================
работа с файлами:

file = open('file_name.txt', 'r')

r - открыть файл только для чтения (значение по умолчанию)
r+ - открыть файл для чтения и записи
w - открыть файл для записи
если файл существует, то его содержимое удаляется
если файл не существует, то создается новый
w+ - открыть файл для чтения и записи
если файл существует, то его содержимое удаляется
если файл не существует, то создается новый
a - открыть файл для дополнения записи. Данные добавляются в конец файла
a+ - открыть файл для чтения и записи. Данные добавляются в конец файла

-------------------------------
читать весь файл как одну строку:
f = open('pizza.py', 'r')
text = f.read()
print(text)

или читать каждуй строку файла:
f = open('pizza.py', 'r')
for line in f:
	print(line)

readlines(). Он считывает строки файла в список:
f = open('pizza.py', 'r')
text = f.readlines()
print(text)

-------------------------------
дописать в файл:
f = open('pizza.py', 'a')
f.write('gdfgdgdfgdg')
f.close()

Метод writelines() ожидает список строк, как аргумент.
f = open('pizza.py', 'a')
v = [
	'1212\n',
	'23232\n',
	'sdaasdf\n',
	'cxzcvxcv\n',
]
f.writelines(v)
f.close()

для закрытия файла удобнее использовать with:
with open('pizza.py', 'a') as f:
	v = [
		'1212\n',
		'23232\n',
		'sdaasdf\n',
		'cxzcvxcv\n',
	]
	f.writelines(v)

==============================================
генератор и итератор

генераторное выражение:
genexpr = (x*2 for x in range(10))
next(genexpr)	# 0
next(genexpr)	# 1

----------------------------------
genexpr = [x*2 for x in range(10)]
print(genexpr)
# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

----------------------------------
итератор это объект, который инициализируется перебираемым объектом, ставит указатель на первый элемент и при помощи метода next() возвращает этот элемент, увеличивая позицию указателя
lista = [1, 2, 3]
i = iter(lista)
next(i) # 1
next(i) # 2

==============================================


==============================================


==============================================

----------------------
----------------------
----------------------
----------------------
----------------------
----------------------
----------------------
----------------------

==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
условие if __name__ == '__main__' проверяет, был ли файл запущен напрямую.

==============================================
print(*objects, sep=' ', end='n', file=sys.stdout, flush=False)

можно вывести объекты в файл, указав параметр file:

sourceFile = open('python.txt', 'w')
print("Круто же, правда?', file = sourceFile)
sourceFile.close()


аналоги input, print:

>>> import sys
>>> contents = sys.stdin.read()
a
b
EOF
>>> contents
'a\nb\nEOF\n'
>>> sys.stdout.write(contents)
a
b
EOF

не забыть нажать ctrl+D

==============================================
a = [1, 2]
b = a
print(id(a), id(b))
print(a == b) # true
print(a is b) # true
print(a is not b) # false


q = [1, 2]
w = [1, 2]
print(q == w) # true
print(q is w) # false


----

a = [1, 2]
b = a

print(a == b) # true
print(a is b) # true

c = list([1, 2])
print(a == c)
print(a is c)


==============================================
==============================================
pip используется для python2. для python3 нужно устанавливать pip3:
sudo apt-get install python3-pip

==============================================
установка адаптера дл postgres psycopg2:
для питона3 его нужно устанавливать при помощи pip3.
или из исходников: https://github.com/psycopg/psycopg2

==============================================
способ установки под конкретную версию python
python<версия> -m pip install Jinja2

python3 -m pip install uwsgi

обновить pip3:
python3 -m pip install --upgrade pip


python3 -m pip install -r requirements.txt
python3 -m pip install flask-migrate

==============================================
старт cgi:
python3 -m http.server --cgi

==============================================
убить процесс локального сервера:
sudo lsof -t -i tcp:8000 | xargs kill -9

==============================================
Если вы используете версию Python 3, в нее включена поддержка виртуальной среды, поэтому все, что вам нужно сделать для ее создания, это:
$ python3 -m venv venv

==============================================
установить конкретную версию питона для virtualenv:
$ sudo apt-get install python-virtualenv
$ virtualenv --python=python3.6 venv

==============================================
собрать python3.6 из исходников:
https://tecadmin.net/install-python-3-6-ubuntu-linuxmint/

==============================================
==============================================
Состояние гонки:
Race condition. Другое название: гонки данных (data race). Ошибка программирования многозадачной системы, при которой работа системы зависит от того, в каком порядке выполняются части кода. Состояние гонки является классическим гейзенбагом. Состояние гонки возникает тогда, когда несколько потоков многопоточного приложения пытаются одновременно получить доступ к данным, причем хотя бы один поток выполняет запись. Состояния гонки могут давать непредсказуемые результаты, и зачастую их сложно выявить. Иногда последствия состояния гонки проявляются только через большой промежуток времени и в совсем другой части приложения. Кроме того, ошибки такого рода невероятно сложно воспроизвести повторно. Для предотвращения состояния гонки используются приемы синхронизации, позволяющие правильно упорядочить операции, выполняемые разными потоками. Приведем пример. Пусть, один поток выполняет над общей переменной x операцию x = x + 3, а второй поток - операцию x = x + 5. Данные операции для каждого потока фактически разбиваются на три отдельных подоперации: считать x из памяти, увеличить x, записать x в память. В зависимости от взаимного порядка выполнения потоками подопераций финальное значение переменной x может быть больше исходного на 3, 5 или 8.
ИЛИ:
это такое состояние системы, в котором один поток ожидает наступления чего-то, а это что-то не может произойти потому, что другой поток ожидает наступления чего-то от первого потока.

взаимная блокировка:
несколько процессов находятся в состоянии ожидания ресурсов, занятых друг другом, и ни один из них не может продолжать свое выполнение

активная блокировка:
система не «застревает» (как в обычной взаимной блокировке), а занимается бесполезной работой, её состояние постоянно меняется — но, тем не менее, она «зациклилась», не производит никакой полезной работы.

исчерпаине ресурсов:
Исчерпание ресурсов описывает ситуацию, где поток неспособен получить регулярный доступ к совместно используемым ресурсам и неспособен выполнить работу. Это происходит, когда совместно используемые ресурсы делаются недоступными в течение многих длительных периодов "жадными" потоками


==============================================
динамическая типизация это переменная связывается с типом во время присваивания. таким образом в программе можно много раз изменять тип переменной.
статическая типизация это когда переменная связывается с типом на этапе объявления. после этого тип её невозможно изменить

строгая типизация не позводяет не явно преобразовывать переменные. например ложить строку с числом.
не стогая типизация позволяет не явно преобразовывать переменные

==============================================
установка tesseract для распознавания текста на картинке:

pip install pytesseract

sudo apt install tesseract-ocr
sudo apt-get -f install

sudo apt update
sudo apt install tesseract-ocr
sudo apt install libtesseract-dev

https://stackoverflow.com/questions/50951955/pytesseract-tesseractnotfound-error-tesseract-is-not-installed-or-its-not-i?rq=1


==============================================
эмуляция switch при помощи объекта:

def __handle_input(self, symbol):
    jump_table_1 = {
        self.PLAIN_TEXT: self.__set_pre_bold,
        self.PRE_BOLD: self.__set_bold,
        self.BOLD: self.__set_pre_end_bold,
        self.ITALIC: self.__set_end_italic,
        self.PRE_END_BOLD: self.__set_end_bold
    }

    jump_table_2 = {
        self.PLAIN_TEXT: self.__update_buffer,
        self.PRE_BOLD: self.__set_italic,
        self.BOLD: self.__update_buffer,
        self.ITALIC: self.__update_buffer,
        self.PRE_END_BOLD: self.__update_buffer
    }

    if symbol == '*':
        jump_table_1[self.__state]()
    else:
        jump_table_2[self.__state](symbol)

==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================