области видимости и замыкания:

Python ищет переменную в таком порядке по областям видимости (до первого совпадения):
L (local) - в локальной (внутри функции)
E (enclosing) - в локальной области объемлющих функций (это те функции, внутри которых находится наша функция)
G (global) - в глобальной (в скрипте)
B (built-in) - в встроенной (зарезервированные значения Python)

встроенная область видимости реализована как модуль стандартной библиотеки. следовательно его нужно импортировать так:
import builtins
>>> dir(builtins)

но если не импортировать, то доступ к его содержимому всё равно есть.

при этом внутри функций можно переорпеделять зарезервированные слова так:
def qw():
	int = 123
	print(int(5.6))
qw()		# TypeError: 'int' object is not callable

=============================
global x объявляет переменную x глобально

x = 100

def func():
  global x  # объявляет переменную глобальной
  x = 10

print(x)  # 100
func()
print(x)  # 10


=============================
nonlocal x объявляет переменную x во внешней области видимости(и только в ней)

x = 100

def func2():
  x = 50

  def func():
    nonlocal x
    x = 10

  func()
  print(x)  # 10

func2()
print(x)    # 100

=============================
=============================
замыкание (closure) в программировании — это функция, в теле которой присутствуют ссылки на переменные, объявленные вне тела этой функции в окружающем коде и не являющиеся ее параметрами


def func(a):
    def f(b):
        return a + b
    return f

curr = func(1)
print(curr(2))

или func(1)(2)

этот пример подходит для объяснения питоновского каррирования.
каррирование это разбиене вызова функции нескольких аргументов на вызовы нескольких функций одного аргумента

=============================
=============================

=============================
=============================
=============================
=============================
=============================
=============================
=============================
=============================
=============================