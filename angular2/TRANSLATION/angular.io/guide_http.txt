....HttpClient

часто разработчики взаимодействуют с бэкенд-сервисами через http протокол. современные браузеры поддерживают 2 различных API, совершающих http-запросы: XMLHttpRequest и fetch() API.

через HttpClient предоставляется простое API для http, которое можно использовать в angular-приложениях. оно является надстройкой над XMLHttpRequest и отображается браузером. дополнительными плюсами HttpClient являются: встроенная поддержка тестирования, строгая типизация запросов и ответов сервера, поддержка перехвата запоса/ответа, возможность обработки ошибок запросов.


....настройка: установка модуля

перед использованием HttpClient необходимо установить HttpClientModule, который предоставляет его функциональность. подключить его нужно в главном модуле вашего приложения, это необходимое сделать только один раз:


// app.module.ts:

import {NgModule} from '@angular/core';
import {BrowserModule} from '@angular/platform-browser';

// Import HttpClientModule from @angular/common/http
import {HttpClientModule} from '@angular/common/http';

@NgModule({
  imports: [
    BrowserModule,
    // Include it under 'imports' in your application module
    // after BrowserModule.
    HttpClientModule,
  ],
})
export class MyAppModule {}


после импорта HttpClientModule в главном модуле приложения, необходимо подключить HttpClient в целевые компоненты и сервисы.


....делаем запрос JSON-данных.

наиболее часто делаемые запросы данных к бэкенду - это запросы JSON-данных. для примера предположим, определённый адрес возвращает JSON-данные такого вида:

{
  "results": [
    "Item 1",
    "Item 2",
  ]
}

,здесь get() это метод HttpClient, предоставляющий простой доступ к данным. 

@Component(...)
export class MyComponent implements OnInit {

  results: string[];

  // Inject HttpClient into your component or service.
  constructor(private http: HttpClient) {}

  ngOnInit(): void {
    // Make the HTTP request:
    this.http.get('/api/items').subscribe(data => {
      // Read the result field from the JSON response.
      this.results = data['results'];
    });
  }
}


....проверка тип запроса.

в примере выше используется скобочная нотация для доступа к конкретному полю. если вы попробуете использовать точечную нотацию data.results, то typescript не разрешит извлечь данные. это произойдёт потому что HttpClient парсит данные ка объект. при этом он не знает форму этого объекта.

вы всегда можете указать HttpClient каким должен быть тип ответа. для этого первым делом определите интерфейс ответа:

interface ItemsResponse {
  results: string[];
}

в этом случае при запросе HttpClient.get необходимо указывать параметр-тип:

http.get<ItemsResponse>('/api/items').subscribe(data => {
  // data is now an instance of type ItemsResponse, so you can do this:
  this.results = data.results;
});


....получение полного ответа.

запрос не возвращает все данные, которые вам могут потребоваться. иногда сервер возвращает особенные заголовки и коды статусов для обозначения определённых условий. проверка их может быть необходима. чтобы сделать её, вы должны сказать HttpClient, что вы хотите получить полный ответ сервера при помощи опции observe:

http
  .get<MyJsonData>('/data.json', {observe: 'response'})
  .subscribe(resp => {
    // Here, resp is of type HttpResponse<MyJsonData>.
    // You can inspect its headers:
    console.log(resp.headers.get('X-Custom-Header'));
    // And access the body directly, which is typed as MyJsonData as requested.
    console.log(resp.body.someField);
  });

  как вы видите, результирующий объект имеет свойство body корректного типа.


....обработка ошибок

  что произойдёт если запрос упадёт на сервере или слабое интернет-соединение не позволит вернуть результат запроса? HttpClient вернёт огибку вместо результата.

  чтобы отловить её необходимо добавить обработчик ошибок в ваш .subscribe() следующим образом:

  http
  .get<ItemsResponse>('/api/items')
  .subscribe(
    // Successful responses call the first callback.
    data => {...},
    // Errors will call this callback instead:
    err => {
      console.log('Something went wrong!');
    }
  );


....получение детальной информации об ошибке:

обнаружение того, что произошла ошибка это первая задача. но важнее знать какая именно ошибка произошла. параметр err из кода выше содержит полезную информацию об ошибке.

могут произойти как минимум 2 вида ошибок: 
1. бэкенд возвращает код неуспешного запроса (404, 500 и т.д.).
2. ошибка произошла на клиенте. исключение попадает в RxJS 

в обоих случаях чтобы понять что произошло нужно смотреть в HttpErrorResponse.

http
  .get<ItemsResponse>('/api/items')
  .subscribe(
    data => {...},
    (err: HttpErrorResponse) => {
      if (err.error instanceof Error) {
        // A client-side or network error occurred. Handle it accordingly.
        console.log('An error occurred:', err.error.message);
      } else {
        // The backend returned an unsuccessful response code.
        // The response body may contain clues as to what went wrong,
        console.log(`Backend returned code ${err.status}, body was: ${err.error}`);
      }
    }
  );

один из способов устранения ошибки - повторить запрос. этот способ может быть полезен когда ошибки не повторяются систематически.

RxJS имеет полезный оператор .retry() ,который автоматически подписывает заново наблюдателя таким образом повторяя запрос.

для этого необходимо в первую очередь импортировать следующее:

import 'rxjs/add/operator/retry';

после этого вы сможете использовать HTTP-наблюдателя так:

http
.get<ItemsResponse>('/api/items')
// Retry this request up to 3 times.
.retry(3)
// Any errors after the 3rd retry will fall through to the app.
.subscribe(...);

этот код возвращает неуспешный запрос 3 раза. после этого приложение упадёт.


....запрос данных формата неJSON

не все API возвращают данные в формате JSON. предположим, вы хотите прочитать текстовый файл на сервере. вы должны сказать HttpClient, что вы ожидаете ответ в текстовом формате:

http
.get('/textfile.txt', {responseType: 'text'})
// The Observable returned by get() is of type Observable<string>
// because a text response was specified. There's no need to pass
// a <string> type parameter to get().
.subscribe(data => console.log(data));


....отправка данных на сервер


В дополнение к получению данных HttpClient поддерживает мутирующие запросы, которые отправляют на сервер данных в различных видах.


....отправка POST-запроса.

одна из типичных операций это отправка данных не сервер, например при сабмите формы. Код для отправки POST-запроса очень поход на код для отправки GET-запроса:

const body = {name: 'Brad'};

http
  .post('/api/developers/add', body)
  // See below - subscribe() is still necessary when using post().
  .subscribe(...);


заметка о методе subscribe(). все наблюдаемые объекты возвращают сырые данные, точнее - метаданные. ничего не случится пока вы не выполните subscribe(). каждый такой вызов будет делать отдельный запрос. например этот код отправляет POST-запрос с некоторыми данными дважды:

const req = http.post('/api/items/add', body);
// 0 requests made - .subscribe() not called.
req.subscribe();
// 1 request made.
req.subscribe();
// 2 requests made.


....конфигурирование других частей запроса

кроме URL-адреса в запросе есть другие параметры, которые вы можете настраивать. все они находятся в объекте options.

....заголовки

одна из частых задач - добавление заголовка авторизации к исходящему запросу. в этом случае вы делаете следующее:

http
  .post('/api/items/add', body, {
    headers: new HttpHeaders().set('Authorization', 'my-auth-token'),
  })
  .subscribe();

HttpHeaders это неизменяемый класс. его метод set() возвращает новый экземпляр класса и инициализирует его.

....URL-параметры

чтобы отправить запрос с параметром id, равным 3 нудно сделать так:

http
  .post('/api/items/add', body, {
    params: new HttpParams().set('id', '3'),
  })
  .subscribe();

в это случае на сервер уходит такой запрос: /api/items/add?id=3.

....расширенное использование.

выше было рассказано как использовать основную функциональность, но иногда требуется делать нечто большее чем просто отсылать запросы и получать обратно ответ.

....перехват всех запросов и ответов

главная особенность @angular/common/http это возможность перехвата. то есть возможность объявить перехватчиков, которые будут работать между вашим приложением и бэкендом. когда ваше приложение делает запрос, то перехватчик трансформирует его перед отправкой на сервер. так же перехватчик может трансформировать ответ, которой поступит с сервера. это бывает полезно, например, при аутентификации и логировании.


....написание перехватчика.

чтобы реализовать перехватчик нужно создать класс, который наследуется от HttpInterceptor. он будет иметь единственный метод intercept(). вот простой перехватчик, который ничего не делает и возвращает запрос без изменений:

import {Injectable} from '@angular/core';
import {HttpEvent, HttpInterceptor, HttpHandler, HttpRequest} from '@angular/common/http';

@Injectable()
export class NoopInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    return next.handle(req);
  }
}


здесть intercept это метод, который трансформирует запрос в наблюдаемы объект, а этот объект в свою очередь возвращает ответ. В этом смысле каждый перехватчик несет полную ответственность за обработку запроса самостоятельно.

часто через перехватчики делают небольшие изменения в запросе и результат возвращается таким образом чтобы можно было использовать chaining. это возможно благодаря next(). в итоге запрос может быть обработан несколькими перехватчиками. 

но мы не можем просто вызвать next.handle в перехватчике потому что изменится оригинальный запрос.

этот паттерн похож на middleware, который используется например в Express.js и в других подобных средах.


....подключение перехватчика.

просто объявите NoopInterceptor в главном модуле вашего приложения. 

import {NgModule} from '@angular/core';
import {HTTP_INTERCEPTORS} from '@angular/common/http';

@NgModule({
  providers: [{
    provide: HTTP_INTERCEPTORS,
    useClass: NoopInterceptor,
    multi: true,
  }],
})
export class AppModule {}


обратите вниманиена опцию multi: true. она необходима. она говорит angular, что HTTP_INTERCEPTORS это не одно значение, а массив значений.


....события.

вы можете заметить, что наблюдаемый объект возвращает intercept и HttpHandler.handle не как Observable<HttpResponse<any>> и  Observable<HttpEvent<any>>. это происходит потому что перехватчик работает на низшем уровне интерфейса HttpClient. одиночный запрос может генерировать много событий. 

перехватчик должен взаимодействовать со всеми событиями, которые происходят. но должен не обрабатывать события, на которые не настроен. многие перехватчики работают только с исходящим запросом. 


....порядок.

когда вы добавляете перехватчики в ваше приложение, то angular подключает их в определённом порядке.


....неизменяемость.

перехватчики существуют для проверки и изменения исходящих запросов и возвращаемых запросов. поэтому HttpRequest и HttpResponse не изменяемы. причина этого в том, что приложене может неодноратно отправлять один и тот же запрос. если приэтом оригинальный запрос будет изменён, то пезультат будет некорректный. 

недопустим оредактировать body запроса. система такие изменение никак не отслеживает, поэтому оно может привести к трудноуловимой ошибке. 

если всё же вы хотите изменить body запроса, то необходимо создать копию объекта при помощи clone(). 

intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
  // This is a duplicate. It is exactly the same as the original.
  const dupReq = req.clone();

  // Change the URL and replace 'http://' with 'https://'
  const secureReq = req.clone({url: req.url.replace('http://', 'https://')});
}


....установка новых заголовков.

обычно используют перехватчики, устанавливая заголовки по умолчанию для исходящих запросов. для пример рассмотрим случай когда вы имеете встраиваемый сервис AuthService, который предоставляет токен аутентификации. в этом случае вы должны написать перехватчик, который добавляет этот токен ко всем исходящим запросам. 


import {Injectable} from '@angular/core';
import {HttpEvent, HttpInterceptor, HttpHandler, HttpRequest} from '@angular/common/http';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  constructor(private auth: AuthService) {}

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    // Get the auth header from the service.
    const authHeader = this.auth.getAuthorizationHeader();
    // Clone the request to add the new header.
    const authReq = req.clone({headers: req.headers.set('Authorization', authHeader)});
    // Pass on the cloned request instead of the original request.
    return next.handle(authReq);
  }
}


здесь мы клонируем объект так: 

const authReq = req.clone({setHeaders: {Authorization: authHeader}});

перехватчик, котрый клонирует заголовки может использоваться для:
1. аутентификацмм
2. кеша
3. XSRF-защиты


...логирование.




