типы данных:

	Numbers 
		(int/float)
		для большей точности после запятой можно импортировать модель decimal

	Strings 

	Boolean 
		истинное значение:
			любое ненулевое число
			любая непустая строка
			любой непустой объект
		ложное значение:
			0
			None
			пустая строка
			пустой объект	

	Lists - 
		{}

	Dictionaries 
		(ключ должен быть объектом неизменяемого типа: число, строка, кортеж) - 
		{}

	Tuples 
		(список, который нельзя изменить) - 
		()

	Sets 
		(список из уникальных элементов) - 
		{}

	NoneType
		дополнительный тип, к которому относится только константа пустого значения None

=============================
преобразование типов

	str
	int
	list (из строки)
	set (из списка)
	tuple (из списка)
	bin
	hex

=============================
проверка типов
	type()	- вывод типа
	isdigit() - только цифры
	isalpha() - только буквы
	isalnum() - только цифры и буквы

=============================
отлов исключений

    try:
        result = int(a)/int(b)
    except ValueError:
        // отлавливается конкретный тип ошибки
    except:
        // отлавливается любой тип ошибки
    else:
        // выполняется если не произошло исключение
    finally:
    	// выполняется всегда


    проброс исключения делается так
    	raise ValueError("При выполнении команды возникла ошибка")

=============================
функция с обязательными и необязательными параметрами
	def qwerty(a, b, c=3, d=4):
		pass

функция с позиционными и ключевыми аргументами
	def check_passwd(username, password, min_length=8, check_username=True):
		pass

	check_passwd('nata', '12345nata', check_username=True, min_length=3)

функция с неизвестным количеством аргументов
	def sum_arg(a, *args):
		pass

=============================
импорт модуля
	from check_ip_function import check_ip

Переменная __name__ - это специальная переменная, которая будет равна "__main__", только если файл запускается как основная программа	
	if __name__ == "__main__" - проверка на то, что скрипт не выполняется как импортированный.

При импорте модуля, Python сначала ищет модуль в стандартной библиотеке. Если модуль не найден в стандартной библиотеке, поиск модуля идет в каталогах, которые указаны в sys.path.
	Содержимое sys.path состоит из:
		текущего каталога
		каталогов, которые указаны в переменной PYTHONPATH
		пути по умолчанию (зависят от установки Python)

=============================
классы

	class Switch(parent_class):
		all_allocated_ip = []	// переменная класса

		def __init__(self, a, b):
		    print(a, b)

		def info(self):
		   pass

		def __str__(self):
		   return f"IPAddress: {self.ip}"	// строковое представление

	sw1 = Switch(1, 2)

	self это ссылка на конкретный экземпляр класса.

	наследование
		есть возможность множетсвенного наследования.

	инкапсуляция
		приватные свойства предваряются двойным подчёркиванием.

	полиморфизм
		есть возможность переопределения метода в наследнике и перегрузки(дополнения) метода в наследнике

		class Employee(Person):		
			def display_info(self):
		        super().display_info()
		        print("hello")			

=============================
многопоточность

	import threading

	def myfunc(a, b):
	    print('сумма :',a + b)

	// создаётся экземпляр в отличие от использования модуля Thread
	thr1 = threading.Thread(target = myfunc, args = (1, 2)).start()	

=============================
2 vs 3

	2: при делении целых чисел результатом является тоже целое число

	2: print "hello" оператор

	3: print("hello") функция


=============================
недостатки

	1. скорость
	2. динамическая типизация
	3. Поэтому любая ошибка проявляется во время выполнения кода. (скрипт постоянно компилируется преед выполнением)
	4. 

=============================
функциональные возможности

	map, filter, reduce + питонизмы

	лямбда выражение - аналог анонимной функции в js

		def func(x, y):
		    return x**2 + y**2

		func = lambda x, y: x**2 + y**2

	замыкания

		def multiplier(n):
		    "multiplier(n) возвращает функцию, умножающую на n"
		    def mul(k):
		        return n*k
		    return mul
		# того же эффекта можно добиться выражением
		# multiplier = lambda n: lambda k: n*k
		mul2 = multiplier(2) # mul2 - функция, умножающая на 2, например, mul2(5) == 10	



=============================
=============================
=============================
=============================
=============================
=============================
=============================
=============================
=============================
=============================
=============================
=============================
=============================
=============================
=============================
=============================
=============================
=============================