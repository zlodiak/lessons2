================================
================================
что такое generics в ts

Обобщённый тип позволяет резервировать место для неизвестного типа, который будет заменён на конкретный, переданный пользователем(явно или не явно).

	function identity<T>(arg: T): T {
		return arg;
	}

Конструкция <T> после имени функции указывает на то, что эта функция собирается захватить тип и подменить им все T. при вызове этой функции нужно явно указывать обобщённый тип:

	identity<number>(115);

но можно вызвать и так. в этом случае обобщённый тип в угловых скобках определится автоматически:

	identity('string');

================================
описать тип tuple

этот тип описывает массив, в котором задана типизация для каждого элемента. длина кортежа меняться не может. порядок элементов меняться не может.

================================
описать тип enum

это объект, который состоит из констант. если контанты - числа, то возможна двусторонняя ассоциация:

	enum Nuts {
	    Peanuts, // 0
	    Walnut, // 1
	    Hazelnut = 0, // 0
	    Cedar // 1
	}
	console.log(Nuts[1]);       // Cedar
	console.log(Nuts.Cedar);    // 1

если констнты  - строки, то ассоциация односторонняя:

	enum Nuts {
	    Peanuts = 'qwe', // 0
	    Walnut = 'asd', // 1
	}
	console.log(Nuts[0]);       // undefined
	console.log(Nuts.Peanuts);    // qwe


================================
чем отличаются типы never и void

если в функции выполняется бесконечный цикл, то она вернёт never. если в функции нет инструкции return, то она вернёт void.

================================
расскзать о модулях и namespaces в ts

пространство имён это способ организации видимости переменных. важно использовать export для тех переменных, к которым есть доступ.
	namespace Validation {
	    export interface StringValidator {
	        isAcceptable(s: string): boolean;
	    }
	    const lettersRegexp = /^[A-Za-z]+$/; 
	 }

обращаться так:
Validation.StringValidator


 модули объявляют свои зависимости через import. в остальном это такие же пространства имён. модуль это отдельный файл.


================================
перечислить типы данных в ts

Boolean: логическое значение true или false
Number: числовое значение
String: строки

Array: массивы. содержат только один тип элементов
Tuple: кортежи. содержат различные типы элементов, их предварительно нужно описать	// let x: [string, number] = ["hello", 10]
Enum: перечисления. enum Season { Winter=0, Spring=1, Summer=2, Autumn=3 };

Any: произвольный тип
Null и undefined: соответствуют значениям null и undefined в javascript
Void: отсутствие конкретного значения, используется в основном в качестве возвращаемого типа функций
Never: возвращает функция, выход из которой никогда не происходит. например бесконечный цикл
Unknown: подобен any, но невозможно присвоить произвольному типу

================================
let vAny: any = 10;          // We can assign anything to any
let vUnknown: unknown =  10; // We can assign anything to unknown just like any 


let s1: string = vAny;     // Any is assignable to anything 
let s2: string = vUnknown; // Invalid we can't assign vUnknown to any other type (without an explicit assertion)

vAny.method();     // ok anything goes with any
vUnknown.method(); // not ok, we don't know anything about this variable

================================
что такое литеральный тип в ts?

	const a: 'qqq' = 'qqq';

================================
чем тип отличается от интерфейса?

интерфейсы можно наследовать.
интерфейсы можно слиавть(если объявлены два с одинаковым именем).
type позволяет задать новое имя для типа или для объединения типов.

================================
что такое условный чейнинг(Optional Chaining)?

	// Before
	if (foo && foo.bar && foo.bar.baz) {
	    // ...
	}

	// After-ish
	if (foo?.bar?.baz) {
	    // ...
	}

Если значение foo.bar равно null или undefined, выполнение выражения автоматически прекращается и возвращается undefined. исключение не выбрасывается.

================================
что такое union и intersection типы?

union это тип, полученный в результате перечисления нескольких типов. результирующий тип принадлежит к одному из перечисленных

	interface Phone {
	  number: string;
	}
	interface Person {
	  name: string;
	}
	let employee: Phone | Person = {
	  name: 'Jane',
	}

intersection это тип, полученный в результате перечисления нескольких типов. результирующий тип включает все перечилсенные

	interface Phone {
	  number: string;
	}
	interface Person {
	  name: string;
	}
	let employee: Phone & Person = {
	  number: '+7 927 555-55-55',
	  name: 'Jane',
	}

================================
что такое type assertion?

assertion это сигнал от разработчика к компилятору об уточнении типа.

например имеется строка, которая присвоена переменной как any. если нужно взять от строки длину, то компилятор не сможет взять длину от типа any. но раазработчика может дать сигнал компилятору не ругаться:

	let someAnyValue: any = "hello world!";
	let strLength: number = (<string>someAnyValue).length;
	console.log(strLength); // 12

	let someAnyValue: any = "hello world!";
	let strLength: number = (someAnyValue as string).length;
	console.log(strLength); // 12	


-------------

assertion это сигнал разработчика компилятору о том, что два типа являются совместимыми. после компиляции в js-коде не остаётся информации об assertion.

например querySelector возвращает тип element, но разработчик хочет его приравнять к переменной типа HTMLElement. при этом в element есть все свойства HTMLElement и даже больше. формально эти типы различаются, но практически нет.

	const element: Element = document.querySelector( '#stage' );
	const stage: HTMLElement = <HTMLElement> element // Ok

альтернативная форма записи:

	 let element = document.querySelector('#counter') as HTMLElement;



================================
что такое тип функции? приведите пример.

Тип функции представляет комбинацию типов параметров и типа возвращаемого значения.

	function sum (x: number, y: number): number {
	    return x + y;
	};
	let op: (x:number, y:number) => number = sum;
	console.log(op(2, 4));  // 6

================================
что такое абстрактный класс?

от АК невозможно создать объект потому что АК нужно обязательно наследовать. АК в отличие от интерфейсов могут содержать реализацию. АК может иметь абстрактные методы, которые не содержат реализацию, и которые должны быть реализованы в наследнике.

	abstract class Figure {
	    getArea(): void{
	        console.log("Not Implemented")
	    }
	    abstract getColor(): void
	}
	class Rectangle extends Figure{
	  getColor() {
	    console.log('is red');
	  }
	}

	// const f = new Figure(); // error
	const r = new Rectangle();
	console.log(r)
	r.getArea();
	r.getColor();

================================
что такое интерфейс?

интерфейс - это определение кастомного типа данных, но без реализации. определяет свойства и методы, которые объект должен реализовать

================================
как в интерфейсе обозначаются необязательные свойства?

	interface IUser {
	    id: number;
	    name: string;
	    age?: number;
	}


================================
что такое type guards?

TG это функция, которая проверяет тип и возвращает true/false. далее эту функцию можно использовать перед использованием метода проверенного объекта.

	let pet =  {
	    // swim: function() {
	    //   console.log('swim');
	    // },
	    fly: function() {
	      console.log('fly');
	    }    
	  };

	interface Fish { swim: any }
	interface Bird { fly: any }

	function isFish(pet: Fish | Bird): pet is Fish {
	  return (pet as Fish).swim !== undefined;
	}

	if (isFish(pet)) {
	  pet.swim();
	} else {
	  pet.fly();
	}

	// fly

================================
как используются дженерики при создании экземпляра класса?

	class A<T> {
	  a: T;

	  constructor(a: T) {
	    this.a = a;
	  }

	  action() {
	    console.log('action', this.a, typeof this.a);
	  }
	}

	const a = new A(123);
	a.action();


================================
как используются дженерики в механизме наследования классов?

	class A<T> {
	  a: T;

	  constructor(a: T) {
	    this.a = a;
	  }

	  action() {
	    console.log('action', this.a, typeof this.a);
	  }
	}

	class B extends A<string> {}
	const b = new B('qwe');
	b.action();

или

	class A<T, U> {
	  a: T;
	  v: U;

	  constructor(a: T, v: U) {
	    this.a = a;
	    this.v = v;
	  }

	  action() {
	    console.log('action', this.a, typeof this.a);
	    console.log('action_', this.v, typeof this.v);
	  }
	}

	class B extends A<string, number> {}
	const b = new B('qwe', 123);
	b.action();

так тоже можно:

	class B extends A<string, string> {}
	const b = new B('qwe', '123');
	b.action();

================================
типы any, never, unknown:

	типы можно понимать как контейнеры допустимых значений. например

	  let a: number; // [1, 2, 3, 30, 100, и т.д.]

	тип any содержит все возможные значения. но он выпадает из этой концепции потому что any-значению может быть присвоено любое другое значение и наоброт - значение any можно назначить значению любого другого типа.

	  let a: any = 123;

	  и 

	  let a: number = 123;
	  let b = function(): any {
	    return 'qwe';
	  }
	  a = b()  // ошибки не будет

	таким образом тип any выпадает из концепции наборов допустимых значений.

	тип unknown исправляет это. он может использоваться как any с той лишь разницей, что unknown значение не может быть назначаемо какому-нибудь типу:

	  let a: unknown = 123;  тут ок
	  let res = 'qwwe';
	  res = a;  // тут будет ошибка

	тип never это пустой контейнер возможных значений. следовательно его можно назначить любому типу. но ему нельзя назначить никакой тип

	  let a: number = 123;
	  let b = function (): never {
	    while (true) {
	      console.log(1);
	    }
	  };
	  a = b(); // ошибки не будет

	  и

	  let a: never = 123;  // будет ошибка

================================
TS может работать с включенным и отключенным значенимем конфига --strictNullChecks. если оно включено, то на этапе компиляции проверяются все места, в которых отсутствие значения может привести к ошибке. также проверяются неинициализированные при объявлении или в конструкторе свойства классов.

разработчик может отключить вывод ошибки при помощи оператора !. важно понимать, что если ошибка всё таки случится, то программа упадёт.

если --strictNullChecks отключено, то никаких проверок на null и undefined компилятором не проводится.

================================
Оператор опциональной последовательности ?. позволяет получить значение свойства, находящегося на любом уровне вложенности в цепочке связанных между собой объектов, без необходимости проверять каждое из промежуточных свойств в ней на существование. ?. не выбрасывает исключение, если объект, к свойству или методу которого идёт обращение, равен null или undefined. В этих случаях он возвращает undefined.

================================
все ли принципы ООП поддерживает TS?

	инкапсуляция:

		 public, protected и private.

	наследование:

		extend

	полиморфизм:

		function add(x: string, y: string): string;
		function add(x: number, y: number): number;
		function add(x: any, y: any): any {
		    return x + y;
		}

================================
в чём отличие type от interface?

	type: 
		позволяет объявлять алиас типа. в том числе объединение или пересечение.

	interface: 
		может наследоваться другим interface.
		несколько interface  одинаковыми именами объединяются.
		класс может реализовывать interface

================================
в чём отличие абстрактного класса и интерфейса?

	АК:
		на основе него нельзя создать экземпля, АК можно только наследовать.
		АК может содержать реализацию

	интерфейс:
		не может содержать реализацию.

	АК применяются для случаев когда нужно создавать экземпляры. интерфейсы - для проверки контракта.

================================
keyof

  В JS ключи объекта извлекаются с помощью метода Object.keys:

    const user = {
      id: 666,
      name: "bytefer",
    }
    const keys = Object.keys(user); // ["id", "name"]

  В TS это делается с помощью keyof:

    type User = {
      id: number;
      name: string;
    }
    type UserKeys = keyof User; // "id" | "name"

================================
declare

  В TS-проектах мы часто импортируем сторонние JS-SDK с помощью тега script. например импортируем через html гугл-карты.

  после этого TS будет подчёркиваит красным обращение к глобальное переменной new google.maps

  чтобы этого не было нужно прописать:

    declare var google: any;

================================
keyof

  в ts он работает подобно Object.keys() в js. но Object.keys() в результате выдаёт все ключи объекта в виде массива строк, а keyof выдвёт все ключи типа в виде пересечения строк. то есть выдаёт новый тип 

    interface IInterfaceType {
      f1: number;
      f2: string;
    }

    let v2: keyof IInterfaceType; // v2: "f1" | "f2"  

  важно то, что результате можно использовать только в виде типа, отдельно его получить, например, для вывода в console.log() нельзя:

    interface TTT {
      id: number;
      name: string;
    }

    let ttt: TTT = {
      id: 1,
      name: 'ser',
    };

    let qqq: keyof TTT = 'name';  

  В случае, если тип данных не содержит публичных ключей, оператор keyof выведет тип never.

================
предикаты типа

  функции, которые сравнивают входящий тип с нужным типом и возвращают true если они совпадают и false, если они не совпадают

    function isType(val: unknown): val is T {
      // возвращает true, если val имеет тип T
    }

    if (isType(val)) {
      // val имеет тип T
    }
================================
TS это язык, который расширяет возможности js при помощи особого синтаксиса. ts компилируется в js. имеет статическую систему типов, полноценные классы(инкапсуляция, полиморфизм, инттерфейсы, абстрактные классы), дополнительные типы.

=========================================================
динамическая типизация,
  Статическая определяется тем, что конечные типы переменных и функций устанавливаются на этапе объявления. 
  В динамической типизации все типы выясняются на этапе присвоения значения.

сильная типизация,
  Сильная типизация выделяется тем, что язык не позволяет смешивать в выражениях различные типы и не выполняет автоматические неявные преобразования, например нельзя вычислить 1 + 'qwe'.

явная типизация
  тип новых переменных / функций / их аргументов нужно задавать явно.

=========================================================
из чего состоит ts

  ts это надстройка над js. сдедовательно нужен модуль, который будет производить компиляцию. этот модуль он устанавилвается через npm, следовательно нужно установить nodeJS. в модуле компиляции указываются пути к ts файлу и скомпилированному js-файлу. 

  кроме того указывается в какую версию ecmascript компилировать. а так же разные мелкие опции типа удаления комментариев в результирующем файле. 

  обычно используется опция watch, которая отслеживает момент когда в ts-фале было сделано изменение и после этого автоматически запускается компиляция

=========================================================
тип never

  описывает случай когда ничего не произойдёт. например если в финкции выполняется бесконечный цикл, то её результат описывается типом never. также если функция возвращает исключение, то её результат тоже описывается типом never

=========================================================
тип unknown

  тип any позволяет производить любые операции со значениями, которые им помечены:

    const anyValue: any = 'any value'
    console.log(anyValue.add())

  эти ошибки будут обнаружены только на этапе выполнения, но не на этапе написания кода. другими словами программист говорит компилятору то том, что он знает что делает.

  тип unknown в таких случаях обнаруживает ошибку именно на этапе написания кода.

    let unknownValue: unknown
    unknownValue = 'unknown value'
    unknownValue.toString() // Ошибка: Object is of type 'unknown'  

=========================================================
as const

  замораживает внутренности объекта. и на разрешает расширять типы(например литеральный тип в string).

  это аналог freeze();

=========================================================
Статические индексы и индексы экземпляров

  динамические ключи можно использовать не только в объекте, но и в экземляре класса, 

    class User {
      username: string
      age: number

      constructor(username: string,age: number) {
        this.username = username
        this.age = age
      }

      [propName: string]: string | number
    }

    const user = new User('John', 23)
    user['phone'] = '+79876543210'

  и в классе

    class User {
      username: string
      age: number

      constructor(username: string,age: number) {
        this.username = username
        this.age = age
      }

      static [propName: string]: string | number
    }

    User['userCount'] = 0  

=========================================================
Объект с произвольным количеством свойств

  type studentScore= { [name: string]: number };

  или

  type studentScore = Record<string, number>;

  то есть каждая запись в объекте будет иметь ключ типа стринг и значение типа намбер

=========================================================
класс может расширять только один класс (множественное наследование в TS, как и в JS, запрещено).
Однако мы вполне можем реализовывать (implements) несколько интерфейсов:

=========================================================
шаблонные литеральные типы:

  type Alignment = 'start' | 'end';
  type Side = 'top' | 'right' | 'bottom' | 'left';
  type AlignedPlacement = ${Side}-${Alignment};
  type Placement = Side | AlignedPlacement;
  
================================
утиная типизация 

  это проверка реализации объектом требуемого интерфейса. если кроме свойств, заявленных в интерфейся, присутствуют дополнительные свойства, то это не мешает отнести объект к типу, который не подразумевает наличие дополнительных свойств.

================
Тип never 

  можно указать только той функции, из которой программа никогда не сможет выйти.

================
Слабое сопряжение (loose coupling)

  Чем меньше окружающему миру известно о внутреннем устройстве классов, тем меньше оно взаимодействует с ним. Взаимодействия программы с объектом называют сопряжением (coupling), уровень которого варьируется от сильного до слабого. 

================
Интерфейсы предназначены 
  
  для описания публичного api, которое служит для сопряжения с программой. Кроме того, они не должны, а в TypeScript и не могут, реализовывать бизнес логику той части, которую представляют. 

================
Добавление статических свойств и методов в класс заставляет их действовать как singleton, в то время как определение нестатических свойств и методов заставляет их действовать как factory.

  singleton:

    const pizza = PizzaMaker.create({
      name: 'Inferno',
      toppings: ['cheese', 'peppers'],
    });
    console.log(pizza);
    // Output: { name: 'Inferno', toppings: [ 'cheese', 'peppers' ] }  

  factory:

    class PizzaMaker {
      create(event: { name: string; toppings: string[] }) {
        return { name: event.name, toppings: event.toppings };
      }
    }
    const pizzaMaker = new PizzaMaker();
    const pizza = pizzaMaker.create({
      name: 'Inferno',
      toppings: ['cheese', 'peppers'],
    });
    console.log(pizza);
    // Output: { name: 'Inferno', toppings: [ 'cheese', 'peppers' ] }    

================
readonly 

  Локальную переменную можно определить неизменяемой при помощи ключевого слова const. readonly делает то же самое для свойства класса. но такое свойство всё таки можно переопределить через конструктор

    interface IAnimal {
        readonly name: string;
    }

    class Animal implements IAnimal {
        public readonly name: string; // Ok
        
        constructor(){
            this.name = 'animal'; // Ok
        }
    }

  Если полям, помеченным “только для чтения”, не указан тип, а присвоение примитивного значения происходит в месте объявления, то для таких полей вывод типов укажет принадлежность к литеральному типу.

    class Animal {
        public readonly nameReadonly = 'animal'; // nameReadonly: "animal"
        public nameDefault = 'animal';           // nameDefault: string
    }  


================
если значение тип значения не задач явно для readonly и const, то присваивается литеральный тип

================
открытый обобщённый тип:

  class T1<T> {
    public f: T0<number, T>; // T0 - открытый тип
  }

закрытый обобщённый тип:

  class T1<T> {
    public f1: T0<number, string>; // T0 - закрытый тип
  }

================
нельзя использовать одинаковые названия для параметризованной и непараметризованной сущности:

  class T2<T> {}
  class T2 {} // Error -> Duplicate identifier

================
параметры типа можно расширять. вот неуспешный пример:

  class Collection<T> {
      private itemAll: T[] = [];
      
      public add(item: T): void {
          this.itemAll.push(item);
      }

      public getItemByName(name: string): T {
          return this.itemAll.find(item => item.name === name); // Error -> Property 'name' does not exist on type 'T'
      }
  }

При операции поиска в массиве возникнет ошибка. Это происходит по причине того, что в типе T не описано свойство name. Для того, что бы ошибка исчезла, тип T должен расширить тип, в котором описано необходимое свойство name.   

вот правильное решение проблемы при помощи расширения параметра типа:

  interface IName {
      name: string;
  }

  class Collection<T extends IName> {
      private itemAll: T[] = [];

      public add(item: T): void {
          this.itemAll.push(item);
      }

			public getItemByName(name: string): T {
          return this.itemAll.find(item => item.name === name); // Ok
      }
  }

================
type assertion

  в DOM все элементы имеют наивысшего родителя Element. но часть элементов не отображается(script), а часть отображается(div). те которые отображаются принадлежат к более узкомц типу HTMLElement.

  querySelector() может найти и видимый элемент, и невидимый.

    // <canvas id="stage" data-inactive="false"></canvas>
    const element: Element = document.querySelector('#stage');
    const stage: HTMLElement = element // Error, Element is not assignable to type HTMLElement

  вообще TS не имеет связи с DOM поэтому для элементов DOM нужно использовать утверждения.      

================================
================================
================================
================================
================================
================================

вопросы из навигатора 

================================
что такое TS?

	это надстройка над JS. она имеет свой синтаксис с расширенными возможностями, который пред выполнением компилируется в обычный JS.  возможности следующие:

		1. строная типизация
		2. полноценные классы
		3. дополнительные типы

	TS позвоняет выявить большинство ошибок на этапе написания кода, а не выполнения.

================================
виды типизации:

	1.
		статическая - тип определяетнся на этапе объявления
		динамическая - тип определяется на этапе присвоения значения

	2.
		сильная - не позволяет приводить типы при выполнении операции. например, 1 + 'qwe'
		слабая - позволяет.

	3.
		строгая - обязывает указывать конкретный тип во время объявления. например, let a<number> = 1
		не строгая - не обязывает

================================
компоненты TS

	компилятор преобразует синтаксис TS в JS. это делается или по команде в CLI, или запуском компилятора с флагом --watch.

	файл конфига, в нём указывается в какую версию js компилировать TS. путь к результирующему JS файлу и прочая подобная информация.

	всегда вместе в TS используется nodejs потому что TS это npm пакет, его нужно установить. кроме того понадобится устанавливать с помощью ноды другие пакеты: express, tslint и т.д.

================================
типы данных

	string
	number
	boolean

	tuple - массив, который содержит разные, но строго определённый типы элементов. его длина не меняется. let user: [string, number];
	array - содержат только дин тип элементов. let list: number[] = [10, 20, 30];
	enum - набор строка:строка или строка:число. в первом случае ассоциация односторонняя, во втором - двусторонняя. enum Season { Winter, Spring, Summer, Autumn };

	undefined
	null

	any - все возможные значения. может быть присвоен переменной с отлиным типом.
	unknown - все возможные значения. не может быть присвоен переменной с отличным типом.
	never	 - пустой набор возможных значений. то есть может быть присвоен любой переменной любого типа, но переменной с типом never ничего не может быть присвоено.
	void - этот тип возвращают функции, у которых нет инструкции return

================================
когда проявляется тип never?

	1. когда в функции есть бесконечный цикл

	2. когда функция всегда возвращает исключение

================================
когда пригодится тип unknown?

	когда приложение получает данные с неизвестной структурой через сетевой запрос, то опасно сразу использовать. тип any такое позволяет, а unknown не позволяет.

		let obj: any = 10;
		let result = obj.x;		// ошибка обнаружится только в рантайме

		let obj: unknown = 10;
		let result = obj.x;		// ошибка обнаружится на этапе напиания кода

================================
type guard

	это функция, которая принимает значение, проверяет его тип и возвращает булевый результат.

	проверка типов может быть реализована в теле функции при помощи typeof, instanceof, in.

	type guard имеет специфический тип возвращаемого значения функции. a is b

================================
объединение типов

	это тип, который состоит из нескольких типов, причём результирующий тип будет включать одну из составных частей. но не обязательно все их

================================
вспомогательные типы

	это набор типов, которые имеют дополнительные возможности. например:

		1. Partial описывает тип, у которого любая составляющая не обязательна.
		2. Readonly описывает тип, значение которого не может быть переназначено
		3. Record описывает тип объекта, который может иметь неограниченное количество свойств
		4. Pick описывает тип, который делает обязательными тольк определённые свойства
		5. Omit позволяет сделать определённое свойство необязательным

		и т.д.

================================
псевдонимы типов

	это дополнительное имя типа, которое задаётся при помощи служебного слова type

		type str = string;
		let test: str = 'abc';	

================================
утверждение типа 

	это сигнал разработчика компилятору о том, что разработчик знает от типе больше компилятора. в результате компилятор не подсвечивает ошибку в коде.

		let a: unknown = 'qwerty';
		let b = (a as string).length;
		console.log(b);

		или 

		let a: unknown = 'qwerty';
		let b = (<string>a).length;
		console.log(b);

================================
обязательные поля интерфейса

	если есть интерфейс, с необязательными полями:

		interface Props {
		  a?: number;
		  b?: string;
		}	

	то при помощи вспомогательного типа required можно делать все поля обязательными:

		const obj2: Required<Props> = { a: 5 };   // будет ошибка пока не задано b

================================
статические свойства

	это свойства, которые не относятся не к инстансам класса, а к самому классу. для обращения к ним применяется имякласса.имя_свойства

		class Person {
		  age = 36;
		  static retirementAge = 100;
		}

		let tom = new Person();
		console.log(tom.age);
		console.log(Person.retirementAge);


================================
модификаторы доступа

	это служебные слова, при помощи котрых осуществляется сокрытие внутренних частей инстанса:

		public свойства/метод доступен извне
		private доступен только изнутри инстанса.
		protected доступен только из наследника инстанса

		класс, у которого конструктор объявлен с модификатором доступа private, нельзя расширять

================================
геттеры и сеттеры

	это методя для получения и установки значения, которые вне класса выглядят как свойства.

	обычно их применяют чтобы иметь доступ к приватной переменной.

	сеттер может иметь аргументы, а геттер не может иметь аргументы

================================
как свойства класса сделать константами?

	нужно использовать служебное слово readonly. это аналог const для случая с переменными.

	такие свойства инициализируются только во время объявления или из конструктора.

		class Foo {
		  readonly bar = 1; // OK
		  readonly baz: string;
		  constructor() {
		    this.baz = 'hello'; // OK
		  }
		}	

================================
класс vs интерфейс

	класс это чертёж будущего объекта, он всегда остаётся в коде после еомпиляции. интерфейс это отприсание контракта между классом и его зависимостями, он пропадает из кода после компиляции.

	в классе можно прописать методы и свойства(в том числе имеющие реализацию), они будут использоваться в наследниках. таким образом можно избежать повторное написание одинакового кода для разных инстансов.

	интерфейс всего лишь указывает каие свойства и методы должен реализовать класс. таким образом, их каждый раз придётся описывать заново во всех однотипных обънетах.

================================
необяхательные свойства интерфейса

	это свойства, помеченные знаком вопроса. объект, который использует такой интерфейс не обязан их реализовывать.

================================
расширение интерфейса

	интерфесйы, подобно классам, могут наследоваться. таким образом, можно несколько интерфейсов объединить в один.

		interface IA {
		  go: string;
		}

		interface IB extends IA {
		  stop: string;
		}

		class Qwe implements IB {
		  go = 'aaa';
		  stop = 'xxx';
		}

================================
readonly свойства интерфейса 

	позволяют запретить изменять переменную, использующую интерфейс, после инициализации.

		interface Foo {
		  readonly bar: number;
		  readonly bas: number;
		}

		let foo: Foo = { bar: 123, bas: 456 };
		foo.bar = 456; // error

		console.log(foo);

================================
гибридные интерфейсы

	это интерфейсы, в который описаны: свойства, методы, функции, индексы.

		interface Circle {
		    radius: number;//property
		    (x: number, y: number): void; //function declaration
		    display(b: boolean);//method
		    [state: string]: any; //indexer
		}	

================================
слияние интерфейсов

	несколько объявлений интерфейсов с одинаковым имененм сливаются:

	кроме того несколько объявлений интерфейсов с одинаковыми именами тоже расширяют друг друга:

		interface IA {
		  go: string;
		}

		interface IA {
		  stop: string;
		}

		class Qwe implements IA {
		  go = 'aaa';
		  stop = 'xxx';
		}	

================================
статические члены класса

	это методы и свойства, которые привязаны не к инстансу, а к классу. они могут быть вызваны без создания инстанса, то есть обращением напрямую через имя класса:

		class Circle {
	    static pi: number = 3.14;
	    
	    static calculateArea(radius:number) {
	        return this.pi * radius * radius;
	    }
		}
		Circle.pi; 
		Circle.calculateArea(5); 

================================
типизация через типы и интерфейсы

	type позволяет создать новое имя типу или пересейчению типов. 

		type Pet = IDog | ICat;

	поэтому класс не может раширяться от type так как в этом случае неоднозначность недопустима.

	интерфейс описывает контракт, который может также быть использовать для расширения класса. в этом случа екласс обязан реализовать все члены интерфейса.

	types и инткерфейсы взаимозаменяемы в применении к описанию типа переменной.

		interface IAnimal {
		  age: number;
		  eat(): void;
		  speak(): string;
		}

		type AnimalTypeAlias = {
		  age: number;
		  eat(): void;
		  speak(): string;
		};

		let animalInterface: IAnimal;
		let animalTypeAlias: AnimalTypeAlias;

		animalInterface = animalTypeAlias;	

	если расширение класса происходит не через интерфейс ,а через класс, тородительский класс может содержать реализацию. в случае с интерфейсаом такое невозможно.

================================
дженерики

	в функции можно предавать значения как аргументы. дженерики позволяют передавать в функцию тип как аргумент.  в результате каждое значение имеет метку типа и функция может принимать произвольный тип, а потом в теле функции работать с этим типом. и даже вернуть этот же тип как результат функции.

		class User<T> {
		 
		    private _id: T;
		    constructor(id:T) {
		 
		        this._id=id;
		    }
		}

	дженерики также можно применять в интерфейсах, классах, алиасах.

		interface Pair<F, S> {
		    first: F;
		    second: S;
		}

		let p : Pair<String, number> = {first: "10K", second: 1000};
		console.log(p);	

================================
обобщённые классы 

	это классы, которые используют дженерики

		class User<T> {
		 
		    private _id: T;
		    constructor(id:T) {
		 
		        this._id=id;
		    }
		}	

================================
сужение типов

	иногда в функцию аргумент приходит как union type. при этом внутри функции можно получить более конкретный тип при помощи проверок. проверка может быть типа:

		1. проверка типа при помощи typeof
		2. проверка на истинность 
		3. проверка на равенство при помощи switch case
		4. проверка наличия свойства в объекте при помощи in
		5. проверка является ли объект инстансом поределённого класса при помощи instanceOf


	в результате этой проверки в теле функции мы получает точную информацию о пришедшем в функцию аргументе

================================
условный тип

	это тип, который подставляется динамически в результате срабатывания условия. внешне это похоже на тернарный оператор.

		T extends U ? T1 : T2

	то есть если тип T имеет какое то определённое свойство, то нужно использовать T1. это может пригодиться в дженериках

================================
расширение типов

	это конструирование нового типа из композиции нескольких. например существует

		type Person = {name: string; age: number};

	следующая переменная иметт расширенный тип

		let bob: Person & {company: string} = {name: "Bob", age: 41, company: "Microsoft"};

	для интерфейсов нужно использовать служебное слово extends:

		T extends U

	в этом случае тип T должен включать члены, тписанные в типе U


================================
что такое декораторы в TS?

	декораторы позволяют добавить к классам и их членам метаданные и тем самым изменить их поведение без изменения их кода. Декораторы представляют функции, которые могут применяться к классам, методам, методом доступа (геттерам и сеттерам), свойствам, параметрам.

	декоратор класса применяется к конструктору. этот декоратор принимает и возвращает функцию конструктора и, например, может её заменить.

		function logger<TFunction extends Function>(target: TFunction): TFunction {
		  let newConstructor: Function = function(name: string) {
		    console.log('Creating new instance')
		    this.name = name
		    this.age = 23
		    this.print = function(): void {
		      console.log(this.name, this.age)
		    }
		  }
		  return <TFunction>newConstructor
		}

		@logger
		class User {
		  name: string
		  constructor(name: string) {
		    this.name = name
		  }
		  print(): void {
		    console.log(this.name)
		  }
		}
		let tom = new User('Tom')
		let bob = new User('Bob')
		tom.print()
		bob.print()

	декоратор метода применяется к методу. декоратор принимает объект, название метода, дескриптор метода. и может, например, запретить переопределение метода.

		function readonly(target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
		  descriptor.writable = false	// метод нельзя переназначить
		}

		class User {
		  name: string
		  constructor(name: string) {
		    this.name = name
		  }

		  @readonly
		  print(): void {
		    console.log(this.name)
		  }
		}
		let tom = new User('Tom')
		tom.print = function() {
		  console.log('print has been changed')
		}
		tom.print() // Tom

	декоратор свойства принимает свойство. он может, например, добавить к нем геттер и сеттер:

		class IceCreamComponent {
		  @Emoji()
		  flavor = 'vanilla';
		}

		function Emoji() {
		  return function(target: Object, key: string | symbol) {

		    let val = target[key];

		    const getter = () =>  {
		        return val + '+++';
		    };

		    const setter = (next) => {
		        console.log('updating flavor...');
		        val = `🍦 ${next}okok`;
		    };

		    Object.defineProperty(target, key, {
		      get: getter,
		      set: setter,
		      enumerable: true,
		      configurable: true,
		    });

		  };
		}

		const i = new IceCreamComponent()
		console.log(i.flavor)
		i.flavor = 10
		console.log(i.flavor)

	или чтобы подменить свойство, то нужно просто переписать геттер:

		function logParameter(target: Object, propertyName: string) {
		  Object.defineProperty(target, propertyName, {
		      get: () => {
		          return '123';
		      },
		  });
		}

		class Employee {
		    @logParameter
		    name: string = '222';
		}

		const emp = new Employee();
		emp.name = 'Mohan Ram';
		console.log(emp.name);

================================
что такое перегрузка функций? приведите примеры.

	перегрузка является частью механизма полиморфизма. это способность функции выполнять различные действия в зависимости от типов и количества получаемых аргументов.

		function add(x: string, y: string): string;
		function add(x: number, y: number): number;
		function add(x: any, y: any): any {
		  return x + y;
		}

		console.log(add(5, 4)); // 9
		console.log(add('5', '4')); // 54


	для классов это тоже работает:

		class Foo {
		  method(a: string);
		  method(a: number);
		  method(a: any) {
		    console.log(typeof a, a);
		  }
		}

		const foo = new Foo();
		console.log(foo.method('1'));

================================
пространство имён namespace

	это контейнер, из которого можно импортировать: функции, классы, переменные, вложенные namespaces и прочие сущности. 

	часто namespace выносят в отдельный файл и подключают в основном файле через:

		/// <reference path="personnel.ts" />

	namespace это замена IIFE.

	пространства имён чс одинаковыми названиями сливаются подобно интерфейсам с одинаковыми названиями.

================================
модули

	это отдельные файлы. из них сущности экспортируются при помощи export или export default. каждый модуль это отдельное пространство имён.

	при импорте модуля можно задавать алиасы отдельным сущностям или модулю.

================================
миксины

	это возможность реализовать множественное наследование через интерфейс, расширяющий классы.

	создаётся вспомогательная функция, которая получает класс и массив интерфейсов. далее в циклах перебираются все ключи интерфейсов и через прототип классу добавляются новые методы.

		class Animal {
		  
		    feed():void {
		        console.log("Кормим животное");
		    }
		}
		  
		class Movable {
		  
		    speed: number=0;
		    move(): void {
		        console.log("Перемещаемся");
		    }
		}
		  
		class Horse {}
		 
		interface Horse extends Animal, Movable {}
		  
		function applyMixins(derivedCtor: any, baseCtors: any[]) {
		    baseCtors.forEach(baseCtor => {
		        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
		            derivedCtor.prototype[name] = baseCtor.prototype[name];
		        });
		    });
		}
		  
		applyMixins(Horse, [Animal, Movable]);
		  
		let pony: Horse = new Horse();
		pony.feed();
		pony.move();	

================================
map-файлы

	это файлы исходников, дело в том, что исходники перед тем ка кпопадают в бандл проходят процедуры минификации и становятся нечитаемыми. программисту же в целях отладки нужно в devTools видеть именно исходники. 

	в  TS есть возможность создавать такие файлы. для этого в конфиг файле нужно указать параметры типа: sourceRoot, mapRoot

================================
заголовочные файлы

	позволяют подключить глобальные js-переменные при помощи declare и затем использовать их в TS. это подключение описывается в файлах *.d.ts 

================================
tsconfig

	позволяет:

		указать файлы, которые будут подвергнуты компиляции,
		версию ecmascript,
		папка, в которую будет помещаться результат компиляциии,
		признак добавления use strict в результирующие файлы,


================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================