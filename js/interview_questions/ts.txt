================================
================================
================================
описать тип tuple

этот тип описывает массив, в котором задана типизация для каждого элемента. длина кортежа меняться не может. порядок элементов меняться не может.

================================
описать тип enum

	это объект с ограниченным числом пар ключ-значение, значения являются константами. если контанты - числа, то возможна двусторонняя ассоциация:

		enum Nuts {
		  Peanuts = 0,
		  Walnut = 1,
		  Hazelnut = 2,
		  Cedar = 3,
		}
		console.log(Nuts[2]); // Hazelnut
		console.log(Nuts.Cedar); // 3

	если констнты  - строки, то ассоциация односторонняя:

		enum Nuts {
		    Peanuts = 'qwe', // 0
		    Walnut = 'asd', // 1
		}
		console.log(Nuts[0]);       // undefined
		console.log(Nuts['qwe']); 	// undefined
		console.log(Nuts.Peanuts);  // qwe

	enum используется когда нужно определить несколько фиксированных значений для переменной. например, seasons это время года, оно может иметь только 4 значения.

	если вместо enum использовать объекты, то возможно равенство различных enum:

		const Seasons = {
		  Summer: 0,
		  Autumn: 1,
		  Winter: 2,
		  Spring: 3,
		};

		const Fruits = {
		  Apple: 1,
		  Orange: 1,
		};

		// sad but true. то же самое со строками
		console.log(Seasons.Autumn === Fruits.Apple); // true

	если использовать объекты, то можно переназначить значение внутри enum, это чревато:

		const Seasons = {
			Summer: Symbol("summer"),
			Autumn: Symbol("autumn"),
			Winter: Symbol("winter"),
			Spring: Symbol("spring")
		}

		Seasons.Winter = "winter" // this will overwrite the `Symbol` with a string 

	поэтому в случае с enum переназначение свойств невозможно.

-----

существует гетерогенный enum, в котором присутствуют как числовые ключи так и строковые. но его использование не рекомендуется даже в документации:

	enum BooleanLikeHeterogeneousEnum {
	  No = 0,
	  Yes = "YES",
	}

------

в отличие от других типов enum использует номинальную типизацию при присвоении. вот пример ошиблочного кода:

	enum Flavor {
	  VANILLA = 'vanilla',
	  CHOCOLATE = 'chacolate',
	}

	let flavor = Flavor.CHOCOLATE; // TS устанавливает тип Flavor для переменной flavor
	flavor = 'vanilla' // ошибка. потому что нужно использовать константу из набора enum
	flavor = Flavor.VANILLA // нет ошибки

-----

невозможно расширять enum при помощи extends. но можно использовать для этой цели union type. таким образом мы получаем аналог множественного наледования:

	enum Flavor {
	  VANILLA = 'vanilla',
	  CHOCOLATE = 'chacolate',
	}

	enum Test {
	  MINT = 'mint'
	}

	type TestFlavor = Flavor | Test;

	let flavor: TestFlavor; // нет ошибки
	flavor = Flavor.VANILLA // нет ошибки
	flavor = Test.MINT      // нет ошибки


================================
чем отличаются типы never и void

если в функции выполняется бесконечный цикл или выбрасывается исключение, то она вернёт never. если в функции нет инструкции return, то она вернёт void.

	/** Пример с прерыванием */
	function error(message: string): never {
	    throw new Error(message);
	}

	/** Бесконечный цикл */
	function infiniteLoop(): never {
	    while (true) {
	    }
	}

================================
расскзать о модулях и namespaces в ts

пространство имён это способ организации видимости переменных. важно использовать export для тех переменных, к которым есть доступ.
	namespace Validation {
	    export interface StringValidator {
	        isAcceptable(s: string): boolean;
	    }
	    const lettersRegexp = /^[A-Za-z]+$/; 
	 }

обращаться так:
Validation.StringValidator


 модули объявляют свои зависимости через import. в остальном это такие же пространства имён. модуль это отдельный файл.


================================
let vAny: any = 10;          // We can assign anything to any
let vUnknown: unknown =  10; // We can assign anything to unknown just like any 


let s1: string = vAny;     // Any is assignable to anything 
let s2: string = vUnknown; // Invalid we can't assign vUnknown to any other type (without an explicit assertion)

vAny.method();     // ok anything goes with any
vUnknown.method(); // not ok, we don't know anything about this variable

================================
что такое литеральный тип в ts?

	const a: 'qqq' = 'qqq';

================================
чем тип отличается от интерфейса?

интерфейсы можно наследовать.
интерфейсы можно слиавть(если объявлены два с одинаковым именем).
type позволяет задать новое имя для типа или для объединения типов.

================================
что такое условный чейнинг(Optional Chaining)?

	// Before
	if (foo && foo.bar && foo.bar.baz) {
	    // ...
	}

	// After
	if (foo?.bar?.baz) {
	    // ...
	}

Если значение foo?.bar равно null или undefined, выполнение выражения автоматически прекращается и возвращается undefined. исключение не выбрасывается.


================================
что такое тип функции? приведите пример.

Тип функции представляет комбинацию типов параметров и типа возвращаемого значения.

	function sum (x: number, y: number): number {
	    return x + y;
	};
	let op: (x:number, y:number) => number = sum;
	console.log(op(2, 4));  // 6

================================
что такое абстрактный класс?

от АК невозможно создать объект потому что АК нужно обязательно наследовать. АК в отличие от интерфейсов могут содержать реализацию. АК может иметь абстрактные методы, которые не содержат реализацию, и которые должны быть реализованы в наследнике.

	abstract class Figure {
	    getArea(): void{
	        console.log("Not Implemented")
	    }
	    abstract getColor(): void
	}
	class Rectangle extends Figure{
	  getColor() {
	    console.log('is red');
	  }
	}

	// const f = new Figure(); // error
	const r = new Rectangle();
	console.log(r)
	r.getArea();
	r.getColor();

================================
что такое интерфейс?

интерфейс - это определение кастомного типа данных, то есть способ описать тип данных. этот тип данных может состоять их свойств и методов. но без реализации методов. определяет свойства и методы, которые объект должен реализовать

================================
как в интерфейсе обозначаются необязательные свойства?

	они помечаются выпросительным знаком.

	interface IUser {
	    id: number;
	    name: string;
	    age?: number;
	}

================================
как используются дженерики при создании экземпляра класса?

	class A<T> {
	  a: T;

	  constructor(a: T) {
	    this.a = a;
	  }

	  action() {
	    console.log('action', this.a, typeof this.a);
	  }
	}

	const a = new A(123);
	a.action();


================================
как используются дженерики в механизме наследования классов?

	class A<T> {
	  a: T;

	  constructor(a: T) {
	    this.a = a;
	  }

	  action() {
	    console.log('action', this.a, typeof this.a);
	  }
	}

	class B extends A<string> {}
	const b = new B('qwe');
	b.action();

	здесь <number> вызовет ошибку линтера.

или

	class A<T, U> {
	  a: T;
	  v: U;

	  constructor(a: T, v: U) {
	    this.a = a;
	    this.v = v;
	  }

	  action() {
	    console.log('action', this.a, typeof this.a);
	    console.log('action_', this.v, typeof this.v);
	  }
	}

	class B extends A<string, number> {}
	const b = new B('qwe', 123);
	b.action();

так тоже можно:

	class B extends A<string, string> {}
	const b = new B('qwe', '123');
	b.action();

================================
типы any, never, unknown:

	типы вообще можно понимать как контейнеры допустимых значений. например

	  let a: number; // [1, 2, 3, 30, 100, и т.д.]

	тип any содержит все возможные значения. но он выпадает из этой концепции потому что any-значению может быть присвоено любое другое значение и наоброт - значение any можно назначить значению любого другого типа.

	  let a: any = 123;

	  и 

	  let a: number = 123;
	  let b = function(): any {
	    return 'qwe';
	  }
	  a = b()  // ошибки не будет

	таким образом тип any выпадает из концепции наборов допустимых значений.

	тип unknown исправляет это. он может использоваться как any с той лишь разницей, что unknown значение не может быть назначаемо произвольному типу:

	  let a: unknown = 123;  тут ок
	  let res = 'qwwe';
	  res = a;  // тут будет ошибка

	тип never это пустой контейнер возможных значений. следовательно его можно назначить любому типу. но ему нельзя назначить никакой тип

	  let a: number = 123;
	  let b = function (): never {
	    while (true) {
	      console.log(1);
	    }
	  };
	  a = b(); // ошибки не будет

	  и

	  let a: never = 123;  // будет ошибка

	ещё один пример полезности never:

		допустим, есть switchcase, у которого блок default никогда не наступает. при этом в default выполняется функция с аргументом. при объявлении этой функции используется тип never.

		но если так случится, что когда-нибудь эта функция сработает(после измененеия кодовой базы новым программистом, например), то в её теле нужно поместить вызов исключения.

================================
TS может работать с включенным и отключенным значенимем конфига --strictNullChecks. если оно включено, то на этапе компиляции проверяются все места, в которых отсутствие значения может привести к ошибке. также проверяются неинициализированные при объявлении или в конструкторе свойства классов.

разработчик может отключить вывод ошибки при помощи оператора !. важно понимать, что если ошибка всё таки случится, то программа упадёт.

если --strictNullChecks отключено, то никаких проверок на null и undefined компилятором не проводится.

другими словами strictNullChecks удаляет из контейнеров типов null и undefined

------

function getUser(id: number): User {
    if (id >= 0) {
        return { name: 'John', age: 12 };
    } else {
        return undefined;
    }
}

Тип getUser гарантирует, что функция всегда возвращает объект типа User. Однако функция может также вернуть значение undefined!


К счастью, включение флага --strictNullChecks приводит к ошибке компиляции: Type 'undefined' is not assignable to type 'User'.

================================
Оператор опциональной последовательности ?. позволяет получить значение свойства, находящегося на любом уровне вложенности в цепочке связанных между собой объектов, без необходимости проверять каждое из промежуточных свойств в ней не существование. ?. не выбрасывает исключение, если объект, к свойству или методу которого идёт обращение, равен null или undefined. В этих случаях он возвращает undefined.

================================
все ли принципы ООП поддерживает TS?

	инкапсуляция:

		 public, protected и private.

		существует возможность обойти действие модификатора private при помощи утверждение типа:

			class Diary {
			  private secret = 'ssssss';
			}

			const diary = new Diary();
			console.log((diary as any).secret);


	наследование:

		extend

	полиморфизм:

		function add(x: string, y: string): string;
		function add(x: number, y: number): number;
		function add(x: any, y: any): any {
		    return x + y;
		}

================================
в чём отличие type от interface?

	type: 
		позволяет объявлять алиас типа. в том числе объединение или пересечение.

	interface: 
		может наследоваться другим interface.
		несколько interface  одинаковыми именами объединяются.
		класс может реализовывать interface

================================
в чём отличие абстрактного класса и интерфейса?

	АК:
		на основе него нельзя создать экземпляр, АК можно только наследовать.
		АК может содержать реализацию

	интерфейс:
		не может содержать реализацию.

	АК применяются для случаев когда нужно создавать экземпляры. интерфейсы - для проверки контракта.

================================
declare

  В TS-проектах мы часто импортируем сторонние JS-SDK с помощью тега script. например импортируем через html гугл-карты.

  после этого TS будет подчёркиваит красным обращение к глобальное переменной new google.maps

  чтобы этого не было нужно прописать:

    declare var google: any;

================================
keyof

  В JS ключи объекта извлекаются с помощью метода Object.keys:

    const user = {
      id: 666,
      name: "bytefer",
    }
    const keys = Object.keys(user); // ["id", "name"]

  В TS это делается с помощью keyof:

		type User = {
		  id: number;
		  name: string;
		};
		type UserKeys = keyof User; // "id" | "name"

		let a: UserKeys = 'id';

		console.log(a);

	то есть в итоге keyof возвращает объединение нескольких литеральных типов.


=========================================================
из чего состоит ts

  ts это надстройка над js. сдедовательно нужен модуль, который будет производить компиляцию. этот модуль он устанавилвается через npm, следовательно нужно установить nodeJS. в модуле компиляции указываются пути к ts файлу и скомпилированному js-файлу. 

  кроме того указывается в какую версию ecmascript компилировать. а так же разные мелкие опции типа удаления комментариев в результирующем файле. 

  обычно используется опция watch, которая отслеживает момент когда в ts-фале было сделано изменение и после этого автоматически запускается компиляция

=========================================================
тип never

  описывает случай когда ничего не произойдёт. например если в функции выполняется бесконечный цикл, то её результат описывается типом never. также если функция возвращает исключение, то её результат тоже описывается типом never

=========================================================
тип unknown

  тип any позволяет производить любые операции со значениями, которые им помечены:

    const anyValue: any = 'any value'
    console.log(anyValue.add())

  эти ошибки будут обнаружены только на этапе выполнения, но не на этапе написания кода. другими словами программист говорит компилятору то том, что он знает что делает.

  тип unknown в таких случаях обнаруживает ошибку именно на этапе написания кода.

    let unknownValue: unknown
    unknownValue = 'unknown value'
    unknownValue.toString() // Ошибка: Object is of type 'unknown'  

=========================================================
as const

  замораживает внутренности объекта (добавление, переназначение свойств). и на разрешает расширять типы(например литеральный тип в string).

		const user = {
		  id: 1,
		  name: 'qwe',
		} as const;

		user.name = 'zzz';

		console.log(user);
		  

  это аналог freeze();

=========================================================
Статические индексы и индексы экземпляров

  динамические ключи можно использовать не только в объекте, но и в экземляре класса, 

    class User {
      username: string
      age: number

      constructor(username: string,age: number) {
        this.username = username
        this.age = age
      }

      [propName: string]: string | number
    }

    const user = new User('John', 23)
    user['phone'] = '+79876543210'

  и в классе

    class User {
      username: string
      age: number

      constructor(username: string,age: number) {
        this.username = username
        this.age = age
      }

      static [propName: string]: string | number
    }

    User['userCount'] = 0  

=========================================================
Объект с произвольным количеством свойств

  type studentScore= { [name: string]: number };

  или

  type studentScore = Record<string, number>;

  то есть каждая запись в объекте будет иметь ключ типа стринг и значение типа намбер

=========================================================
класс может расширять только один класс (множественное наследование в TS, как и в JS, запрещено).
Однако мы вполне можем реализовывать (implements) несколько интерфейсов:

=========================================================
шаблонные литеральные типы:

  type Alignment = 'start' | 'end';
  type Side = 'top' | 'right' | 'bottom' | 'left';
  type AlignedPlacement = ${Side}-${Alignment};
  type Placement = Side | AlignedPlacement;
  
================================
утиная типизация 

  это проверка реализации объектом требуемого интерфейса. если кроме свойств, заявленных в интерфейся, присутствуют дополнительные свойства, то это не мешает отнести объект к типу, который не подразумевает наличие дополнительных свойств.

================
Тип never 

  можно указать только той функции, из которой программа никогда не сможет выйти.

================
Слабое сопряжение/зацепление (loose coupling)

  зацепление(coupling) говорит насколько классы одного компонента сильно зависят от классов другого компонента. оно должно быть минимальным. это поможет безболезненно отключить один из компонентов или добавить новый.

  возможны 3 ситуации:

  	1. первый класс ничего не знает о связи со вторым (второй класс легче сломать)
  	2. второй класс не знает о связи с первым
  	3. оба класса знают о друг друге

  поэтому существует формула для расчёта силы связи (афферентное и эфферентное зацепление)

  методы внутри класса должны относиться к решению одной задачи, то есть связаны. связанность это характеристика характеризующая насколько методы внутри класса относятся к решению одной задачи.

================
Интерфейсы предназначены 
  
  для описания публичного api, которое служит для сопряжения с программой. например, controlValueAccessor имплементирует определённый интерфейс, следовательно должен иметь 4 метода. 

  также интерфейсы описывают контракт, то есть типы входных и выходных параметров сущности:

 тип функции getUser гарантирует, что она возвращает объект, у которого всегда есть два свойства: name и age.

		interface User {
		  name: string;
		  age: number;
		}

		function getUser(id: number): User { /* ... */ }

================
Добавление статических свойств и методов в класс заставляет их действовать как singleton, в то время как определение нестатических свойств и методов заставляет их действовать как factory.

  singleton:

    const pizza = PizzaMaker.create({
      name: 'Inferno',
      toppings: ['cheese', 'peppers'],
    });
    console.log(pizza);
    // Output: { name: 'Inferno', toppings: [ 'cheese', 'peppers' ] }  

  factory:

    class PizzaMaker {
      create(event: { name: string; toppings: string[] }) {
        return { name: event.name, toppings: event.toppings };
      }
    }
    const pizzaMaker = new PizzaMaker();
    const pizza = pizzaMaker.create({
      name: 'Inferno',
      toppings: ['cheese', 'peppers'],
    });
    console.log(pizza);
    // Output: { name: 'Inferno', toppings: [ 'cheese', 'peppers' ] }    

================
readonly 

  Локальную переменную можно определить как неизменяемую при помощи ключевого слова const. readonly делает то же самое для свойства класса. но такое свойство всё таки можно переопределить через конструктор

    interface IAnimal {
        readonly name: string;
    }

    class Animal implements IAnimal {
        public readonly name: string; // Ok
        public readonly name: string = 'qwe'; // даже так Ok
        
        constructor(){
            this.name = 'animal'; // Ok
        }
    }

  Если полям, помеченным “только для чтения”, не указан тип, а присвоение примитивного значения происходит в месте объявления, то для таких полей вывод типов укажет принадлежность к литеральному типу.

    class Animal {
        public readonly nameReadonly = 'animal'; // nameReadonly: "animal"
        public nameDefault = 'animal';           // nameDefault: string
    }  

  -----

  можно указать аргумент функции как readonly. в этом случае, если в функцию приходит объект, то изменить его поссылке будет невозможно.

		const obj = {
		  a: 1,
		  b: 2,
		};

		function f(obj: Readonly<Record<string, number>>) {
		  obj.a = 10; // linter error
		  obj.c = 30; // linter error
		}

		f(obj);

		console.log(obj);  

================
открытый обобщённый тип:

  class T1<T> {
    public f: T0<number, T>; // T0 - открытый тип
  }

закрытый обобщённый тип:

  class T1<T> {
    public f1: T0<number, string>; // T0 - закрытый тип
  }

================
нельзя использовать одинаковые названия для параметризованной и непараметризованной сущности:

  class T2<T> {}
  class T2 {} // Error -> Duplicate identifier

================
параметры типа можно расширять. вот неуспешный пример:

  class Collection<T> {
      private itemAll: T[] = [];
      
      public add(item: T): void {
          this.itemAll.push(item);
      }

      public getItemByName(name: string): T {
          return this.itemAll.find(item => item.name === name); // Error -> Property 'name' does not exist on type 'T'
      }
  }

При операции поиска в массиве возникнет ошибка. Это происходит по причине того, что в типе T не описано свойство name. Для того, что бы ошибка исчезла, тип T должен расширить тип, в котором описано необходимое свойство name.   

вот правильное решение проблемы при помощи расширения параметра типа:

  interface IName {
      name: string;
  }

  class Collection<T extends IName> {
      private itemAll: T[] = [];

      public add(item: T): void {
          this.itemAll.push(item);
      }

			public getItemByName(name: string): T {
          return this.itemAll.find(item => item.name === name); // Ok
      }
  }

================
type assertion

  в DOM все элементы имеют наивысшего родителя Element. но часть элементов не отображается(script), а часть отображается(div). те которые отображаются принадлежат к более узкому типу HTMLElement.

  querySelector() может найти и видимый элемент, и невидимый.

    // <canvas id="stage" data-inactive="false"></canvas>
    const element: Element = document.querySelector('#stage');
    const stage: HTMLElement = element // Error, Element is not assignable to type HTMLElement

   таким образом, если находим невидимый элемент ихотим его присвоить переменной типа HTMLElement, то получим ошибку. чтобы ошибки избежать нужно применять приведение типа as HTMLElement:

   	const stage: HTMLElement = element as HTMLElement

  вообще TS не имеет связи с DOM поэтому для элементов DOM нужно использовать утверждения.      

================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================

вопросы из навигатора 

================================
что такое TS?

	TS это язык, который расширяет возможности js при помощи особого синтаксиса, который пред выполнением компилируется в обычный JS.  возможности следующие:

		1. строгая типизация
		2. полноценные классы (инкапсуляция, полиморфизм, инттерфейсы, абстрактные классы)
		3. дополнительные типы

	TS позвоняет выявить большинство ошибок на этапе написания кода, а не выполнения.

================================
виды типизации:

	1.
		статическая - тип определяетнся на этапе объявления
		динамическая - тип определяется на этапе присвоения значения

	2.
		сильная - не позволяет приводить типы при выполнении операции с операндами разного типа. например, 1 + 'qwe'
		слабая - позволяет.

	3.
		явная - обязывает указывать конкретный тип во время объявления. например, let a<number> = 1
		не явная - не обязывает, в этом случае тип назначается автоматически.

================================
компоненты TS

	компилятор преобразует синтаксис TS в JS. это делается или по команде в CLI, или запуском компилятора с флагом --watch.

	файл конфига, в нём указывается в какую версию js компилировать TS. путь к результирующему JS файлу и прочая подобная информация.

	всегда вместе в TS используется nodejs потому что TS это npm пакет, его нужно установить. кроме того понадобится устанавливать с помощью ноды другие пакеты: express, tslint и т.д. также нода непосредственно выполняет функционал TS.

================================
типы данных

	string
	number
	boolean

	tuple - массив, который содержит разные, но строго определённый типы элементов. его длина не меняется. let user: [string, number];
	array - коллекции, которые содержат только дин тип элементов. let list: number[] = [10, 20, 30];
	enum - набор строка:строка или строка:число. в первом случае ассоциация односторонняя, во втором - двусторонняя. enum Season { Winter, Spring, Summer, Autumn };

	undefined
	null
	symbol
	bigint

	any - все возможные значения. может быть присвоен переменной с отличным типом.
	unknown - все возможные значения. не может быть присвоен переменной с отличным типом.
	never	 - пустой набор возможных значений. то есть может быть присвоен любой переменной любого типа, но переменной с типом never ничего не может быть присвоено.
	void - этот тип возвращают функции, у которых нет инструкции return

	типы вообще можно понимать как контейнеры допустимых значений. например

	  let a: number; // [1, 2, 3, 30, 100, и т.д.]

================================
когда проявляется тип never?

	1. когда в функции есть бесконечный цикл

	2. когда функция всегда возвращает исключение

================================
когда пригодится тип unknown?

	когда приложение получает данные с неизвестной структурой через сетевой запрос, то опасно сразу использовать. тип any такое позволяет, а unknown не позволяет.

		let obj: any = 10;
		let result = obj.x;		// ошибка обнаружится только в рантайме

		let obj: unknown = 10;
		let result = obj.x;		// ошибка обнаружится на этапе напиания кода

	также unknown можно использовать вместо any в возвращаемом значении функции чтобы неопределённость не распространялась за пределы видимости этой функции.

================================
type guard

	это функция, которая принимает значение, проверяет его тип и возвращает булевый результат.

	проверка типов может быть реализована в теле функции при помощи typeof, instanceof, in.

	type guard имеет специфический тип возвращаемого значения функции: a is b. это означает: identifier is Type. Первым членом выражения является идентификатор, который обязан совпадать с идентификатором одного из параметров, объявленных в сигнатуре функции. 

		let pet =  {
		    // swim: function() {
		    //   console.log('swim');
		    // },
		    fly: function() {
		      console.log('fly');
		    }    
		  };

		interface Fish { swim: any }
		interface Bird { fly: any }

		function isFish(pet: Fish | Bird): pet is Fish {
		  return (pet as Fish).swim !== undefined;
		}

		if (isFish(pet)) {
		  pet.swim();
		} else {
		  pet.fly();
		}

		// fly


		итак, pet is Fish означает, что если pet имеет тип Fish, то функция проверки возвращает true	

================================
объединение типов

	union это тип, полученный в результате перечисления нескольких типов. результирующий тип принадлежит к одному из перечисленных

		interface Phone {
		  number: string;
		}
		interface Person {
		  name: string;
		}
		let employee: Phone | Person = {
		  name: 'Jane',
		}

	intersection это тип, полученный в результате перечисления нескольких типов. результирующий тип включает все перечилсенные

		interface Phone {
		  number: string;
		}
		interface Person {
		  name: string;
		}
		let employee: Phone & Person = {
		  number: '+7 927 555-55-55',
		  name: 'Jane',
		}

================================
вспомогательные типы

	это набор типов, которые имеют дополнительные возможности. например:

		1. Partial описывает тип, у которого любая составляющая не обязательна.
		2. Readonly описывает тип, значение которого не может быть переназначено
		3. Record описывает тип объекта, который может иметь неограниченное количество свойств
		4. Pick описывает тип, который делает обязательными только пределённые свойства
		5. Omit позволяет сделать определённое свойство необязательным

		и т.д.

	пример определения типа и его дальнейшего примененеия на практике:

		interface Album {
		  artist: string;
		  title: string;
		}

		const kindOfBlue: Album = {
		  artist: 'md',
		  title: 'kob',
		};

		const func = function (): Album {
		  return kindOfBlue;
		};

		type Test = ReturnType<typeof func>;

		const funcTest = function (): Test {
		  return kindOfBlue;
		};

	также есть возможность получить не только тип, который возвращает функция, но и тип параметров функции:

		typeMyName = Parameters<typeof getGift>[0]


================================
псевдонимы типов

	это дополнительное имя типа, которое задаётся при помощи служебного слова type

		type str = string;
		let test: str = 'abc';	

================================
утверждение типа 

	это сигнал разработчика компилятору о том, что разработчик знает от типе больше компилятора. в результате компилятор не подсвечивает ошибку в коде.

		let a: unknown = 'qwerty';
		let b = (a as string).length;
		console.log(b);

		или 

		let a: unknown = 'qwerty';
		let b = (<string>a).length;
		console.log(b);

	-------------

	например, querySelector возвращает тип element, но разработчик хочет его приравнять к переменной типа HTMLElement. при этом в element есть все свойства HTMLElement и даже больше. формально эти типы различаются, но практически нет.

		const element: Element = document.querySelector( '#stage' );
		const stage: HTMLElement = <HTMLElement> element // Ok

	альтернативная форма записи:

		 let element = document.querySelector('#counter') as HTMLElement;


================================
обязательные поля интерфейса

	если есть интерфейс, с необязательными полями:

		interface Props {
		  a?: number;
		  b?: string;
		}	

	то при помощи вспомогательного типа required можно делать все поля обязательными:

		const obj2: Required<Props> = { a: 5 };   // будет ошибка пока не задано b

================================
статические свойства

	это свойства, которые относятся не к инстансам класса, а к самому классу. для обращения к ним применяется имякласса.имя_свойства

		class Person {
		  age = 36;
		  static retirementAge = 100;
		}

		let tom = new Person();
		console.log(tom.age);
		console.log(Person.retirementAge);

	статические свойства класса могут наследоваться:

		class Person {
		  
		    age: number;
		    name: string;
		     
		    static retirementAge: number = 65;
		    static calculateYears(age: number): number{
		         
		        return Person.retirementAge - age;
		    }
		     
		    constructor(name: string, age: number) {
		        this.name = name;
		        this.age = age;
		    }
		}
		class Employee extends Person {}
		 
		let years = Employee.calculateYears(36);
		console.log(Employee.retirementAge);

	экземпляры не имеют доступа к статическим свойствам класс:

		class Animal {
		  age: number;
		  static gender = 'male';

		  constructor() {
		    this.age = Math.random();
		  }
		}

		const i = new Animal();
		console.log(i.age);
		console.log(i.gender); // undefined

================================
модификаторы доступа

	это служебные слова, при помощи котрых осуществляется сокрытие внутренних частей инстанса:

		public свойства/метод доступен извне инстанса.
		private доступен только изнутри инстанса.
		protected доступен только из наследника инстанса.

		класс, у которого конструктор объявлен с модификатором доступа private, нельзя расширять

================================
геттеры и сеттеры

	это методя для получения и установки значения, которые вне класса выглядят как свойства.

	обычно их применяют чтобы иметь доступ к приватной переменной.

	сеттер может иметь аргументы, а геттер не может иметь аргументы

================================
как свойства класса сделать константами?

	нужно использовать служебное слово readonly. это аналог const для случая с переменными.

	такие свойства инициализируются только во время объявления или из конструктора.

		class Foo {
		  readonly bar = 1; // OK
		  readonly baz: string;
		  constructor() {
		    this.baz = 'hello'; // OK
		  }
		}	

---------

class Animal {
  readonly test = 'str';

  readonly age = {
    a: 12,
    b: 34,
  };

  ttt = {
    z: 1,
    x: 2,
  } as const;

  readonly hhh = {
    v: 111,
    b: 222,
  };
}

const i = new Animal();
i.test = 'qwerty'; // compilation error
i.age = {}; // compilation error
i.ttt.x = 10; // compilation error
i.hhh.v = 666; // ok
console.log(i.test);
console.log(i.age);
console.log(i.ttt);
console.log(i.hhh);


================================
класс vs интерфейс

	класс это чертёж будущего объекта, он всегда остаётся в коде после компиляции. интерфейс это описание контракта между классом и его зависимостями, он пропадает из кода после компиляции.

	в классе можно прописать методы и свойства(в том числе имеющие реализацию), они будут использоваться в наследниках. таким образом можно избежать повторное написание одинакового кода для разных инстансов.

	интерфейс всего лишь указывает какие свойства и методы должен реализовать класс. таким образом, их каждый раз придётся описывать заново во всех однотипных объектах.

================================
необязательные свойства интерфейса

	это свойства, помеченные знаком вопроса. объект, который использует такой интерфейс не обязан их реализовывать.

================================
расширение интерфейса

	интерфесйы, подобно классам, могут наследоваться. таким образом, можно несколько интерфейсов объединить в один.

		interface IA {
		  go: string;
		}

		interface IB extends IA {
		  stop: string;
		}

		class Qwe implements IB {
		  go = 'aaa';
		  stop = 'xxx';
		}

================================
readonly свойства интерфейса 

	позволяют запретить изменять переменную, использующую интерфейс, после инициализации.

		interface Foo {
		  readonly bar: number;
		  readonly bas: number;
		}

		let foo: Foo = { bar: 123, bas: 456 };
		foo.bar = 456; // error

		console.log(foo);

================================
гибридные интерфейсы

	это интерфейсы, в который описаны: свойства, методы, функции, индексы.

		interface Circle {
		    radius: number;//property
		    (x: number, y: number): void; //function declaration
		    display(b: boolean): void //method
		    [state: string]: any; //indexer
		}	

		выше представлен в том числе и интерфейс массива:

			interface StringArray {
			    [index: number]: string;
			}
			 
			let phones: StringArray;
			phones = ["iPhone 7", "HTC 10", "HP Elite x3"];

		вот пример функции:

			interface PersonInfo {
			  (name: string, surname: string): void;
			}

			function test(): PersonInfo {
			  return function f(name: string, surname: string, q: string) { // здесь ошибка! нужно удалить параметр q
			    return [name, surname];
			  };
			}

			console.log(test()('zzz', 'xxx'));


================================
слияние интерфейсов

	 несколько объявлений интерфейсов с одинаковыми именами тоже расширяют друг друга:

		interface IA {
		  go: string;
		}

		interface IA {
		  stop: string;
		}

		class Qwe implements IA {
		  go = 'aaa';
		  stop = 'xxx';
		}	

================================
статические члены класса

	это методы и свойства, которые привязаны не к инстансу, а к классу. они могут быть вызваны без создания инстанса, то есть обращением напрямую через имя класса:

		class Circle {
	    static pi: number = 3.14;
	    
	    static calculateArea(radius:number) {
	        return this.pi * radius * radius;
	    }
		}
		Circle.pi; 
		Circle.calculateArea(5); 

================================
типизация через типы и интерфейсы

	type позволяет создать новое имя типу или пересейчению типов. 

		type Pet = IDog | ICat;

	поэтому класс не может раширяться от type так как в этом случае неоднозначность недопустима.

	интерфейс описывает контракт, который может также быть использовать для расширения класса. в этом случае класс обязан реализовать все члены интерфейса.

	types и инткерфейсы взаимозаменяемы в применении к описанию типа переменной.

		interface IAnimal {
		  age: number;
		  eat(): void;
		  speak(): string;
		}

		type AnimalTypeAlias = {
		  age: number;
		  eat(): void;
		  speak(): string;
		};

		let animalInterface: IAnimal;
		let animalTypeAlias: AnimalTypeAlias;

		animalInterface = animalTypeAlias;	

	если расширение класса происходит не через интерфейс ,а через класс, то родительский класс может содержать реализацию. в случае с интерфейсаом такое невозможно.

================================
generics

	в функции можно предавать значения как аргументы. дженерики позволяют передавать в функцию тип как аргумент.  в результате каждое значение имеет метку типа и функция может принимать произвольный тип, а потом в теле функции работать с этим типом. и даже вернуть этот же тип как результат функции.

		class User<T> {
		 
		    private _id: T;
		    constructor(id:T) {
		 
		        this._id=id;
		    }
		}

	дженерики также можно применять в интерфейсах, классах, алиасах.

		interface Pair<F, S> {
		    first: F;
		    second: S;
		}

		let p : Pair<String, number> = {first: "10K", second: 1000};
		console.log(p);	

-----

	Обобщённый тип позволяет резервировать место для неизвестного типа, который будет заменён на конкретный, переданный пользователем(явно или не явно).

		function identity<T>(arg: T): T {
			return arg;
		}

	Конструкция <T> после имени функции указывает на то, что эта функция собирается захватить тип и подменить им все T. при вызове этой функции нужно явно указывать обобщённый тип:

		identity<number>(115);

	но можно вызвать и так. в этом случае обобщённый тип в угловых скобках определится автоматически:

		identity('string');

================================
обобщённые классы 

	это классы, которые используют дженерики

		class User<T> {
		 
		    private _id: T;
		    constructor(id:T) {
		 
		        this._id=id;
		    }
		}	

	здесь  T доступен только в конструкторе. в методах он недоступен

================================
сужение типов

	это действие компилятора, в результате которого переменной назначается более узкий тип чем тот, который имел в виду разработчик.

	const result = []; // тип any[]
	result.push('a');
	console.log(result); // тип string[]
	result.push(1);
	console.log(result); // тип (string | number)[]

================================
условный тип

	это тип, который подставляется динамически в результате срабатывания условия. внешне это похоже на тернарный оператор.

		T extends U ? T1 : T2

	то есть если тип T имеет какое то определённое свойство, то нужно использовать T1. это может пригодиться в дженериках

================================
расширение типов

	это действие компилятора, в результате которого переменной назначается более общий тип чем тот, который имел в виду разработчик.

	например пользователь ожидает, что после присваивания переменная будет иметь литеральный тип 'x':

		interface Vector3 {
		  x: number;
		  y: number;
		  z: number;
		}

		function getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {
		  return vector[axis];
		}

		let x = 'x'; // разработчик имел в виду литеральный тип, а компилятор назначил тип string
		// let x = 'x' as const;  // right solution
		// const x = 'x';					// right solution

		let vec = { x: 10, y: 20, z: 30 };
		getComponent(vec, x); // error x type

	но в действительности переменная имеет НЕ литеральный тип 'qwerty', а тип string.



================================
что такое декораторы в TS?

	декораторы позволяют добавить к классам и их членам метаданные и тем самым изменить их поведение без изменения их кода. Декораторы представляют функции, которые могут применяться к классам, методам, методом доступа (геттерам и сеттерам), свойствам, параметрам.

	декоратор класса применяется к конструктору. этот декоратор принимает и возвращает функцию конструктора и, например, может её заменить.

		function logger<TFunction extends Function>(target: TFunction): TFunction {
		  let newConstructor: Function = function(name: string) {
		    console.log('Creating new instance')
		    this.name = name
		    this.age = 23
		    this.print = function(): void {
		      console.log(this.name, this.age)
		    }
		  }
		  return <TFunction>newConstructor
		}

		@logger
		class User {
		  name: string
		  constructor(name: string) {
		    this.name = name
		  }
		  print(): void {
		    console.log(this.name)
		  }
		}
		let tom = new User('Tom')
		let bob = new User('Bob')
		tom.print()
		bob.print()

	декоратор метода применяется к методу. декоратор принимает объект, название метода, дескриптор метода. и может, например, запретить переопределение метода.

		function readonly(target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
		  descriptor.writable = false	// метод нельзя переназначить
		}

		class User {
		  name: string
		  constructor(name: string) {
		    this.name = name
		  }

		  @readonly
		  print(): void {
		    console.log(this.name)
		  }
		}
		let tom = new User('Tom')
		tom.print = function() {
		  console.log('print has been changed')
		}
		tom.print() // Tom

	декоратор свойства принимает объект и свойство. он может, например, добавить к нем геттер и сеттер:

		class IceCreamComponent {
		  @Emoji()
		  flavor = 'vanilla';
		}

		function Emoji() {
		  return function(target: Object, key: string | symbol) {

		    let val = target[key];

		    const getter = () =>  {
		        return val + '+++';
		    };

		    const setter = (next) => {
		        console.log('updating flavor...');
		        val = `🍦 ${next}okok`;
		    };

		    Object.defineProperty(target, key, {
		      get: getter,
		      set: setter,
		      enumerable: true,
		      configurable: true,
		    });

		  };
		}

		const i = new IceCreamComponent()
		console.log(i.flavor)
		i.flavor = 10
		console.log(i.flavor)

	или чтобы подменить свойство, то нужно просто переписать геттер:

		function logParameter(target: Object, propertyName: string) {
		  Object.defineProperty(target, propertyName, {
		      get: () => {
		          return '123';
		      },
		  });
		}

		class Employee {
		    @logParameter
		    name: string = '222';
		}

		const emp = new Employee();
		emp.name = 'Mohan Ram';
		console.log(emp.name);

================================
что такое перегрузка функций? приведите примеры.

	перегрузка является частью механизма полиморфизма. это способность функции выполнять различные действия в зависимости от типов и количества получаемых аргументов.

		function add(x: string, y: string): string;
		function add(x: number, y: number): number;
		function add(x: any, y: any): any {
		  return x + y;
		}

		console.log(add(5, 4)); // 9
		console.log(add('5', '4')); // 54


	для классов это тоже работает:

		class Foo {
		  method(a: string);
		  method(a: number);
		  method(a: any) {
		    console.log(typeof a, a);
		  }
		}

		const foo = new Foo();
		console.log(foo.method('1'));

================================
пространство имён namespace

	это контейнер, из которого можно импортировать: функции, классы, переменные, вложенные namespaces и прочие сущности. 

	часто namespace выносят в отдельный файл и подключают в основном файле через:

		/// <reference path="personnel.ts" />

	namespace это замена IIFE.

	пространства имён с одинаковыми названиями сливаются подобно интерфейсам с одинаковыми названиями.

================================
модули

	это отдельные файлы. из них сущности экспортируются при помощи export или export default. каждый модуль это отдельное пространство имён.

	при импорте модуля можно задавать алиасы отдельным сущностям или модулю.

================================
миксины

	это возможность реализовать множественное наследование через интерфейс, расширяющий классы.

	создаётся вспомогательная функция, которая получает класс и массив интерфейсов. далее в циклах перебираются все ключи интерфейсов и через прототип классу добавляются новые методы.

		class Animal {
		  
		    feed():void {
		        console.log("Кормим животное");
		    }
		}
		  
		class Movable {
		  
		    speed: number=0;
		    move(): void {
		        console.log("Перемещаемся");
		    }
		}
		  
		class Horse {}
		 
		interface Horse extends Animal, Movable {}
		  
		function applyMixins(derivedCtor: any, baseCtors: any[]) {
		    baseCtors.forEach(baseCtor => {
		        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
		            derivedCtor.prototype[name] = baseCtor.prototype[name];
		        });
		    });
		}
		  
		applyMixins(Horse, [Animal, Movable]);
		  
		let pony: Horse = new Horse();
		pony.feed();
		pony.move();	

================================
map-файлы

	это файлы исходников, дело в том, что исходники перед тем как попадают в бандл проходят процедуры минификации и становятся нечитаемыми. программисту же в целях отладки нужно в devTools видеть именно исходники. 

	в  TS есть возможность создавать такие файлы. для этого в конфиг файле нужно указать параметры типа: sourceRoot, mapRoot

================================
заголовочные файлы

	позволяют подключить глобальные js-переменные при помощи declare и затем использовать их в TS. это подключение описывается в файлах *.d.ts 

================================
tsconfig

	позволяет:

		указать файлы, которые будут подвергнуты компиляции,
		версию ecmascript,
		папка, в которую будет помещаться результат компиляциии,
		признак добавления use strict в результирующие файлы,

	Файл tsconfig.json используется при компиляции в том случае, если компилятору не передаются названия файлов, которые надо скомпилировать. В этом случае компилятор TypeScript просматривает текущий каталог, ищет в нем файл tsconfig.json и затем при компиляции использует те параметры, которые определены в этом файле(в секции files).

	Если же компилятору передаются названия файлов, например, tsc app.ts, то файл tsconfig.json игнорируется.		

	несколько tsconfig-файлов могут быть связаны наследованием при помощи extends.

	Если опция files не указана, то TypeScript будет использовать include для поиска компилируемых файлов. Если include так же не указана, то поиск файлов будет осуществляться во всех папках и их подпапках.	

	чтобы задать псевдонимы для коротких путей нужно в секции paths указать ссылку на index.ts-файл

		"@libs/store/standards": ["libs/store/standards/src/index.ts"],

	после этого импорт будет выглядеть так:

		import { StandardsFacade } from '@libs/store/standards';

	если не используется index.ts-файл, то в секции path нужно использовать звёздочки:

		"@lib/*": ["src/lib/*"],

------

	strictNullChecks удаляет null и undefined из области типов. следовательно qwe: number может теперь быть только number, но не null и не undefined. правильным ариантом теперь будет:

		qwe: number | null 

	или

		qwe!: number

	при объявлении интерфеса тоже может быть ошибка:

		interface Member {
		    name: string;
		    age?: number;
		}

	в случае наличия неинициализированных свойств класса тоже появится ошибка (кроме случая когда свойство инициализируется в конструкторе). но если позже в каком-нибудь методе будет происходить инициализация и программист об этом знает, то можно использовать постфиксный ! чтобы избежать ошибки на этапе анализа.

-----

	noImplicityAny включает проверку, которая требует наличие явно указанного типа (явная типизация). не принимается отсутствие типизации:

		function log(someArg) {
		    // Ошибка : someArg имеет неявный тип any
		    sendDataToServer(someArg);
		}

	исправить эту ситуацию можно так:

		function log(someArg: any) {
		    sendDataToServer(someArg);
		}



================================
если к объекту происходит обращение по имени поля через квадратные скобки, то нужно учитывать, что линтер может такую операцию посчитать неправильной потому что ключи объекта это набор литеральных типов, а в квадратные скобки передаётся строка, а не литеральный тип.

	способ решить проблему:

		const str = 'name' as string;

		const obj = {
		  name: 'Bobby Hadz',
		  country: 'Chile',
		};

		// error
		// console.log(obj[str]);

		// 👇️ "Bobby Hadz"
		console.log(obj[str as keyof typeof obj]);

	тут больше способов: https://bobbyhadz.com/blog/typescript-element-implicitly-has-any-type-expression

================================
extends для типов используется как псевдоним. то есть результирующий тип будет одним из тех, от которого он расширился. это может быть полезно при обобщении:

	function double<T extends number | string>(x: T): T;
	function double(x: any) { return x + x };

	здесь T это или number или string

================================
если здесь не будет указан тип Record<string, string>, то код выдаст ошибку:

	const obj: Record<string, string> = {
	  one: 'ooo',
	  two: 'ttt',
	  three: 'trrr',
	};

	for (const k in obj) {
	  let v = obj[k];
	  console.log(v);
	}

	причина её в том, что в цикле k имеет тип string, в то время как без Record<string, string> объект имел бы три конкретных ключа литерального типа.

второй способ решить проблему это назначить тип переменной цикла:

	const obj = {
	  one: 'ooo',
	  two: 'ttt',
	  three: 'trrr',
	};

	let k: keyof typeof obj;
	for (k in obj) {
	  let v = obj[k];
	  console.log(v);
	}

	здесь нельзя обойтись typeof obj потому что keyof работает только с типом, а не с переменной. typeof как раз переводит переменную с тип.


================================
номинальная и структурная типизация

	Структурная типизация это принцип, определяющий совместимость типов, основываясь на описании свойств.

		class Car {
		  id: number;
		  numberOfWheels: number;
		}

		class Boat {
		  id: number;
		}

		let test: Car = new Car(); // ok
		console.log(test); // {}

		let car: Car = new Boat(); // здесь TypeScript выдаст ошибку
		let boat: Boat = new Car(); // а на этой строчке все в порядке

		в этом примере мы перед присваиванием значения переменной проверяем тип этой переменной с типом присваиваемого значения. как видно, они имеют необходимый набор одинаковых объявлений. оишние объявления не приводят к ошибке, они просто игнорируются.

		-----------------------------

		class Car {
		  id: number;
		  numberOfWheels: number;

		  constructor() {
		    this.id = Math.random();
		  }
		}

		class Boat {
		  id: number;

		  constructor() {
		    this.id = Math.random();
		  }
		}

		function func1(obj:Boat) {
		  console.log('func1', obj.id);
		}
		func1(new Boat());  // ok
		func1(new Car());   // ok

		function func2(obj:Car) {
		  console.log('func1', obj.id);
		}
		func2(new Boat());  // error
		func2(new Car());   // ok

		в этом примере мы передаём различные типы в функцию, которая ожидает строго определённый тип. в результате видно, что функция может принимать переменные отличающихся типов, но которые имеют нужный набор свойств, в данном случае наличие id достаточно чтобы типы оказались совместимыми.



	Номинативная типизация это принцип, определяющий совместимость типов, основываясь на наследовании и интерфесах.

		в этом случае наличие одинаковых свойств не имеет значения. чтобы типы были совместимыми они должны быть объединены при помощи наследования или имплементации интерфейсов.


================================
можно использовать readonly для типа параметра функции:

	в этом случае объект, который передаётся в функцию как параметр не может быть мутирован в теле функции. анализатор подчёркнёт красным проблемный код, хотя сама мутация формально будет выполнена.

		function doubleScores(scores: readonly number[]) {
		  scores.forEach((score, i) => (scores[i] = score * 2)); // тут линтер подчеркнёт красным scores[i] 
		  return scores;
		}

		const billScores = [90, 65, 80];

		console.log(doubleScores(billScores))  	// [180, 130, 160]
		console.log(billScores);								// [180, 130, 160]


================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================