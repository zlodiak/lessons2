APP_INITIALIZER:

это возможность стартануть сервис перед началом работы модуля. таким образом из компонент можно сразу брать готовые данные, а не подписываться на них и ждать.

useFactory это функция внутри которой пинается метод сервиса.

deps передаёт аргумент в useFactory, то есть сервис, метод которого нужно пнуть.

обычно сервис создаётся таким образом чтобы его переменные содержали результат работы метода. иногда в виде subject

	function initUser(curSrv: CurService) {
	  return () => curSrv.init();
	}

	@NgModule({
	  imports: [
	  	.....
	  ],
	  providers: [
	    CurService,
	    {
	      provide: APP_INITIALIZER,
	      useFactory: initUser,
	      deps: [CurService],
	      multi: true
	    }
	  ],
	  declarations: [AppComponent],
	  bootstrap: [AppComponent],
	})
	export class AppModule {}

здесь важно, что CurService прописан не только в deps, но и в providers.

multi необходим для того чтобы многократно добавлять подобные конструкции, в том числе интерсепторы. важно понимать, что у каждого типа токена свой multi

=========================================================
map
 
этот оператор работает почти так же как обычный джаваскриптовый map. то есть берёт каждый элемент потока, преобразует его и возвращает тоже поток.
в джаваскриптовом map элементы результирующего массива можно получить при помощи синтаксиса квадратных скобок, а в реактивном map элементы результирующего потока можно получить при помощи синтаксиса .subscribe()
 
    const source = from([1,2,3,4,5,6,7]);
    const result = source.pipe(map(v => v+1));
    result.subscribe(v => console.log(v));
 
=========================================================
concatMap для обработки стримов по очереди;
mergeMap для обработки стримов параллельно;
switchMap если нужно отменять стримы, созданные ранее;
exhaustMap для игнорирования создания новых стримов, если текущий стрим ещё не был завершён;

=========================================================
кастомный провайдер позволяет вынести часть зависимостей за пределы компонента. 

например компонент делает запрос в зависимости от параметра роута. создадим отдельный файл:

	// это просто название, которое используется при инжектировании в конструкторе
	export const ORGANIZATION_INFO = new InjectionToken<Observable<Organization>>(
	   'A stream with current organization information',
	);

	// это название, котрое используется при инжектировании в массиве providers
	export const ORGANIZATION_PROVIDERS: Provider[] = [
	   {
	       provide: ORGANIZATION_INFO,
	       deps: [ActivatedRoute, OrService],
	       useFactory: organizationFactory,
	   },
	];

	// функционал провайдера. тут вся логика
	export function organizationFactory(
	   {params}: ActivatedRoute,
	   orService: OrService,
	): Observable<Organization> {
	   return params.pipe(
	       switchMap(params => {
	           const id = params.get('orgId');

	           return orService.getOrById$(id);
	       }),
	   );
	}


в компоненте применять так:

	@Component({
	   selector: 'or',
	   templateUrl: 'or.template.html',
	   styleUrls: ['or.style.less'],
	   changeDetection: ChangeDetectionStrategy.OnPush,
	   providers: [ORGANIZATION_PROVIDERS],
	})
	export class OrganizationComponent {
	   constructor(
	       @Inject(ORGANIZATION_INFO) readonly or$: Observable<Organization>,
	   ) {}
	}

в шаблоне применять так:

	<p *ngIf="or$ | async as or">
	   {{or.name}} from {{or.city}}
	</p>


=========================================================
провайдер это поставщик данных. почти такой же как сервис. 

но у сервиса название класс и токен, по котрому обращаются к сервису совпадает.

	@NgModule({
	    providers: [DeService]
	})

а у провайдера они могут различаться:

	providers: [
	  { provide: DeService, useClass: OtherService },		// имя токена, имя класса
	]
 
у провайдера есть дополнительная конфигурация:

	providers: [
	  {
	    provide: UserService,
	    useFactory: userServiceFactory,
	    deps: [AuthService],
	  },
	]

вот все варианты тела провайдера:

	- useClass - каждый раз при обращении к зависимости, указанной в provide, создается новый экземпляр класса, указанного в useClass;
	- useExisting - каждый раз при обращении к зависимости, указанной в provide, будет использоваться один и тот же экземпляр класса, указанного в useClass;
	- useValue - позволяет при обращении к зависимости, указанной в provide, использовать предопределенный объект;
	- useFactory и deps - эти свойства позволяют создавать переопределяющее значение динамически уже в процессе работы приложения.


@Inject

	constructor(private _uService: UserService) {}

	Она эквивалентна:

	constructor(@Inject(UserService) private _uService) {}

=========================================================
обнаружение изменений это сравнение значений в компоненте и в шаблоне. после срабатывания очередного цикла обнаружения изменений отображающиеся в шаблоне значения становятся актуальными. 

компоненты построены в виде дерева. когда в одном из родительских компонентов происходит событие, то процесс сравнивания значений в компоненте и в шаблоне стартует во всех дочерних компонентах. это называется dirty checking.

таким образом обдаружение изменений может быть запущено или событием в конкретном компоненте, или событием, спустившимся из вышестоящих компонентов.

можно включить стратегию onPush и изменения от вышестоящих компонентов будут обнаружиться только в случае передачи по ссылке нового значения. 

обнаружение изменений в текущем компоненте и спустившееся из родительского компонента можно отключить при помощи detach. в этом случае данные не спускаются в более нижние компоненты (вернее, спускаются, но не отображаются в шаблоне).

его можно включить при помощи reattach, но если родительский отключен, то это не будет иметь эффекта. markForCheck позволяет единоразово включить обнаружение изменений во всех вышестоящих компонентах.

detectChanges одноразово запускает обнаружение для текущего компонента и его потомков и его родителей. лучше не использовать по соображениям сохранения производительности.

обнаружение изменений распространияется вниз по дереву компонентов после того как произошло событие или изменились передаваемые данные.

его можно ограничить. например, если в дочернем компоненте установить стратегию onPush, то он будет реагировать только на поступающие через @Input значения или на всплывающие от более нижних компонентов события или на события происходящие в этом самом компоненте. при этом @Input значения должны изменяться по ссылке.

важно понимать, что при включенной стратегии onPush придётся вручную пинать цикл обнаружение события через detectChanges или через markForCheck после того как отработает асинхронная операция типа setTimeout, promise, http и т. д. если цикл не пинать, то сами свойства внутри класса изменятся, но не отобразятся в шаблоне.

даже, если иерархия компонентов не связана через передачу параметров при помощи синтаксиса квадратных скобок, то при стратегии default всё равно во всех компонентах срабатывает цикл обнаружения изменений. это называется dirty checking

=========================================================
CVA это преобразователь html-элемента в поле реактивной формы.

в первую очередь нужно создать компонент, в котором будут описаны правила и вид кастомного поля формы. затем прописать его в imports модуля. после этого в шаблоне родительского компонента использовать кастомный тег.

кастомный компонент будет реализовывать интерфейс NG_VALUE_ACCESSOR и, возможно, NG_VALIDATORS. важно понимать, что валидатор можно использовать или в кастомном компоннете или в родительском компоненте(стандартный или самописный). одновременно их использовать нельзя.

в кастомном компоненте определить свойство, которое с одной стороны будет связано с элементом формы, а сдругой с отображением кастомного элемента. связь (установка/синхронизация) осуществляется при помощи методов writeValue/onChanged соответственно.

при изменении значения нужно повесить обработчик в элемент шаблона поля. этот обработчик должен делать 2 вещи: 1. изменять локальную переменную, 2. пинать onChange() чтобы информация о новом значении всплывала в объект формы.

validate срабатывает каждый раз когда меняется значение поля в шаблоне. если с валидацией всё ок, то он возвращает null, иначе произвольный объект (этот объект помещается в объект формы, в errors конкретного поля).

	@Component({
	  selector: 'hello',
	  template: `
	    <button (click)="minus()">minus</button>
	    <button (click)="plus()">plus</button>
	    {{ value }}
	  `,
	  providers: [
	    {
	      provide: NG_VALUE_ACCESSOR,
	      useExisting: forwardRef(() => HelloComponent),
	      multi: true,
	    },
	    {
	      provide: NG_VALIDATORS,
	      useExisting: forwardRef(() => HelloComponent),
	      multi: true,
	    },
	  ],
	})
	export class HelloComponent implements ControlValueAccessor, Validator {
	  value: number;

	  validate() {
	    return this.value > 0 ? null : { positive: true };
	  }

	  onChange: any = () => {};
	  onTouch: any = () => {};

	  registerOnChange(fn: any) {
	    this.onChange = fn;
	  }

	  registerOnTouched(fn: any) {
	    this.onTouch = fn;
	  }

	  writeValue(input: number) {
	    this.value = input;
	  }

	  minus() {
	    this.value -= 1;
	    this.onChange(this.value);
	  }

	  plus() {
	    this.value += 1;
	    this.onChange(this.value);
	  }
	}



в родителе:

    this.form = this.fb.group({
      name: [null, [Validators.required]],
      email: [null, [Validators.required, Validators.email]],
      buttons: [2],
      input: [null, [Validators.pattern('^asd$')]],
    });

тут больше:
https://stackblitz.com/edit/angular-ivy-iecnm4?file=src/app/hello.component.ts


=========================================================
CVA validation

вешать валидаторы на cva-поле можно двумя способами:

	1. в родительском компоненте как обычный кастомный валидатор

		export class AppComponent {
		  myForm: FormGroup = new FormGroup({
		    login: new FormControl(null, Validators.required),
		    name: new FormControl(null, Validators.required),
		    isAdmin: new FormControl(false, this.ValidateAdmin),
		  });

		  ValidateAdmin(control: AbstractControl) {
		    if (control.value === false) {
		      return { ValidateAdminError: true };
		    }
		    return null;
		  }
		}	

	2. внутри cva-компонента. в этом случае при любом изменении срабатывает метод validate. он как и кастомный валидатор должен вернуть или null, или объект с ключом ошибки.

	  validate({ value }: FormControl) {
	    if (!value) {
	      return {
	        invalid: true,
	      };
	    }

	    return null;
	  }	

	в этом случае нужно не забыть прописать провайдер:

	    {
	      provide: NG_VALIDATORS,
	      useExisting: HelloComponent,
	      multi: true,
	    },	

	в шаблоне проверять валидацию так:

		*ngIf="myForm.get('isAdmin').hasError('invalid')"


    тут больше:
    https://stackblitz.com/edit/angular-ivy-sgaslf?file=src/app/hello.component.ts


setDisabledState() срабатывает каждый раз когда из родителя поле делаю disabled/enabled. в этот обработчик можно поместить полезное действие, например, чтобы cva-поле дизейблилось изнутри(извне его задизейблить не получится)

=========================================================
template-driven forms

чтобы создать шаблонную форму нужно в компоненте определить объект с полями формы:

  form = {
    name: '',
    position: '',
  };

  submit() {
    console.log(this.form);
  }

затем в шаблоне прописать элементы этого объекта при помощи специального синтаксиса:

  <div>
    <input
      type="text"
      [(ngModel)]="form.name"
      name="name"
      #name="ngModel"
      required
    />
    <ng-container *ngIf="name.touched && name.invalid">
      name error
    </ng-container>
  </div>

  <div>
    <input
      type="text"
      [(ngModel)]="form.position"
      name="position"
      appPositionValidator
      #position="ngModel"
    />
    <ng-container *ngIf="position.touched && position.invalid">
      position error
    </ng-container>
  </div>


как видите, валидация осуществояется или при помощи встроенных атрибутов required/pattern или при помощи директивы, если требуется кастомная валидация:

	@Directive({
	  selector: '[appPositionValidator]',
	  providers: [
	    {
	      provide: NG_VALIDATORS,
	      useClass: PositionValidatorDirective,
	      multi: true,
	    },
	  ],
	})
	export class PositionValidatorDirective {
	  validator: ValidatorFn;

	  constructor() {
	    this.validator = this.positionValidator();
	  }

	  validate(c: FormControl) {
	    return this.validator(c);
	  }

	  positionValidator(): ValidatorFn {
	    return (control: FormControl) => {
	      if (control.value !== 'boss') {
	        return {
	          positionValidatorError: true,
	        };
	      }

	      return null;
	    };
	  }
	}


тут больше:
https://stackblitz.com/edit/angular-ivy-gqy6hs?file=src/app/position-validator.directive.ts


=========================================================
viewChild(ren)

viewChild это декоратор, который позволяет обращаться к свойствам компонентов/директив, которые были встроены в шаблон. а так же к провайдерам, сервисам встроенных компонентов. 

в качестве встроенных компонентов могут рассматриваться обычные html элементы такие как span.

viewChildren возвращает то же самое но в виде queryList, по кторому нужно ходить при помощи toArray().foreach()

параметр read позволяет обращаться к токену провайдера:

	@Component({
	  selector: 'first-child',
	  providers: [
	    SampleService,
	    { provide: 'TokenA', useValue: 'valueA' },
	    { provide: 'TokenB', useValue: 123 },
	    { provide: ExampleServiceToken, useExisting: SampleService },
	    { provide: 'TokenC', useValue: true }
	  ]
	})

	export class FirstChildComponent{}

	@Component({
	  selector: 'parent',
	  template: `<first-child></first-child>`
	})

	export class ParentComponent{
	  @ViewChild(FirstChildComponent, { read: 'TokenA' }) dependencyA: string;
	  @ViewChild(FirstChildComponent, { read: 'TokenB' }) dependencyB: number;
	  @ViewChild(FirstChildComponent, { read: 'TokenC' }) dependencyC: boolean;
	  @ViewChild(FirstChildComponent, { read: SampleService }) sampleService: SampleService;
	  @ViewChild(FirstChildComponent, { read: ElementRef }) fcElementRef: ElementRef;
	  @ViewChild(FirstChildComponent, { read: FirstChildComponent }) fcComponent: FirstChildComponent;
	  @ViewChild(FirstChildComponent, { read: ExampleServiceToken }) exampleService: SampleService;
	}

свойство static определяет в какой момент будут считываться viewChild (до отрисовки шаблона компанента или после. это событие ngAfterViewInit)


декорировать можно импортированные элементы или помеченные в шаблоне при помощи #.


https://dev-gang.ru/article/ponimanie-dekoratorov-viewchild-i-viewchildren-v-angular--bpb46hqf3i/

----------------
@Component({
  selector: 'my-app',
  template: `
    <hello></hello>
    <p #p>Start</p>
  `,
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  @ViewChild(HelloComponent)
  hello: HelloComponent;

  @ViewChild('p')
  p: ElementRef;

  ngOnInit() {
    console.log('ngOnInit', this.hello);		// undefined
    console.log('ngOnInit', this.p);			// undefined
  }

  ngAfterViewInit() {
    console.log('ngAfterViewInit', this.hello.greetings);	// hello i am hello comp
    console.log('ngAfterViewInit', this.p);					// *nativeElement*
  }
}


@Component({
  selector: 'hello',
  template: `<h1>Hello</h1>`,
  styles: [`h1 { font-family: Lato; }`],
})
export class HelloComponent {
  public greetings = 'i am hello comp';
}


----------------


contenChild(ren)

этот декоратор используется в дочернем элементе для доступа к элементу, которые пришёл из родительского элемента и был вставлен при помощи ng-content

	родитель:

		@Component({
	    selector: 'my-app',
	    template: `<child-comp>
	                    <h3 #headerContent>Добро пожаловать {{name}}!</h3>
	               </child-comp>`
		})

	дочерний компонент:

		@Component({
		    selector: 'child-comp',
		    template: `<ng-content></ng-content>
		               <button (click)="change()">Изменить</button>`
		})
		export class ChildComponent{ 
		      
		    @ContentChild("headerContent", {static:false})
		    header: ElementRef|undefined;	

		}


=========================================================
rxjs common operators

все операторы принимают поток, меняют его внутренности и возвращают изменённый поток чтобы потом можно было на него подписаться при помощи subscribe.

map:
	преобразует каждый элемент последовательности по определённому правилу.

concat:
	объединяет потоки последовательно. то есть по мере их регистрации, ане по мере выполнения.

merge:
	объединяет потоки по мере их выполнения. последовательность регистрации значения не имеет.

mergeAll:
	если существует поток, элементами которого являются другие потоки, то этот оператор подписывается на каждый внутренний поток, получает его результат и возвращает только внешний поток, содержащий уже не потоки, а результаты. 

	таким образом этот оператор уменьшает вложенность потоков. порядок результатов внутри потока зависит от порядка в котором разрешилась подписка.

concatAll:
	 делает то же самое, но порядок результатов в потоке зависит от регистрации, а не от скорости разрешения подписок.

mergeMap:
	позволяет избежать подписки в подписке. для каждого элемента потока он создаёт новый поток, разрешает его и получает результат. таким образом на выходе получает поток, который содержит набор результатов. на него теперь нужно подписаться только один раз.

	порядок результатов в финальном потоке зависит от того в какой последовательности разрешались внутренние потоки.

concatMap:
	делает то же самое, но активна всегда только одна подписка. пока она не разрешится не произойдёт следующей подписки. таким образом поледовательно выполнятся все подписки

switchMap:
	похож на mergeMap, но при появлении нового потока внутри основного потока отменяет выполняющиеся в данный момент потоки. таким образом актуален всегда только последний внутренний поток.

exhaustMap:
	то же самое, но делает актуальным только первый поток, а запустившиеся позже отключает.


=========================================================
custom pipe. это функция, которая принимает поток, изменяет его и возвращает поток.

создать пользовательский оператор можно двумя способами:
	1. с использованием pipe второго уровня,
	2. полностью создав новый поток с тремя коллбеками.


1:
	export function hmm(n: number) {
	  console.log(n);
	  return <T>(source$: Observable<T>) => {
	    return source$.pipe(tap(console.log, console.error));
	  };
	}
	 
	const source = of('World').pipe(
	  map((x) => `Hello ${x}!`),
	  hmm(111)
	);
	 
	source.subscribe();


	видно, что hmm это просто функция-обёртка, которая возвращает сам оператор. этото оператор подобен map(x => x + 1). разница только в том, что он принимает поток и обрабатывает его стандартным pipe(tap()).

	при желании в функцию обёртку можно передать аргумент n. в данном примере он передаётся, но не используется.

2:
	function custom() {
	  return (src) => {
	    return new Observable((sub) => {
	      return src.subscribe({
	        next(value) {
	          sub.next(value + '_extra');
	        },
	        error(error) {
	          console.log(error);
	        },
	        complete() {
	          console.log('complete');
	        },
	      });
	    });
	  };
	}

	const obs$ = of(1, 2, 3, 4, 5);

	obs$
	  .pipe(
	    map((x) => x + '___addition'),
	    custom()
	  )
	  .subscribe(console.log);


	  видно, что новый оператор представляет из себя обёртку над new Observable(), в котором происходит: подписка, изменение и next изменённого значения.

=========================================================
ng-container и ng-template это обёртки. их теги не существуют в DOM, но содержимое первого отображается всегда, а содержимое второго отображается только в результате использования структурных директив.

	<!-- hide -->
	<ng-template #qwerty>qwerty</ng-template>
	 
	<!-- show -->
	<div *ngIf="true; else qwerty">zzz</div>
	 
	<!-- show -->
	<ng-container>xxxxx</ng-container>



ngTemplateOutlet это слот для вставки ng-template. если этот слот видим, то вставка производится, если нет, то не производится. 

ngTemplateOutlet можно использовать на странице несколько раз.


	<ng-template #detail> 123 </ng-template>
	 
	<div class="outer">
	  Outer Box
	  <div [ngTemplateOutlet]="detail" *ngIf="outside"></div>
	  <div class="inner">
	    inner box
	    <div [ngTemplateOutlet]="detail" *ngIf="!outside"></div>
	  </div>
	</div>
	 
	<button (click)="outside = !outside">
	  Move {{ outside ? 'inside' : 'outside' }}
	</button>

=========================================================
через ng-content можно передавать отдельный части разметки и отображать их соответственно в разных целевых контейнерах.

	<app-child>
	  <div header>This should be rendered in header selection of ng-content</div>
	  <div body>This should be rendered in body selection of ng-content</div>
	</app-child>


	<div class="header-css-class">
	  <h4>Header</h4>
	  <ng-content select="[header]"></ng-content>
	</div>
	<div class="body-css-class">
	  <h4>Body</h4>
	  <ng-content select="[body]"></ng-content>
	</div>

=========================================================
pipes pure & pipes impure

	по умолчанию пайпы чистые. то есть они реагируют только на изменение ссылки, но не внутренностей объекта.

	если в декораторе пайпа прописать pure: false, то пайп будет реагировать на изменение внутренностей передаваемого объекта. это опасно с точки зрения производительности.

=========================================================
trackBy

	используется при циклическом выводе элементов в шаблоне. проблема в том, что если мы отрисовали при помощи *ngFor 4 элемента, а затем по событию добавили в середину новый элемент, то в DOM будут перерисованы все элементы.

	но если мы используем trackBy, который принимает index и object, а возваращает какую-нибудь уникальную строку, то в DOM будет перерисован только новый элемент и те, которые ниже него.

=========================================================
инжектор сервисов 

	это фабоика, которая отдаёт объекты сервисов. существует 3 уровная: глобальный уровень, уровень модуля, уровень компонента.

	если существует один сервис и два компонента ижектируют его отдельн на уровне компонета, то инжектор создас 2 экземляра сервиса, каждый из которых будет независим. то есть содержать свой уникальный набор данных.

	если сервис обхявлен на уровне модуля, то каждый компонент этого модуля получает один и тот же экземпляр сервиса (синглтон). то есть будет работать с одними тем же набором данных.

=========================================================
catchError позволяет вместо в случае возникновения ошибки подменить результат новым observable продолжить выполнение, тем самым позволить сработать коллбеку успешной операции. при этом коллбек ошибки не сработает.

если catchError не вернёт observable, то сработает коллбек ошибки в блоке подписки.

  public ngOnInit() {
    this.http
      .get('data.json')
      .pipe(
        tap(() => console.log('start...')),
        catchError((error) => {
          console.log('error!!!', error);
          return of([1, 2, 3]);					// shape new result for success callback
        })
      )
      .subscribe(
        (data) => console.log('OK', data),		// success
        (err) => console.log('err', err)		// error
      );
  }


=========================================================
IVY

	это механизм, который преобразует компоненты и шаблоны в чистый HTML и javaScript.

=========================================================
interceptor это просто сервис, который срабатывает при отправке запроса. он может изменить исходящие данные и изменить получаемые данные:

	export class InterService implements HttpInterceptor {
	  constructor() {}

	  intercept(
	    req: HttpRequest<any>,
	    next: HttpHandler
	  ): Observable<HttpEvent<any>> {
	    const authReq = req.clone({
	      headers: req.headers.set('Session', '123456789'), // добавить заголовок при отправке запроса
	    });

	    return next.handle(authReq).pipe(
	      map((event) => {
	        // изменить id в полученном результате
	        event['body'] = event['body']?.map((x) => {
	          const newR = x;
	          newR.id = newR.id * 10;
	          return newR;
	        });
	        return event;
	      }),
	      tap((event) => {
	        if (event instanceof HttpResponse)
	          console.log('Server response', event);
	      })
	    );
	  }
	}


а встраивается он в модуль так же как другие сервисы тоесть через массив providers.

	providers: [
	    {
	      provide: HTTP_INTERCEPTORS,
	      useClass: InterService,
	      multi: true,
	    },
	  ],

=========================================================
ExpressionChangedAfterItHasBeenCheckedError выводится только в dev режиме.

переменные в компоненте и вывод их в шаблоне связаны. change detection актуализирует эту связь. но бывает так, что после того как CD отработал переменная в компоненте меняется, при этом соответствующее значение в шаблоне не обновляется. в этом случае dev режим извещает об этом разработчика при помощи ExpressionChangedAfterItHasBeenCheckedError, запуская дайджест цикл ещё раз после того как CD отработает. но prod режим не этого не делает.

чтобы избежать этой ошибки нужно после того как отработает CD инициировать событие(например при помощи setTimeout) или запустить changeDetection().

	export class AppComponent {
	  name = 'I am a component with Ivy 🍃';
	  text = 'A message for the child component';
	  @ViewChild(ChildComponent) childComponent: ChildComponent;

	  constructor(private cdRef: ChangeDetectorRef) {}

	  ngAfterViewInit() {
	    this.childComponent.input = 'Changed Name';

	    // this.cdRef.detectChanges();

	    // setTimeout(() => {
	    //   this.childComponent.input = 'Changed Name';
	    // });
	  }
	}


	@Component({
	  selector: "hello",
	  template: `
	    <h1>Hello {{ input }}!</h1>
	  `,
	})
	export class ChildComponent {
	  @Input() input: string;
	}

тут живой пример: https://stackblitz.com/edit/expressionchangedafterithasbeencheckederror-ivy-byszyj?file=src/app/child.component.ts

=========================================================
hostDirectives это альтернативный способ привязать директиву к компоненту. раньше необходимо ьыло прописывать директиву в виде атрибута

	<a-comp dir></a-comp>

но сейчас возможно это делать в декораторе компонента:

	@Component({
	  selector: 'admin-menu',
	  template: 'admin-menu.html',
	  hostDirectives: [MenuBehavior],
	})
	export class AdminMenu { }

при этом отпадает необходимость в лишнем звене @Input\@Output при передаче параметров. 

Так же есть возможность реализовать наследование в директивах, если в декораторе директивы тоже использовать hostDirectives.

важно помнить, что хуки жизненного цикла сначала выполняются в директивах и только потом в использующих их компонетнах.


=========================================================
NgOptimizedImage позволяет оптимизировать загрузку изображений. при этом является просто надстройкой над обычным heml-элементов img.

	1. при подключении в модуль позволяет указать несколько CDN-поставщиков через providers. при этом в в атрибуте rawSrc не требуется указывать полный путь к поставщику, а только конечную его часть. 

		<img rawSrc="1-4000x3000_ag.jpg" />

	2. чтобы при после завершения загрузки картинки экран не дёргался можно сразу указать ширину и высоту. по сути в нативном img делается то же самое
		
		<img [rawSrc]="img.url"  width="4000" height="3000"/>

	3. в консоли будет предупреждение, если html не содержит <link rel="preconnect" href="https://ik.imagekit.io">

	4. браузер сам подбирает разные размеры изображения в зависимости от размера экрана, это нативная способность. использование rawSrcset позволяет сократить запись
		
		<img [rawSrc]="img.url" rawSrcset="200w, 400w, 600w, 800w, 1000w" />

	 5. при помощи priority можно пометить наиболее приоритетную картинуц. это дублирование нативного функционала img-элемента.

		<img [rawSrc]="img.url" priority />

=========================================================
angular 15: что нового

	1. hostDirectives

		появились директивы, привязанные к компоненту. при этом директивы можно наследовать

	2. NgOptimizedImage 

		появилась директива для оптимизации загрузки изображений

	3. появилась солкращённая запись guards (без класса, реализующего интерфейс и возвращающего true/false):

		const route = {
		  path: 'admin',
		  canActivate: [() => inject(LoginService).isLoggedIn()]
		};  

	4. упростилась запись ленивой загрузкт в роутере (теперь не нужно указывать конкретный компонент, он сам будет найден на основе пути к файлу)

		{
		  path: 'lazy',
		  loadComponent: () => import('./lazy-file'),
		}  

	5. улучшенные сообщения об ошибках в консоли, которые, в частности, игнорируют сообщения от сторонних библиотек.

	6. общий рефакторинг кода реймворка

=========================================================
новое в angular15:

	1. возможность использовать автономные компоненты стала частью стабильной версии, а не предварительной.

	2. возможность построить роутинг на основе автономных компонентов

	3. возможность привязать директиву к компоненту через hostDirectives

	4. директива для оптимизации изображений стала стабильной. она позволяет сократить время загрузки изображений и дёргание экрана при загрузке изображения. также можно использовать режим заполнения родительского контейнера изображением.

	5. возможность более лаконично записывать гарды в маршрутизаторе

	6. возможность более лаконично записывать ленивый роутинг для автономных компонентов

	7. вывод ошибок консоли теперь не содержит ошибок от сторонних модулей

	8. был произведён рефакторинг material компонентов

	9. стало возможным генерировать через CLI автономные компоненты, директивы, пайпы

=========================================================
angular elements это npm-пакет, который позволяет отдельные angular-компоненты: 

	1. запаковывать
	2. импортировать результирующие js/css файлы в любую среду
	3. в любой среде использовать кастомный тег типа <my-tag></my-tag>

	на такой тег в среде HTML можно повесить addEventListener, который будет слушать событие, которое генерировано angular-компонентом при помощи emit(). кроме того, такой тего может принимать значения, передаваемые через атрибут при помощи @Input.

=========================================================
динамические компоненты это компоненты, кторые создаются в рантайме. Например тултипы, модальные окна и т.д.

с 13 версии ДК создаются без использования componentFactoryResolver.

	export class AppComponent {
	  @ViewChild('dynamic', { read: ViewContainerRef })
	  private viewRef: ViewContainerRef;

	  showDynamicComponent(): void {
	    this.viewRef.clear();
	    this.viewRef.createComponent(DynamicComponent);
	  }

	  removeDynamicComponent(): void {
	    this.viewRef.clear();
	  }
	}

то есть нужно просто получить элемент и выполнить на нём createComponent()

=========================================================
<base href="/"> 

	служит для того чтобы быть префиксом перед относительными ссылками.

=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
========================================================