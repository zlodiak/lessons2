=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
повышение версии по одной:

	ng update @angular/core@18 @angular/cli@18


=========================================================
@Injectable

	этим декоратором необходимо пометить классы, которые могут быть инжектированы в другие классы. 

	многие декораторы типа @NgModule, @Directive являются потомками @Injectable. поэтому для них не нужно явно прописывать @Injectable

	@Injectable({  
	   providedIn: 'root'
	})	
	// сервис является синглтоном для жадных и ленивых модулей


	@Injectable({  
	   providedIn: 'any'
	})	
	// сервис является не синглтоном, для ленивых модулей. и является синглтоном для жадных модулей. deprecated

	@Injectable({  
	   providedIn: 'platform'
	})	
	// сервис является синглтоном для нескольких ангуляр-приложений
	на этом уровне содержатся общие для всех приложений сервисы, например DomSanitizer etc.

		import { DomSanitizer } from '@angular/platform-browser'
		constructor(private _renderer: Renderer,private sanitizer:DomSanitizer){
			let htm = this.sanitizer.bypassSecurityTrustHtml(this.html);
		}




	@Injectable({  
	   providedIn: null
	})	
	// не добавляется в инжектор. поэтому, если сервис нужен, то должен быть явно добавлен в массив провайдеров.

	@Injectable({  
	   providedIn: module_name
	})		
	// будет синглтоном для указанного модуля

=========================================================
@Inject

	это декоратор, который используется в конструкторе класса. с помощью него инжектируются зависимости по названию токена. по сути его обычно заменяют синтаксическим сахаром:

		constructor(private chatWidget: ChatWidget) { }

	но на самом деле инжектировать нужно так:

		constructor(@Inject(ChatWidget) private chatWidget) { }


=========================================================
angular 

	это клиентсикй фреймворк для создания одностраничных приложений. он предоставляет возможность обновлять страницу при помощи AJAX запросов на сервер, а так же возможности роутинга и компонентную структуру.

	компоненты выстроены в форме дерева,в этом дереве действиет механизм обнаружения изменений.

	использует TS, rxjs. существует возможность добавления сторонних модулей таких как ngrx, primeNG.



=========================================================

APP_INITIALIZER:

	это возможность стартануть сервис перед началом работы модуля. таким образом из сервисов можно сразу брать готовые данные, а не подписываться на них и ждать. 

	APP_INITIALIZER будет подгружать тяжёоые данные для определённой страницы пока пользователь ходит по другим страницам. Но, если пользователь загружает тяжёлую страницу по прямой ссылке, то ждать всё равно придётся. в этом случае разумно реализовать спиннер.

	useFactory это функция внутри которой пинается метод сервиса.

	deps передаёт аргумент в useFactory, то есть сервис, метод которого нужно пнуть.

	обычно сервис создаётся таким образом чтобы его переменные содержали результат работы метода. иногда в виде subject

		export class ContactsService {

		  private contacts$ = new BehaviorSubject<string>('');

		  constructor() {
		    this.init();
		  }

		  init(){
		    of('contacts contacts contacts ')
		      .pipe(delay(2000))
		      .subscribe(d => {
		        this.contacts$.next(d)
		      });
		  }

		  getContacts() {
		    return this.contacts$.asObservable();
		  }
		}

	в модуле прописывается следующее:

		function initContacts(service: ContactsService) {
		  return () => service.init();
		}

		@NgModule({
		  declarations: [...],
		  imports: [...],
		  providers: [
		    ContactsService,
		    {
		      provide: APP_INITIALIZER,
		      useFactory: initContacts,
		      deps: [ContactsService],
		      multi: true
		    }
		  ],
		  bootstrap: [...]
		})
		export class AppModule { }	

	здесь важно, что ContactsService прописан не только в deps, но и в providers.

	multi необходим для того чтобы многократно добавлять подобные конструкции, в том числе интерсепторы. важно понимать, что у каждого типа токена свой multi

	шаблон со спиннером может выглядеть так:

		<strong *ngIf="(contacts.getContacts() | async) as data else loading">
		    <div *ngIf="data">{{ data }}</div>
		</strong>

		<ng-template #loading>loading...</ng-template>


	если метод service.init() возвращает promise/observable, то приложение стартанёт сразу, но при заходе на определённый роут будет виден спиннер или пустая страница до тех пор пока этот promise/observable не разрешится. 

	но это поведение можно изменить на такое: пока не загрузятся вообще все данные из всех сервисов, то показывать спиннер для ВСЕГО приложения в КОРНЕВОМ шаблоне. возможно, для этого придётся объединять потоки при помощи forkJoin.

	прочая информация тут:

		https://upmostly.com/angular/using-the-app_initializer-token-to-bootstrap-your-application

=========================================================
map
 
	этот оператор работает почти так же как обычный джаваскриптовый map. то есть берёт каждый элемент потока, преобразует его и возвращает тоже поток.
	в джаваскриптовом map элементы результирующего массива можно получить при помощи синтаксиса квадратных скобок, а в реактивном map элементы результирующего потока можно получить при помощи синтаксиса .subscribe()
	 
	    const source = from([1,2,3,4,5,6,7]);
	    const result = source.pipe(map(v => v+1));
	    result.subscribe(v => console.log(v));
 
=========================================================
concatMap для обработки стримов по очереди;
mergeMap для обработки стримов параллельно;
switchMap если нужно отменять стримы, созданные ранее;
exhaustMap для игнорирования создания новых стримов, если текущий стрим ещё не был завершён;

=========================================================
custom providers

	позволяет вынести часть зависимостей за пределы компонента. 

	например компонент делает запрос в зависимости от параметра роута. создадим отдельный файл:

		// это просто название, которое используется при регистрации в первом агрументе кастомного провайдера и в конструкторе при инжектировании
		export const ORGANIZATION_INFO = new InjectionToken<Observable<Organization>>(
		   'A stream with current organization information',
		);

		// это название, котрое используется при регистрации в массиве providers
		export const ORGANIZATION_PROVIDERS: Provider[] = [
		   {
		       provide: ORGANIZATION_INFO,
		       deps: [ActivatedRoute, OrService],
		       useFactory: organizationFactory,
		   },
		];

		// функционал провайдера. тут вся логика
		export function organizationFactory(
		   {params}: ActivatedRoute,
		   orService: OrService,
		): Observable<Organization> {
		   return params.pipe(
		       switchMap(params => {
		           const id = params.get('orgId');

		           return orService.getOrById$(id);
		       }),
		   );
		}


	в компоненте применять так:

		@Component({
		   selector: 'or',
		   templateUrl: 'or.template.html',
		   styleUrls: ['or.style.less'],
		   changeDetection: ChangeDetectionStrategy.OnPush,
		   providers: [ORGANIZATION_PROVIDERS],
		})
		export class OrganizationComponent {
		   constructor(
		       @Inject(ORGANIZATION_INFO) readonly or$: Observable<Organization>,
		   ) {}
		}

	в шаблоне применять так:

		<p *ngIf="or$ | async as or">
		   {{or.name}} from {{or.city}}
		</p>


=========================================================
частный провайдер это поставщик данных. почти такой же как сервис. 

	но у сервиса название класса и токен, по котрому обращаются к сервису совпадает.

		@NgModule({
		    providers: [DeService]
		})

	а у провайдера они могут различаться:

		providers: [
		  { provide: DeService, useClass: OtherService },		// имя токена, имя класса
		]
	 
	у провайдера есть дополнительная конфигурация:

		providers: [
		  {
		    provide: UserService,
		    useFactory: userServiceFactory,
		    deps: [AuthService],
		  },
		]

	вот все варианты тела провайдера:

		- useClass - каждый раз при обращении к зависимости, указанной в provide, создается новый экземпляр класса, указанного в useClass;
		- useExisting - каждый раз при обращении к зависимости, указанной в provide, будет использоваться один и тот же экземпляр класса;
		- useValue - позволяет при обращении к зависимости, указанной в provide, использовать предопределенный объект;
		- useFactory и deps - эти свойства позволяют создавать предопределенный объект динамически уже в процессе работы приложения, на сонове полученных динамических значений.


	@Inject

		constructor(private _uService: UserService) {}

		Она эквивалентна:

		constructor(@Inject(UserService) private _uService) {}

		она эквивалента:

		const service = inject(HelloService);

		пример выше показывает как можно обойтись вообще без конструктора(поюс этого подхода в том, что при наследовании не нужно пробрасывать из дочернего компонента зависимости родительского конструктора).

			@Injectable()
			abstract class Storage {
			  private logger = inject(Logger);
			}

			@Injectable()
			class LocalStorage extends Storage {
			  constructor(private selfDependency: SelfDepService){
			    super();
			  }
			}	

		второе преимущество в том, что не обязательно при таком виде инжектирования указывать тип. этот тип уже указан в new InjectionToken поэтому повторение излишне:


			const TOKEN = new InjectionToken<string>('token');

			@Component({
			    // component metadata
			})
			export class AppComponent {
			    private token = inject(TOKEN);
			    // type "string" is inferred
			}		

		третье преимущество в том, что зависимость можно шарить между несколькими компонентами вместо того чтобы в конструкторе каждого компонента прописывать эту зависимость:

			function getRouteParam(paramName: string): string {
			  const route = inject(ActivatedRoute);
			  return route.snapshot.paramMap.get(paramName);
			}

			@Component({
			  selector: 'app-root',
			    template: `
			        <h1>Route param: {{ id }}</h1>
			    `,
			})
			export class AppComponent {
			  id = getRouteParam('id');
			}		

	есть возможность зарегистрировать частный провайдер в декораторе @Injectable. то есть в нём тоже можно использовать useClass/useExisting/useValue/useFactory. преимущество этого способа заключается в том, что включается treeShaking.


	-----------------------

	есть возможность подменить один сервис другим, но для этого необходимо чтобы оба сервиса были заимпортированы.

	допустим, существуют два сервиса: OldServiceService, SitesService который реализуют интерфейс getValues(). подмена происходит в блоке providers на уровне компонента:

		@Component({
		  selector: 'my-app',
		  // providers: [OldServiceService],
		  providers: [{ provide: OldServiceService, useExisting: SitesService }],
		})
		export class AppComponent implements OnInit {
		  constructor(public data: OldServiceService) {}

		  ngOnInit() {
		    console.log(this.data.getValues());
		  }
		}	

	важно понимать, что происходит не замена, а всего лишь создание псевдонима. то есть по токену, которые совпадает с названием класса сервиса доступ остаётся:

		@Component({
		  selector: 'my-app',
		  template: ``,
		  providers: [
		    { provide: 'DDD', useClass: SitesService },
		    OldServiceService,
		    SitesService,
		  ],
		})
		export class AppComponent implements OnInit {
		  constructor(
		    @Inject('DDD') public ddd: SitesService,
		    public old: OldServiceService,
		    public sites: SitesService
		  ) {}

		  ngOnInit() {
		    console.log(this.ddd.getValues());		// 123
		    console.log(this.old.getValues());		// 777
		    console.log(this.sites.getValues());	// 123
		  }
		}	

		тут больше: https://stackblitz.com/edit/reactive-dumb-components-qupk4k?file=src%2Fapp%2Fapp.component.ts

	---------------------------

	текстовый токен может быть заменён на уникально сгенерированный. результат будет тот же:

		@Component({
		  selector: 'my-app',
		  template: ``,
		  providers: [
		    { provide: DATA, useClass: SitesService },
		    OldServiceService,
		    SitesService,
		  ],
		})
		export class AppComponent implements OnInit {
		  constructor(
		    @Inject(DATA) public ddd: SitesService,
		    public old: OldServiceService,
		    public sites: SitesService
		  ) {}

		  ngOnInit() {
		    console.log(this.ddd.getValues());
		    console.log(this.old.getValues());
		    console.log(this.sites.getValues());
		  }
		}


=========================================================
InjectionToken

	можно использовать для создания алиаса сервиса, который будет инжектироваться потом через конструктор

	в отдельном файле создаём токен, который привязан к объекту:

		export const DATA = new InjectionToken<Record<string, number>>('MyObj', {
		  factory: () => {
		    return {
		      a: 111,
		      b: 222,
		    };
		  },
		});

	теперь можно его инжектировать в компоненте. при этом не обызательно регистрировать в массиве providers(потому что есть заполненный второй аргумент):

		export class AppComponent implements OnInit {
		  constructor(@Inject(DATA) public readonly data: Record<string, number>) {}
		  ngOnInit() {
		    console.log(this.data);
		  }
		}

	существует 3 вида токена:

		1. type token - когда название токена совпадает с именем класса сервиса
		2. string token - просто идентификатор в виде строки
		3. injection token - сгненерированный при помощи new уникальный токен(строка, которая передаётся аргументом не обязана быть уникальной, она выводится только в случае ошибки)

		пример string token:

			@NgModule({
			  imports: [BrowserModule, FormsModule],
			  declarations: [AppComponent, HelloComponent],
			  bootstrap: [AppComponent],
			  providers: [
			    { provide: 'APIURL', useValue: 'http://SomeEndPoint.com/api' },
			  ]
			})
			export class AppModule {}

			@Component({
			  selector: 'my-app',
			  templateUrl: './app.component.html',
			  providers: [],
			})
			export class AppComponent {
			  products: Product[];

			  constructor(
			    @Inject('APIURL') public ApiUrl: String,
			  ) {
			    console.log(ApiUrl);
			  }

			  getProducts() {
			    this.products = this.productService.getProducts();
			  }
			}

			демо: https://stackblitz.com/edit/angular-injection-token-string-token-example1-vmt99ska?file=src%2Fapp%2Fapp.component.ts


=========================================================
что такое шаблонная переменная?

	это помеченный # элемент в шаблоне. на который можно ссылаться из шаблона же:

		<input type="text" [(ngModel)]="name" #username />
		<p>{{username.value}}</p>

	и из компонента:

		<div #editor id="jsoneditor">

		@ViewChild('editor') 
		editor: ElementRef;
		this.editor.nativeElement.innerHTML  = 'qwerty';

=========================================================
ng-container и ng-template это обёртки. их теги не существуют в DOM, но содержимое первого отображается всегда, а содержимое второго отображается только в результате использования структурных директив.

	<!-- hide -->
	<ng-template #qwerty>qwerty</ng-template>
	 
	<!-- show -->
	<div *ngIf="true; else qwerty">zzz</div>
	 
	<!-- show -->
	<ng-container>xxxxx</ng-container>



ngTemplateOutlet это слот для вставки ng-template. если этот слот видим, то вставка производится, если нет, то не производится. 

ngTemplateOutlet можно использовать на странице несколько раз.


	<ng-template #detail> 123 </ng-template>
	 
	<div class="outer">
	  Outer Box
	  <div [ngTemplateOutlet]="detail" *ngIf="outside"></div>
	  <div class="inner">
	    inner box
	    <div [ngTemplateOutlet]="detail" *ngIf="!outside"></div>
	  </div>
	</div>
	 
	<button (click)="outside = !outside">
	  Move {{ outside ? 'inside' : 'outside' }}
	</button>

	пример передачи контекста:

		<ng-template let-name let-message="message" #template3>  
		  <p>Dear {{name}} , {{message}} </p>
		</ng-template>
		<ng-container [ngTemplateOutlet]="templates" 
		              [ngTemplateOutletContext] ="{$implicit:'Guest',message:'Welcome to our site'}">
		</ng-container> 

	или так:

		<ng-template #estimateTemplate let-lessonsCounter="estimate">
		    <div> Approximately {{lessonsCounter}} lessons ...</div>
		</ng-template>
		<ng-container 
		   *ngTemplateOutlet="estimateTemplate;context:ctx">
		</ng-container>	
		//  ctx = {estimate: this.totalEstimate};

ngComponentOutlet аналогична ngTemplateOutlet. Различие лишь в том, что она формирует представление Host View по переданному ей названию компонента:

	import { Component } from '@angular/core';
	import { HelloComponent } from './hello.component';
	import { ByeComponent } from './bye.component';

	@Component({
	  selector: 'my-app',
	  template: `
	    <button (click)="render()">Render dynamic component</button>
	    <ng-container *ngComponentOutlet="currentComponent"></ng-container>
	  `
	})
	export class AppComponent  {
	  public components = [HelloComponent, ByeComponent];
	  public currentComponent = null;

	  public render(): void {
	    const index = Math.round(Math.random());
	    this.currentComponent = this.components[index];
	  }
	}

	фактически это ленивая загрузка компонента потому что до последнего момента фреймворк не знает какой именно компонент будет встроен и насколько он тяжёл.

	демо тут: https://stackblitz.com/edit/angular-ng-component-outlet-example-7bte9w?file=src%2Fapp%2Fapp.component.ts

		однако в 17 версии фреймворка появился более продвинутый механизм ленивого встраивания одного standalone компонента в другой не standalone or ngModule. этот механизм предполагает отображение заглушек и ошибок в процесс встраивания:

	    <button type="button" #loadButton>Click Me</button>
	    @defer(on interaction(loadButton)) {
	      <app-lazy-component />
	    }@placeholder {
	      showed until the chunk file not begin to load
	    }@loading {
	      showed during the loading of the chunk
	    }@error {
	      showed if an error happen during loading
	    }		


	    триггер расположен после @defer. триггер может быть декларативным (hover) или императивным (пользовательская логика, возвращающая boolean, например, qwe$ | async)

	    демо: https://stackblitz.com/edit/angular-defer-example-fbmqbq?file=src%2Fmain.ts


=========================================================
через ng-content можно передавать отдельный части разметки и отображать их соответственно в разных целевых контейнерах.

	<app-child>
	  <div header>This should be rendered in header selection of ng-content</div>
	  <div body>This should be rendered in body selection of ng-content</div>
	</app-child>


	<div class="header-css-class">
	  <h4>Header</h4>
	  <ng-content select="[header]"></ng-content>
	</div>
	<div class="body-css-class">
	  <h4>Body</h4>
	  <ng-content select="[body]"></ng-content>
	</div>

	также существует фоллбек для непомеченных проекций:

		<app-card>
		  <card-header>
		    <h2>Header Content</h2>
		  </card-header>
		  <card-content>
		    <p>This is the main content of the card.</p>
		  </card-content>
		  <card-footer>
		    <button>Footer Button</button>
		  </card-footer>
		  <p>This will be projected into default ng content in the child</p>
		</app-card>


		<div class="card">
		  <ng-content select="card-header"></ng-content>  
		  <ng-content select="card-content"></ng-content>
		  <ng-content select="card-footer"></ng-content>
		  <!-- capture anything except "card-header, card-content and card-footer" -->
		  <ng-content></ng-content>
		</div>


	

=========================================================
что такое пайп?

	это фильтр, которые получает на вход данные и возвращет изменённые данные. в основном ипользуется в шаблоне, но есть возможность использовать пайпы в компоненте.

=========================================================
pipes pure & pipes impure

	по умолчанию пайпы чистые. то есть они реагируют только на изменение входного параметра по ссылке. если ссылка не меняется, то метод transform не отрабатывает заново, а отдаётся предыдущее замемоизированное значение. ресурсы экономятся. в этом преимущество пайпа перет геттером или методом

	если в декораторе пайпа прописать pure: false, то пайп будет реагировать на изменение внутренностей передаваемого объекта, а так же на любой запуск цикла обнаружения изменений. это опасно с точки зрения производительности. потому что метод transform будет срабатывать очень часто.

	пайпы можно использовать не только через шаблон, но и через контрорллер:

		import { DatePipe } from '@angular/common';

		class MyService {

		  constructor(private datePipe: DatePipe) {}

		  transformDate(date) {
		    return this.datePipe.transform(date, 'yyyy-MM-dd');
		  }
		}

=========================================================
trackBy

	используется при циклическом выводе элементов в шаблоне. проблема в том, что если мы отрисовали при помощи *ngFor 4 элемента, а затем по событию добавили в середину новый элемент, то в DOM будут перерисованы все элементы.

	но если мы используем trackBy, который принимает index и item, а возваращает какую-нибудь уникальную строку, то то каждый элемент будет помечен этой уникальной строкой, а в DOM будет перерисован только новый элемент и те, которые ниже него.

		<li *ngFor="let item of items; trackBy: trackByFn">{{ item }}</li>
		trackByFn(index, item) {   
		  return item.id;
		}	

=========================================================
catchError 

	оператор, который позволяет в случае возникновения ошибки подменить результат новым observable и продолжить выполнение, тем самым позволить сработать коллбеку успешной операции. при этом коллбек ошибки не сработает.

	если catchError не вернёт observable, то сработает коллбек ошибки в блоке подписки.

	  public ngOnInit() {
	    this.http
	      .get('data.json')
	      .pipe(
	        tap(() => console.log('start...')),
	        catchError((error) => {
	          console.log('error!!!', error);
	          return of([1, 2, 3]);					// shape new result for success callback
	        })
	      )
	      .subscribe(
	        (data) => console.log('OK', data),		// success
	        (err) => console.log('err', err)		// error
	      );
	  }


=========================================================
IVY

	это механизм, который преобразует компоненты и шаблоны в чистый HTML и javaScript.

=========================================================
interceptor это просто сервис, который срабатывает при отправке запроса. он может изменить исходящие данные и изменить получаемые данные:

	export class InterService implements HttpInterceptor {
	  constructor() {}

	  intercept(
	    req: HttpRequest<any>,
	    next: HttpHandler
	  ): Observable<HttpEvent<any>> {
	    const authReq = req.clone({
	      headers: req.headers.set('Session', '123456789'), // добавить заголовок при отправке запроса
	    });

	    return next.handle(authReq).pipe(
	      map((event) => {
	        // изменить id в полученном результате
	        event['body'] = event['body']?.map((x) => {
	          const newR = x;
	          newR.id = newR.id * 10;
	          return newR;
	        });
	        return event;
	      }),
	      tap((event) => {
	        if (event instanceof HttpResponse)
	          console.log('Server response', event);
	      })
	    );
	  }
	}


а встраивается он в модуль так же как другие сервисы тоесть через массив providers.

	providers: [
	    {
	      provide: HTTP_INTERCEPTORS,
	      useClass: InterService,
	      multi: true,
	    },
	  ],

=========================================================
ExpressionChangedAfterItHasBeenCheckedError выводится только в dev режиме.

переменные в компоненте и вывод их в шаблоне связаны. change detection актуализирует эту связь. но бывает так, что после того как CD отработал переменная в компоненте меняется, при этом соответствующее значение в шаблоне не обновляется. в этом случае dev режим извещает об этом разработчика при помощи ExpressionChangedAfterItHasBeenCheckedError, запуская дайджест цикл ещё раз после того как CD отработает. но prod режим не этого не делает.

чтобы избежать этой ошибки нужно после того как отработает CD инициировать событие(например при помощи setTimeout) или запустить changeDetection().

	export class AppComponent {
	  name = 'I am a component with Ivy 🍃';
	  text = 'A message for the child component';
	  @ViewChild(ChildComponent) childComponent: ChildComponent;

	  constructor(private cdRef: ChangeDetectorRef) {}

	  ngAfterViewInit() {
	    this.childComponent.input = 'Changed Name';

	    // this.cdRef.detectChanges();

	    // setTimeout(() => {
	    //   this.childComponent.input = 'Changed Name';
	    // });
	  }
	}


	@Component({
	  selector: "hello",
	  template: `
	    <h1>Hello {{ input }}!</h1>
	  `,
	})
	export class ChildComponent {
	  @Input() input: string;
	}

тут живой пример: https://stackblitz.com/edit/expressionchangedafterithasbeencheckederror-ivy-byszyj?file=src/app/child.component.ts


--------------

представим, что мы хотим изменить какое-то значение родителя из дочернего элемента. 
Angular как всегда пройдёт «сверху вниз», отследит изменения, и… его только что проверенное состояние снова меняет какой-то дочерний элемент. 
Отсюда и возникает ошибка ExpressionChangedAfterItHasBeenCheckedError

=========================================================
hostDirectives это альтернативный способ привязать директиву к компоненту. раньше необходимо было прописывать директиву в виде атрибута

	<a-comp dir></a-comp>

но сейчас возможно это делать в декораторе компонента:

	@Component({
	  selector: 'admin-menu',
	  template: 'admin-menu.html',
	  hostDirectives: [MenuBehavior],
	})
	export class AdminMenu { }

при этом отпадает необходимость в лишнем звене @Input\@Output при передаче параметров. 

Так же есть возможность реализовать наследование в директивах, если в декораторе директивы тоже использовать hostDirectives.

важно помнить, что хуки жизненного цикла сначала выполняются в директивах и только потом в использующих их компонетнах.


=========================================================
NgOptimizedImage позволяет оптимизировать загрузку изображений. при этом является просто надстройкой над обычным html-элементом img.

	1. при подключении в модуль позволяет указать несколько CDN-поставщиков через providers. при этом в в атрибуте rawSrc не требуется указывать полный путь к поставщику, а только конечную его часть. 

		<img rawSrc="1-4000x3000_ag.jpg" />

	2. чтобы при после завершения загрузки картинки экран не дёргался можно сразу указать ширину и высоту. по сути в нативном img делается то же самое
		
		<img [rawSrc]="img.url"  width="4000" height="3000"/>

	3. в консоли будет предупреждение, если html не содержит <link rel="preconnect" href="https://ik.imagekit.io">

	4. браузер сам подбирает разные размеры изображения в зависимости от размера экрана, это нативная способность. использование rawSrcset позволяет сократить запись
		
		<img [rawSrc]="img.url" rawSrcset="200w, 400w, 600w, 800w, 1000w" />

	 5. при помощи priority можно пометить наиболее приоритетную картину. это дублирование нативного функционала img-элемента.

		<img [rawSrc]="img.url" priority />

=========================================================
angular 15: что нового

	1. hostDirectives

		появились директивы, привязанные к компоненту. при этом директивы можно наследовать

	2. NgOptimizedImage 

		появилась директива для оптимизации загрузки изображений

	3. появилась сокращённая запись guards (без класса, реализующего интерфейс и возвращающего true/false):

		const route = {
		  path: 'admin',
		  canActivate: [() => inject(LoginService).isLoggedIn()]
		};  


		раньше было:

			@Injectable({ providedIn: 'root' })
			export class MyGuardWithDependency implements CanActivate {
			  constructor(private loginService: LoginService) {}

			  canActivate() {
			    return this.loginService.isLoggedIn();
			  }
			}

			const route = {
			  path: 'somePath',
			  canActivate: [MyGuardWithDependency]
			};		

		сейчас стало:

			const route = {
			  path: 'admin',
			  canActivate: [() => inject(LoginService).isLoggedIn()]
			};		



	4. упростилась запись ленивой загрузки в роутере (теперь не нужно указывать конкретный компонент, он сам будет найден на основе пути к файлу)

		раньше было:

			{
			  path: 'lazy',
			  loadChildren: () => import('./lazy-file').then(m => m.LazyComponent),
			}		

		сейчас стало:

			{
			  path: 'lazy',
			  loadComponent: () => import('./lazy-file'),
			}


	5. улучшенные сообщения об ошибках в консоли, которые, в частности, игнорируют сообщения от сторонних библиотек.

	6. общий рефакторинг кода фреймворка


=========================================================
angular elements это npm-пакет, который позволяет отдельные angular-компоненты: 

	1. запаковывать
	2. импортировать результирующие js/css файлы в любую среду
	3. в любой среде использовать кастомный тег типа <my-tag></my-tag>

	на такой тег в среде HTML можно повесить addEventListener, который будет слушать событие, которое генерировано angular-компонентом при помощи emit(). кроме того, такой тег может принимать значения, передаваемые через атрибут при помощи @Input.

=========================================================
динамические компоненты это компоненты, кторые создаются в рантайме. Например тултипы, модальные окна и т.д.

с 13 версии ДК создаются без использования componentFactoryResolver.

	export class AppComponent {
	  @ViewChild('dynamic', { read: ViewContainerRef })
	  private viewRef: ViewContainerRef;

	  showDynamicComponent(): void {
	    this.viewRef.clear();
	    this.viewRef.createComponent(DynamicComponent);
	  }

	  removeDynamicComponent(): void {
	    this.viewRef.clear();
	  }
	}

то есть нужно просто получить элемент и выполнить на нём createComponent()

можно настроить действие, которое будет происходит при удалении динамического компонента. это действие нужно описывать внутри динамического компонента:

	<div class="c1" (click)="clicked.emit()">This is Component 1</div>

	public destroyRef = inject(DestroyRef);
	public clicked = output<void>();

	ngOnInit() {
	this.destroyRef.onDestroy(() => {
	  console.log('Component 1 was destroyed');
	});
	}

=========================================================
<base href="/"> 

	служит для того чтобы быть префиксом перед относительными ссылками.

=========================================================
какие виды директив бывают в ангуляре?

	атрибутивные(изменяют внешний вид или поведение), структурные(создают и удаляют элементы в DOM)

=========================================================
что такое резолвер в ангуляр?

	Резолверы в Angular используются для предварительной выборки данных: пока пользователь перенаправляется с одного маршрута на другой, новая доступная страница уже будет содержать те данные, которые требуется на ней отобразить.

=========================================================
что такое route guards в ангуляр?

	позволяют ограничить навигацию по маршрутам. в блок, в котором описываются роуты, добавляется один или несколько роут гардов:

		CanActivate - ограничивает доступ к роуту.
		CanActivateChild - ограничивает доступ к дочерним роутам.
		CanDeactivate - срабатывает когда пользователь покидает роут.
		Resolve - срабатывает перед открытием роута(часто это асинхронное получение данных).
		Canload - ограничивает загрузку роута при lazy loading подходе. с 15 версии устарел, вместо него используется canMatch

	все гарды кроме Resolver возвращают булево значение. класс, который прописан в роутах должен реализовывать определённый интерфейс. но в angular15 появилась сокращённая запись для гардов: canActivate: [() => inject(LoginService).isLoggedIn()]

	существует приоритет гардов, по правилам котрого гарды в массиве выполняются параллельно, но все они прежде чем начать действовать, будут ждать завершения первого по счёту гарда в массиве. в случае редиректов есть нюансы: https://habr.com/ru/articles/689682/

	передать параметр в гард можно так:

		{ 
		   path: 'teacher', 
		   component: DashboardTeacherComponent, 
		   canActivate: [AccessGuardTeacher], 
		   data: { role: 'teacher' } 
		}

		export class AccessGuardTeacher implements CanActivate {
		    canActivate(route: ActivatedRouteSnapshot): boolean {
		        const role = route.data.role;
		        return true;
		    }
		}	

=========================================================
что такое tree shaking? где для него прописываются настройки?

	Tree shaking (Встряхивание дерева) — это метод оптимизации библиотек путем удаления любого кода который фактически не используется из окончательного файла.

	включается в webpack.config.js. а файлы-исключения указываются в package.json

=========================================================
что такое веб-воркеры?

	это механизм, который предоставляет возможность запускать скрипт в отдельном процессе. 
	после создания веб-воркера через cli создастся файл веб воркера и шаблонный код в компоненте, для которого он создан.
	таким образом из компонента можно будет отправлять сигналы на совершение определённого действия. при этом ответы веб-воркера будут в компоненте же отлавливаться при помощи onmessage и onerror

	веб-воркеры бывают выделенные и разделяемые. первые работают только с одним компонентом, вторые - со многими.

	  // webWorker-demo/src/app/webWorker.ts
	  function fibonacci(num) {
	      if (num == 1 || num == 2) {
	          return 1
	      }
	      return fibonacci(num - 1) + fibonacci(num - 2)
	  }
	  self.addEventListener('message', (evt) => {
	      const num = evt.data
	      postMessage(fibonacci(num))
	  })


	  // webWorker-demo/arc/app/app.component.ts
	  @Component({
	      selector: 'app',
	      template: `
	          <div>
	              <input type="number" [(ngmodel)]="number" placeholder="Enter any number">
	              <button (click)="calcFib">Calc. Fib</button>
	          </div>
	          <div>{{output}}</div>
	      `
	  })
	  export class App implements OnInit{
	      private number
	      private output
	      private webworker: Worker
	      ngOnInit() {
	          if(typeof Worker !== 'undefined') {
	              this.webWorker = new Worker('./webWorker')
	              this.webWorker.onmessage = function(data) {при
	                  this.output = data
	              }
	          }
	      }
	      calcFib() {
	          this.webWorker.postMessage(this.number)
	      }
	  }

=========================================================
что такое сервис-воркеры?

	СВ это система кеширования, которая была добавлена в ангуляр. все запросы проходят через СВ. после первого запроса весь ответ кешируется. при последующих запросах сравниваются контрольные суммы принятных файлов. если они не отличаются, то пользователю отдаются ране загруженные файлы.
	контрольные суммы хранятся в manifest.json, который создаётся в момент сборки приложения.

=========================================================
что такое HostListener?

	это декоратор, который связывает события DOM и метод компонента. например после наведения курсора должен вывестись console.log

	    @HostListener("mouseenter") 
	    onMouseEnter() {
	        console.log('start');
	    }

	при этом возможно отлавливать события не только на элементе директивы, но и на window. здесь второй аргумент это то, что передаётся в обработчик когда событие произойдёт.

		@HostListener('window:keyup', ['$event'])
		KeyUp(event: KeyboardEvent) {
			console.log("KeyUp", event);
		}

		или

	  @HostListener('document:keydown.escape', ['$event']) 
	  onKeydownHandler(event: KeyboardEvent) {
	    console.log('esc!');
	  }		


=========================================================
что такое HostBinding?

	это декоратор, который связывает свойство компонента со значением атрибута хост-элемента

		private fontWeight = 'bold'

		@HostBinding('style.fontWeight') 
		get getFontWeight() {
			return this.fontWeight;
		}

		в данном примере хост-тегу добавляется стиль font-weight: bold;

=========================================================
что такое модуль в angular?

	модуль это контейнер, который содержит структурные части приложения: компоненты, директивы, пайпы, сервисы. модули могут импортироваться друг в друга, но при этом они не образуют дерево со строгими уровнями. 

	типы модулей:
		CoreModule - содержит сервисы, общие для всего приложения.
		SharedModule - содержит компоненты, директивы и пайпы для всего приложения.
		RoutingModule - содержит описание роутов и соответствующих им компонентов.
		корневой - он загружается в первую очередь и содержит второстепенные модули.

	технически модуль представляет собой класс с декоратором ngModule. декоратор содержит следующие поля:
		declarations - для описания использующихся компоннетов, директив, пайпов.
		providers - для импорта сервисов
		imports - для импорта других модулей или автономных компонентов
		exports - массив компонентов, директив и пайпов, которыми пользуются другие модули, если они импортируют текущий;

=========================================================
как отписаться от потока?

	первый способ: 
		1. создать переменную типа ISubscription
		2. присвоить ей поток
		3. в хуке ngOnDestroy или в блоке next прописать .unsubscribe()

	второй способ:
		1. создать s = Subject
		2. .pipe(takeUntil(s))
		3. в хуке ngOnDestroy использовать this.s.next();

	третий способ:
		1. в шаблоне использовать async pipe

	четвёртый способ:
		использовать стороннюю библиотеку с методом untilDestroy().

		прописать декоратор перед компонентом:

			@UntilDestroy()
			@Component({})
			export class InboxComponent {		

		в пайпе потока использовать:

			.pipe(untilDestroyed(this))

	пятый способ:

		я 16 версии появился DestroyRef, он позволяет не задействовать хук ngOnDestroy:

			export class Component implements OnInit {
			  destroyRef = inject(DestroyRef);
			 
			  ngOnInit(): void {
			    const destroyed = new Subject();
			 
			    this.destroyRef.onDestroy(() => {
			      destroyed.next();
			      destroyed.complete();
			    });
			 
			    this.service.getData()
			      .pipe(takeUntil(destroyed))
			      .subscribe(response => this.data = response)
			  }
			}

	шестой способ:

		import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
		 
		export class Component implements OnInit{
		  data;
		 
		  constructor(private service: DataService) {
		    this.service.getData()
		      .pipe(takeUntilDestroyed())
		      .subscribe(response => this.data = response)
		  }
		}


	седьмой способ:

		унаследовать компонент при помощи super() от другого:

			@Component({
			  selector: 'app-base-component',
			  template: '',
			})
			export class BaseComponent implements OnDestroy {
			  protected readonly $destroy = new Subject();

			  ngOnDestroy() {
			    this.$destroy.next(true);
			    this.$destroy.complete();
			  }
			}		

		теперь в наследнике будет срабатывать хук ngOnDestroy, который будет посылать сигнал сюда:

			this.checkList$.pipe(takeUntil(this.$destroy)).subscribe(


	что будет, если не отписываться?
		будет происходить утечка памяти. например, если пользователь 10 раз зайдёт на одн и туже страницу, на которой есть подписка, то будет работать 10 коллбеков.


=========================================================
что такое ngrx?

	это шаблон, позволяющий централизировать изменения состояния. когда проект становтся большим, то состояния могут быть изменены из разных мест программы. это приводит к ошибкам и трудностям юнит-тестирования.

	ngrx предполагает наличие глобального стейта, при изменении которого каждый раз создаётся клон с добавленными изменениями. таким образом в приложении есть только один источник правды.

	редюсер содержит условный оператор, который на основе входящего сигнала(экшена) изменяет стейт. и возвращает изменённую копию.

	экшен это название действия в виде строки, которое отправляется в редюсер. возможно, с полезной нагрузкой. экшен отправляется в редюсер при помощи метода dispatch().

	для повышения производительности стейт можно запрашивать частями. например, если требуется на экране отобразить определённую часть стейта.

	в эффектах выполняются побончые действия, которые не укладываются в концепцию чистых функций.

	кроме того существует фасад, который сожержит методы для выборки и методы для диспатча экшена в редюсер.

	живой пример: https://stackblitz.com/edit/ngrx-demo-angular?file=src%2Fapp%2Fapp.state.ts

	-----------

	ngrx нужно использовать когда несколько участников одновременно редактируют одни и те же данные. в этом случае участники конкурируют между собой, а следовательно нет определённости и однозначности.

	-----------

	@ngrx/component-store подходит для компонентов, которые требуют управления состоянием, но не нуждаются в глобальном хранилище NgRx. то есть это локальный стейт:

		@Component({
		  selector: 'app-counter',
		  template: `
		  <div>
		    <h1>Count: {{ count$ | async }}</h1>
		    <button (click)="increment()">Increment</button>
		    <button (click)="decrement()">Decrement</button>
		  </div>`,
		})
		export class CounterComponent {
		  private readonly initialState: CounterState = { count: 0 };


		  constructor(private store: ComponentStore<CounterState>) {
		    this.store.setState(this.initialState);
		  }


		  readonly count$ = this.store.select((state) => state.count);


		  readonly increment = this.store.updater((state) => ({
		    ...state,
		    count: state.count + 1,
		  }));


		  readonly decrement = this.store.updater((state) => ({
		    ...state,
		    count: state.count - 1,
		  }));
		}	


=========================================================
какие подходы к мультиязычности существуют?

	пакет ngx-translate (https://stackblitz.com/edit/ngx-translate-example):
	в этом случае после подключения его в главный модуль приложения необходимо в assets создать в формате json описания констант и соответвтующие им переводы. для каждого языка отдельный файл. далее в компоненте нужно инжектировать сервис TranslateService и использовать pipe для описанной константы:

		<h2>{{ 'HOME.TITLE' | translate }}</h2>

	язык можно менять динамически, используя метод 
		
		TranslateService.use('en-US')

=========================================================
как можно проводить тестирование?

	в angular можно использовать jest юнит-тесты. они могут быть изолированные и неизолированные.

	в первом случае класс не имеет зависимостей и тестируется как изолированный функционал.

	во втором случае необходимо перед каждым тестом создать среду при помощи встроенного фреймворка testBed. создание среды предполагает эмуляцию компонента и установка зависимостей. в этом случае обычно сервисы, пайпы и прочие зависимости заменяют на моковые данные.

=========================================================
на каком шаблоне построен angular?

	mvvm

		model - сервисы. содержат данные и логику работы с данными(отправка в БД, получение из БД и т.п.)

		view - html,css. разметка и стили

		modelView - контроллер, в котором есть:
			1. связь с данными из модели, и
			2. хранятся данные-стейт шаблона, которые не должны попадать в БД(на каких полях побывал фокус, какие ошибки валидации сейчас активны и т.д). таким образом modelView тоже является миниатюрной моделью.

		modelView работает реактивно, то есть любое взаимодействие инициируется не получателем, а отправителем.

=========================================================
отличие конструктора от ngOnInit

	конструктор это не часть ангуляра, а часть ES6. он выполняется раньше хуков. в конструкторе недоступны входные параметры компонента.

=========================================================
можно ли в конструкторе получить значения инпутов?

	нет, в результате получим  undefined. для этого нужно использовать ngOnInit		

=========================================================
работали с вебсокетами?

	да, в частности они применялись для получения пуш-уведомлений в PWA. ВС обеспечивают такую возможность потому что протокол WSS использует постоянное двустороннее соединение.

	чтобы работать с ВС необходимо создать экземпляр объекта:
		let socket = new WebSocket("wss://.....");

	и затем повесить на него обработчики:
		onopen,
		onmessage,
		onerror,
		onclose

=========================================================
загрузка файлов через reactive form

	используется <input type="file" formControlName="file">

	но значение содержит не файл а путь к файлу. чтобы путь заменить на файл нужно или повесить слушатель на поле и в нём произвести замену или в шаблоне использовать событие (change)

	затем сформировать POST-запрос из обычных и файловых полей.

	шаблон:

		<form [formGroup]="myForm" (ngSubmit)="submit()">
		  <input formControlName="name" type="text" />

		  <input
		    formControlName="fileSource"
		    type="file"
		    (change)="onFileChange($event)"
		  />

		  <button class="btn btn-primary" type="submit">Submit</button>
		</form>

	компонент:

	  myForm = new FormGroup({
	    name: new FormControl('', [Validators.required]),
	    fileSource: new FormControl('', [Validators.required]),
	  });

	  constructor(private http: HttpClient) {}

	  onFileChange(event) {
	    if (event.target.files.length > 0) {
	      const file = event.target.files[0];
	      console.log(event.target.files);
	      console.log(file);
	      this.myForm.patchValue({
	        fileSource: file,
	      });
	    }
	  }

	  submit() {
	    const formData = new FormData();
	    formData.append('file', this.myForm.get('fileSource').value);
	    formData.append('name', this.myForm.get('name').value);

	    this.http
	      .post('http://localhost:8001/upload.php', formData)
	      .subscribe((res) => {
	        console.log(res);
	        alert('Uploaded Successfully.');
	      });
	  }		


=========================================================
как использовать валидатор на уровне группы? (случай изменения пароля со старого на новый, с подтверждением)

	нельзя использовать кастомные валидаторы, в которых объект валидации затирается при помоши setErrors

	вот правильное решение:

	@Component({
	  selector: 'my-app',
	  standalone: true,
	  imports: [
	    CommonModule,
	    ReactiveFormsModule
	  ],
	  template: `
	    <ng-container [formGroup]="form">
	      <input formControlName="field_1" [class.error]="form.get('field_1').invalid"> 
	      <br>
	      <input formControlName="field_2" [class.error]="form.get('field_2').invalid"> 
	    </ng-container>
	    <br>
	    <ng-container *ngIf="form.errors?.nonEqualPasswords">
	      Пароли то разные
	    </ng-container>
	  `,
	})
	export class App {
	  name = 'Angular';
	  form = inject(FormBuilder).group({
	    field_1: [null, Validators.required],
	    field_2: [null, Validators.required]
	  }, {
	    validators: [(group) => {
	      const c1 = group.get('field_1');
	      const c2 = group.get('field_2');

	      return c1.valid && c2.valid && c1.value !== c2.value ? {nonEqualPasswords: true} : null
	    }]
	  })
	}	

=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
описать хуки жизненного цикла.

	ngOnChanges 

		срабатывает только когда ссылка Input элемента меняется или составляющая переданного объекта. срабатывает каждый раз при получении всех значений для входных переменных или они равны undefined.

		в том случае, если изменяется внутренняя часть Input объекта, то имеет значение стратегия. в частности OnPush разрешает отслеживать в шаблоне только изменение ссылки. а  Default разрешает отслеживать в шаблоне также и зменение внутренней части объекта.

	ngOnInit 

		срабатывает один раз при создании компонента. то есть когда все всходящие параметра input проинициализированы значением или равны undefined. другими словами - срабатывает один раз после первой установки входных значений компонента. предназначен для логики инициализации.

		если нет входных параметров, то ngOnChange не выполняется. следовательно ngOnInit выполнится первым.

	ngDoCheck 

		срабатывает при любой стратегии. и при любом изменении Input объекта (и по ссылке, и по внутренней части). кроме того этот хук срабатывает при любом событии компонента например:

			EventEmitter.emit(),

			клик по кнопке, но только если к кнопке привязан обработчик:

				сработает:

				    <button (click)="run()">btn</button>
				    <button (click)="null">null</button>	

			    не сработает:

					<button>empty</button>

				тут демо: https://stackblitz.com/edit/stackblitz-starters-3kb5yn?file=src%2Fapp%2Fsecond%2Fsecond.component.ts


		по сути этот хук срабатывает на любой цикл обнаружения изменений в том числе запущенный вручную через ChangeDetectorRef. срабатывает сразу после ngOnInit().

		таким образом при помощи ngDoCheck можно обойти ограничение стратегии OnPush:

			appComponent:

				@Component({
				  selector: 'app-root',
				  template: `
				  <newsletter [user]="user"></newsletter>
				`,
				})
				export class AppComponent {
				  user: any = {
				    firstName: 'Alice',
				    lastName: 'Smith',
				  };

				  constructor() {
				    setTimeout(() => {
				      this.user.firstName = 'Bobby';
				    }, 4000);
				  }
				}		
				
			secondComponent:

				@Component({
				  selector: 'newsletter',
				  changeDetection: ChangeDetectionStrategy.OnPush,
				  template: `
				    <fieldset class="newsletter">     
				      <h5>Hello {{user?.firstName}},
				          enter your email below to subscribe:</h5>
				      <form>
				          
				          <input #email type="email" name="email" placeholder="Enter your Email">
				        
				          <input  type="button" class="button button-primary" value="Subscribe"
				                  (click)="subscribeToNewsletter(email.value)">
				      </form>
				            
				    </fieldset>
				`,
				})
				export class SecondComponent {
				  @Input()
				  user: any;

				  @Output()
				  subscribe = new EventEmitter();

				  subscribeToNewsletter(email: string) {
				    this.subscribe.emit(email);
				  }

				  constructor(private cdr: ChangeDetectorRef) {}

				  ngDoCheck() {
				    console.log('do check', this.user);
				    this.cdr.detectChanges();
				  }
				}

				в результате видно, что несмотря на changeDetection: ChangeDetectionStrategy.OnPush, всё же переменная user.firstname актуализируется после 4 секунд при помощи ngDoCheck()

				живой пример тут: https://stackblitz.com/edit/stackblitz-starters-ru9hbq?file=src%2Fapp%2Fsecond%2Fsecond.component.ts


	ngAfterContentInit, ngAfterContentChecked 

		срабатывают когда отрисовались(а отрисоваться они могут после того как все input-параметры проинициализированы) встроенные при помощи ng-content компоненты. и когда они были изменёны.

	ngAfterViewInit, ngAfterViewChecked 

		срабатывают когда отрисовались встроенные при помощи host-тега компоненты. и когда они были изменёны.

	ngOnDestroy 

		срабатывает один раз когда пользователь покидает компонент. обычно в этом хуке очищаются подписки и прочие ресурсы, а так же отключаются слушатели событий.

		если пользователь просто закрывает вкладку или браузер, то ngOnDestroy не успеет сработать, чтобы это исправить нужно использовать hostListener:

		// не срабатывает, но должно
		  @HostListener('window:beforeunload')
		  async ngOnDestroy() {
		    if (this.myValueSub) {
		        this.myValueSub.unsubscribe();
		    }
		 
		    await this.authService.logout();
		  }

	конструктор не относится к хукам, он срабатывает до них. поэтому в нём недоступны входные свойства класса.

	существуют хуки, которые не привязаны к компоненту, а привязаны с приложению вообще. и они срабатывают при первом рендере всех компонентов приложения и при последующих рендерах. называются они соответственно: afterNextRender и afterRender. они в отличие от остальных хуков прописываются в конструкторе:

		export class App {
		  constructor() {
		    afterNextRender(() => {
		      console.log('afterNextRender called');
		    });

		    afterRender(() => {
		      console.log('afterRender called', new Date());
		    });
		  }
		}

	они появились в 16 версии фреймворка.ы


	тут подробнее: https://angular.dev/guide/components/lifecycle

=========================================================
чем конструктор отличается от ngOnInit?

	конструктор используется для иньекции зависимостей, ngOnInit - для логин инициализации.

	в конструкторе недоступны Input-свойства, но доступны обычные свойства класса.


=========================================================
что такое структурные директивы?

	это директивы, действие которых изменяет DOM: ngIf, ngFor, ngSwitch

	ngIf можно использовать в альтернативном синтаксисе:

		<p *ngIf="condition;else unset">
			Привет мир
		</p>
		<ng-template #unset>  
			<p>Пока мир</p>  
		</ng-template>   	

	при помощи ngSwitch можно создать в шаблоне аналог switch-оператора:

	<div [ngSwitch]="count">
		<ng-template *ngSwitchCase="1">{{count * 10}}</ng-template>
		<ng-template *ngSwitchCase="2">{{count * 100}}</ng-template>
		<ng-template *ngSwitchDefault>{{count * 1000}}</ng-template>
	</div>	

	важно понимать, что знак * это просто синтаксический сахар. без него запись более многословна.

=========================================================
что такое атрибутивные директивы?

	это директивы, которые меняют внешний вид или поведение уже существующего компонента. ngClass, ngStyle, ngModel динамически добавляют классы или стили.

		[ngClass]={
		    "класс1": true/false,
		    "класс2": true/false,
		    ...................
		}	

	атрибутивные директивы позволяют привязываться к динамическим значениям и выражениям. таким образом обеспечивая изменение именно поведения, а не только внешнего вида элемента.

=========================================================
что такое @Input/@Output

	существует возможность передавать значение из родительского компонента в дочерний при помощи синтаксиса квадратных скобок. для этого в дочернем компоненте входное свойство должно быть помечено декоратором @Input.

	кроме того можно это свойство устанавливать через сеттер, если требуется обработка/проверка входящего значения:

	    @Input()
	    set userAge(age:number) {
	        if(age<0)
	            this._userAge=0;
	        else if(age>100)
	            this._userAge=100;
	        else
	            this._userAge = age;
	  	}	

	  	при этом важно понимать, что userAge это название той переменной, которая в шаблоне родителя передаётся через синтаксис квадратных скобок, а age это локальная ничегонезначащая прееменная.

	если нужно передать значение из дочернего компонента в ролительский, то используется всплывающее событие. для этого выходное свойство должно быть помечено декоратором @Output:

    @Output() onChanged = new EventEmitter<boolean>();
    change(increased:any) {
        this.onChanged.emit(increased);
    }

    в родительском компоненте срабатывает событие onChanged, оно ловится через синтаксис круглых скобок.

=========================================================
чем отличаются директивы и компоненты?

	у директивы нет шаблона потому что она работает с существующими в DOM элементами. у компонента есть шаблон поэтому он создаёт разметку внутри тега, который используется для вставки компонента в DOM.

=========================================================
template-driven forms

	чтобы создать шаблонную форму нужно в компоненте определить объект с полями формы:

	  form = {
	    name: '',
	    position: '',
	  };

	  submit() {
	    console.log(this.form);
	  }

	затем в шаблоне прописать элементы этого объекта при помощи специального синтаксиса:

	  <div>
	    <input
	      type="text"
	      [(ngModel)]="form.name"
	      name="name"
	      #name="ngModel"
	      required
	    />
	    <ng-container *ngIf="name.touched && name.invalid">
	      name error
	    </ng-container>
	  </div>

	  <div>
	    <input
	      type="text"
	      [(ngModel)]="form.position"
	      name="position"
	      appPositionValidator
	      #position="ngModel"
	    />
	    <ng-container *ngIf="position.touched && position.invalid">
	      position error
	    </ng-container>
	  </div>

	  <button (click)="submit()">submit</button>

	  здесь обязательны:

	      [(ngModel)]="form.name"
	      name="name"

	  не обязательны:

	  		#name="ngModel"

	  		это нужно только для вывода сообщения об ошибке:

				<ng-container *ngIf="name.touched && name.invali	  	

	также допускается прописывать метода сабмита в обёртке формы так:

		<form (ngSubmit)="onSubmit()"></form>


	как видите, валидация осуществояется или при помощи встроенных атрибутов required/pattern или при помощи директивы, если требуется кастомная валидация:

		@Directive({
		  selector: '[appPositionValidator]',
		  providers: [
		    {
		      provide: NG_VALIDATORS,
		      useClass: PositionValidatorDirective,
		      multi: true,
		    },
		  ],
		})
		export class PositionValidatorDirective {
		  validator: ValidatorFn;

		  constructor() {
		    this.validator = this.positionValidator();
		  }

		  validate(c: FormControl) {
		    return this.validator(c);
		  }

		  positionValidator(): ValidatorFn {
		    return (control: FormControl) => {
		      if (control.value !== 'boss') {
		        return {
		          positionValidatorError: true,
		        };
		      }

		      return null;
		    };
		  }
		}


	тут больше:
	https://stackblitz.com/edit/angular-ivy-gqy6hs?file=src/app/position-validator.directive.ts

	вывод ошибок валидации в шаблоне осуществляется примено так:

	    <input
	      type="text"
	      [(ngModel)]="form.position"
	      name="position"
	      appPositionValidator
	      #position="ngModel"
	    />
	    <ng-container *ngIf="position.touched && position.invalid">
	      position error {{ position.errors | json }}
	    </ng-container>	

	важно не забыть в теге прописать значение атрибуту name

------------------

	правилом хорошего тона считается создавать геттеры для имени контрола:

		get email() {
		      return this.form.controls['email'];
		 }	

		<input formControlName="email">		

------------------
	
	альтенативная форма записи формконтрола:


		 form = this.fb.group({
		    email: ['', {
		        validators: [ ... array of synchronous validators ...],
		        asyncValidators: [ ... array of asynchronous validators ...]
		        updateOn:  'change' or 'blur' or 'submit'
		    }],
		    ...
		 });	

		 здесь updateOn указывает на каком этапе запускать валидацию поля. дело в том, что, если валидатор асинхронный и отрабатывает долго, то отправка асинхронных запросов после ввоа каждого символа может привести к ухудшению произволительности.

		 другими словами updateOn это откладывание момента проверки валидации поля.

		 change действует по умолчанию и соответствует любому событию в поле.


=========================================================
reactive forms

	модель формы описывается в контроллере. formControls это поля, которые помещаются в контейнер formGroup. затем в шаблоне прописывается подобная структура через атрибуты.

	существует возможность в контроллере задать начальные значения, валидаторы, disabled-состояние. для удобства используется formBuilder, который нужно предварительно заинжектить.

	для конкретного поля можно написать кастомный валидатор. он будет возвращать или null или объект с ошибкой. также валидатор можно написать для группы полей.

	если необходимо динамически добавлять и выводить поля, то используетс formArray. в шаблоне для него используется конструкция ngFor.

	из шаблона можно получить доступ к состоянию полей через .get(). это нужно для вывода сообщений валидации. также доступ к состоянию полей можно получить в контроллере.

	onlySelf запрещает событию всплывать в родительский блок по аналогии с stopPropagation(). поэтому valuesChange не сможет поймать событие. onlySelf действует с: 

		setValue, patchValue, markAsUntouched, markAsDirty, markAsPristine, markAsPending, disable, enable, and updateValueAndValidity

	пример. есть форма с двумя полями. эти поля имеют свою валидацию, но и форма имеет свою, отдельную от них, валидацию:

		this.userNameControl = this.formBuilder.control('Harry', Validators.required);
		this.passwordControl = this.formBuilder.control('S3cReT', Validators.required);
		this.loginForm = this.formBuilder.group({
		  userName: this.userNameControl,
		  password: this.passwordControl
		});	

		сделаем:

			this.passwordControl.setValue('');

			сейчас:

				this.passwordControl.valid === false
				this.loginForm.valid === false

		но если сделаем:

			this.passwordControl.setValue('', { onlySelf: true });

			станет:

				this.passwordControl.valid === false
				this.loginForm.valid === true			


	из-за того, что существует reset() любое поле может получить значение null даже если оно не было им типизировано при объявлении. чтобы этого избежать можно использовать настройку nonNullable. в этом случае после применения reset() значение сбросистся не к null, а к ничальному значению:

		const email = new FormControl('angularrox@gmail.com', {nonNullable: true});
		email.reset();
		console.log(email.value); // angularrox@gmail.com	

		если nonNullable полей много, то можно применять специальный формбилдер	:

			constructor(private fb: NonNullableFormBuilder) {}		

	с 14-ой версии все формы типизированные. это просто значит, что будет работать автодополнение в конструкциях типа patchValue. старые же формы, нетипизированные нужно теперь помечать при помощи:

		const login = new UntypedFormGroup({
		  email: new UntypedFormControl(''),
		  password: new UntypedFormControl(''),
		});	

	можно подписываться на вводи значения и изменение статуса конкретного поля. но с 18-ой версии можно подписываться на поток всевозможных событий, отвеивая ненужные:

		form.events
		  .pipe(filter((event) => event instanceof ValueChangeEvent))
		  .subscribe((event) => {
		    console.log(event);
		  });

	при этом нужно помнить, что события всплывают в зависимости от вложенной структуры формы. остановить всплытие можно при помощи OnlySelf. во всплывающем событии есть указание источника события. а в случае отправки формы событие содержит ТОЛЬКО источник в виде ссылки на объект (конфиг) формы.

	при этом событие reset более сложное потому что оно предполагает восстановление предудущих значениий, то есть взаимодействие с каждым полем и формой вцелом. это всё равно, что пользователь кликал бы по ним.

=========================================================
ленивая загрузка модулей 

	используется для уменьшения бандла, который изначально загружается в браузер. есть роуты, на которые пользователь, возможно, не зайдёт. поэтому они ИМПОРТИРУЮТСЯ по требованию. форма записи такая:

		const routes: Routes = [
		  {
		    path: 'customers',
		    loadChildren: () => import('./customers/customers.module').then(m => m.CustomersModule)
		  }
		];	

	здесь, CustomersModule подгружается когда пользователь заходит на роут customers. при этом CustomersModule имеет свой конфиг роутера, в котром прописан компонент для относительного роута '':

		const routes: Routes = [
		  { path: '', component: UsersContainerComponent },		// <--------------
		  { path: ':id', component: UserComponent }
		];	


	есть возможность лениво загружать компоненты. например в каждой вкладке аккордиона есть тяжёлый компонент. для этого случая нужно воспользовать директиву ngTemplateOutlet, которая представляет из себя слот для вставки <ng-template #name>qwerty</ng-template>. также есть возможность передавать контекст. для этой же цели используется ngComponentOutlet

=========================================================
ленивая загрузка компонентов

	так как существуют автономные компоненты, то есть возможность импортировать их лениво. для этого вместо loadChildren используется loadComponent

=========================================================
type guards

	это просто функция, которая делает проверку типа и возвращает булево значение.

	проверки могут делать при помощи:

		instanceof,
		typeof,
		in

=========================================================
Resolver

	используется для предварительной загрузки данных перед переходом на страницу. например чтобы не показывать пользователю вёрстку без данных или спиннер, то сначала отрабатывает асинхронный запрос на сервер, получаются данные и только после этого происходит переход на страницу и отрисовка контента.

	в компоненте чтобы получить данные резолвера нужно на них подписаться:

		constructor(private _routes: ActivatedRoute) { }

		ngOnInit(): void {
			this._routes.data.subscribe((response: any) => {
			  this.empList = response.employees;
			})
		}	

	при этом нужно помнить, что если пользователь перейдёт на страницу по прямой ссылке, то во время работы резолвера будет виден несформированный шаблон.

	допустим, имеется такой конфиг роутера:

		const routes: Routes = [
		  { 
		    path: 'product/:id',
		    component: ProductDetailsComponent,
		    data: {aaa: 555, z: {q: 11}},
		    resolve: {
		      product: ProductResolver
		    }
		  },
		];	

		пользователь проходит по такому урлу:

			http://localhost:4200/product/b924?qwe=123

		как видно, в резолвер передаётся параметр роута, гет-параметр и произвольные параметр data. получить их в резолвере можно так:

			export class ProductResolver {
			    url = 'http://localhost:3000/products';

			    constructor(private http: HttpClient) {}

			    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
			        // параметр роута
			        const id = route.params['id'];  // route.paramMap.get('id')
			        console.log(id, typeof id)     // b924 string

			        // гет-параметр
			        const qwe = state.root.queryParams['qwe'];  // state.root.queryParamMap.get('qwe')
			        console.log(qwe, typeof qwe)    // 123 string

			        // произвольный аргумент
			        const arg = route.data['aaa'];
			        console.log(arg, typeof arg);   // 555 number

			        // произвольный аргумент в виде объекта
			        const obj = route.data['z'];
			        console.log(obj, typeof obj);   // {q: 11} object

			        return this.http.get(this.url + '?id=' + id).pipe(
			            delay(2000),
			            map(products => products[0])
			        );
			    }
			}

		чтобы получить все эти переданные данные в компоненте нужно подписаться в хуке компонента:

  			constructor(private activatedRoute: ActivatedRoute) {}		

			ngOnInit() {
				this.activatedRoute.data.subscribe((d: any) => {
				  this.product = d.product;
				  console.log(d, d.aaa, d.z)
				});
			}		

		при этом не имеет смысла в компоненте отображать спиннер по значению флага isLoading потому что шаблон компонента начнёт отрисовываться только после того как разрешится резолвер. то есть изменения видимости спиннера просто не будет видно. таким образом, если пользователь загружает страницу по прямому урлу, то не избежать показа несформированной страницы.

		в ранних версиях сервис резолвера должен был имплементировать интерфейс Resolve. в свежих версиях не нужно прописывать implementation, хотя сам метод resolve() должен присутствовать в теле сервиса.


=========================================================
события роутера

  после клика по ссылке происходит переход на роут. последовательно запускаются события роута, на которые можно подписаться из компонента, на который происходит переход:

    constructor(private router: Router) {
      this.router.events.subscribe( (event: RouterEvent) => console.log(event))
    }

  событий много, вот основные:

    NavigationStart - старт перехода на новый роут
    GuardsCheckStart - начало выполнение роут гародв 
    ResolveStart - начало выполнения росолверов
    NavigationEnd - навигация выполнена успешно
    NavigationCancel - навигация была отменена в результате действий роут гардов
    NavigationError - навигация закончена с ошибкой

  существует возможность включить вывод событий в консоль:

    RouterModule.forRoot(ROUTES, {
      enableTracing: true
    })

  в подписке события можно ловить так:

    if (evt instanceof NavigationStart) {
      this.displayMessage = true;
    }

=========================================================
что такое @viewChild?

	при помощи viewChild можно получить доступ к вложенному или даже к произвольному компоненту. допустим в компонент импортирован вложенный в шаблон компонент:

		import { ChildComponent } from './child.component';

	в этом случае обратиться к нему можно так:

		@ViewChild(ChildComponent) 
		child: ChildComponent;
		ngAfterViewInit() {
			console.log(this.child.whoAmI());
		}	

	то же самое будет, если вложенный компонент не импортирован, а указан в шаблоне:

		<input #someInput placeholder="Your favorite pizza toping">

		@ViewChild('someInput') 
		someInput: ElementRef;
		ngAfterViewInit() {
			this.someInput.nativeElement.value = "qwerty";
		}	


		можно не только получать доступ к свойствам дочернего элемента, но и изменять их:

		tpl of inner component:

			<div class="inner">
			  inner:
			  <app-in2 #in2></app-in2>
			</div>

		controller of inner component:

			export class InnerComponent implements AfterViewInit {
			  @ViewChild('in2', { static: true }) in2: In2Component;
			  // здесь true означает, что переменная доступна уже на этапе OnInit.
			  // если false, то переменная доступна только на этапе afterViewInit

			  ngOnInit() {
			    console.log('some var in in2 is:', this.in2.some);	// получение переменной дочернего элемента
			    setTimeout(() => {
			      this.in2.some = 'qwe';	// изменение переменной дочернего элемента
			    }, 2000);
			  }

			  ngAfterViewInit() {
			    // console.log('some var in in2 is:', this.in2.some);
			    // setTimeout(() => {
			    //   this.in2.some = 'qwe';
			    // }, 2000);
			  }
			}

			демо здесь: https://stackblitz.com/edit/at-ng-14-router-mhm3d4?file=src%2Fapp%2Finner%2Finner.component.ts

		если при помощи @viewChild мы обращаемся к DOM-элементу, например, к h2, то в переменной мы получим ссылку на DOM-элемент и работать будем с ней при помощи метода nativeElement.

		но если мы при помощи @viewChild мы обращаемся к ангуляр-компоненту, то мы получим ссылку на инстанс этого компонента. однако, если мы вместо инстанса получить ссылку на DOM-элемент, который оборачивает этот компонент, то нужно @viewChild использовать со вторым аргументом:

		  @ViewChild('primaryColorSample', {read: ElementRef})
		  sample: ElementRef;

		  ngAfterViewInit() {
		    console.log('Values on ngAfterViewInit():');
		    console.log("sample:", this.sample.nativeElement);
		  }		

		 также read пригодится когда нужно получить доступ к директиве, привязанной к DOM-элементу. например когда на инпут повещен датепикер. в этом случае в read нужно указать имя директивы:

			@ViewChild('primaryInput', {read: ColorPickerDirective})
			colorPicker: ColorPickerDirective;

			openColorPicker() {
				this.colorPicker.openDialog();
			}		 


=========================================================
viewChild(ren)

viewChild это декоратор, который позволяет обращаться к свойствам компонентов/директив, которые были встроены в шаблон. другими словами в шаблон может быть встроено несколько одинаковых хост-тегов. в том числе и посредством ngFor. а так же к провайдерам, сервисам встроенных компонентов. 

в качестве встроенных компонентов могут рассматриваться обычные html элементы такие как span. или хост-теги дочерних элементов, выведенные через ngFor.

viewChildren возвращает то же самое но в виде queryList, по кторому нужно ходить при помощи toArray().foreach()

параметр read позволяет обращаться к токену провайдера:

	@Component({
	  selector: 'first-child',
	  providers: [
	    SampleService,
	    { provide: 'TokenA', useValue: 'valueA' },
	    { provide: 'TokenB', useValue: 123 },
	    { provide: ExampleServiceToken, useExisting: SampleService },
	    { provide: 'TokenC', useValue: true }
	  ]
	})

	export class FirstChildComponent{}

	@Component({
	  selector: 'parent',
	  template: `<first-child></first-child>`
	})

	export class ParentComponent{
	  @ViewChild(FirstChildComponent, { read: 'TokenA' }) dependencyA: string;
	  @ViewChild(FirstChildComponent, { read: 'TokenB' }) dependencyB: number;
	  @ViewChild(FirstChildComponent, { read: 'TokenC' }) dependencyC: boolean;
	  @ViewChild(FirstChildComponent, { read: SampleService }) sampleService: SampleService;
	  @ViewChild(FirstChildComponent, { read: ElementRef }) fcElementRef: ElementRef;
	  @ViewChild(FirstChildComponent, { read: FirstChildComponent }) fcComponent: FirstChildComponent;
	  @ViewChild(FirstChildComponent, { read: ExampleServiceToken }) exampleService: SampleService;
	}

свойство static определяет в какой момент будут считываться viewChild (до отрисовки шаблона компонента или после. это событие ngAfterViewInit)


декорировать можно импортированные элементы или помеченные в шаблоне при помощи #.


https://dev-gang.ru/article/ponimanie-dekoratorov-viewchild-i-viewchildren-v-angular--bpb46hqf3i/

--------------

@Component({
  selector: 'my-app',
  template: `
    <alert></alert>
    <alert type="danger"></alert>
    <alert type="info"></alert>
  `,
})
export class App {
  @ViewChildren(AlertComponent) alerts: QueryList<AlertComponent>
  
  ngAfterViewInit() {
    this.alerts.forEach(alertInstance => console.log(alertInstance));
  }
}



----------------
@Component({
  selector: 'my-app',
  template: `
    <hello></hello>
    <p #p>Start</p>
  `,
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  @ViewChild(HelloComponent)
  hello: HelloComponent;

  @ViewChild('p')
  p: ElementRef;

  ngOnInit() {
    console.log('ngOnInit', this.hello);		// undefined
    console.log('ngOnInit', this.p);			// undefined
  }

  ngAfterViewInit() {
    console.log('ngAfterViewInit', this.hello.greetings);	// hello i am hello comp
    console.log('ngAfterViewInit', this.p);					// *nativeElement*
  }
}


@Component({
  selector: 'hello',
  template: `<h1>Hello</h1>`,
  styles: [`h1 { font-family: Lato; }`],
})
export class HelloComponent {
  public greetings = 'i am hello comp';
}


----------------


contenChild(ren)

этот декоратор используется в дочернем элементе для доступа к элементу, которые пришёл из родительского элемента и был вставлен при помощи ng-content

	родитель:

		@Component({
	    selector: 'my-app',
	    template: `<child-comp>
	                    <h3 #headerContent>Добро пожаловать {{name}}!</h3>
	               </child-comp>`
		})

	дочерний компонент:

		@Component({
		    selector: 'child-comp',
		    template: `<ng-content></ng-content>
		               <button (click)="change()">Изменить</button>`
		})
		export class ChildComponent{ 
		      
		    @ContentChild("headerContent", {static:false})
		    header: ElementRef|undefined;	

		}

	здесь важно, что h3 тег помечен шаблонной переменной headerContent. именно на эту переменную ссылается декоратор @ContentChild

	static:false означает, что элемент будет доступен в хуке ngAfterContentInit.
	static:true означает, что элемент будет доступен в хуке ngOnInit.

=========================================================
стандартные валидаторы

  для template-driven форм в теге прописываются атрибуты: 

    required, 
    pattern, 
    maxlength, 
    minLength
    email.

    кастомные валидаторы пишутся как директива, которая реализует интерфейс NG_VALIDATORS, и тоже прописываются в html-тег.

  для reactive форм стандартные валидаторы живут в классе Validators:

    Validators.required
    Validators.maxLength
    Validators.minLength
    Validators.pattern
    Validators.min
    Validators.max
    Validators.email

    асинхронные валидаторы прописываются третьим аргументом, простые - вторым. кастомные валидаторы представляют из себя функцию, которая принимает поле и возвращает null для успешно пройденной валидации и объект с ошибкой для неуспешно пройденной валидации.

=========================================================
CVA это преобразователь html-элемента, соответствующего ангуляр-компоненту в поле реактивной формы.

	в первую очередь нужно создать компонент, в котором будут описаны правила и вид кастомного поля формы. затем прописать его в imports модуля. после этого в шаблоне родительского компонента использовать тег созданного ранее компонента, связанный с конфигом формбилдера через атрибут formControlName="hello".

	кастомный компонент будет реализовывать интерфейс NG_VALUE_ACCESSOR и, возможно, NG_VALIDATORS. важно понимать, что валидатор можно использовать или в кастомном компоннете или в родительском компоненте(стандартный или самописный). одновременно их использовать нельзя.

	в кастомном компоненте определить свойство, которое с одной стороны будет связано с элементом формы, а сдругой с отображением кастомного элемента. связь (установка/синхронизация) осуществляется при помощи методов writeValue/onChanged соответственно.

	при изменении значения нужно повесить обработчик в элемент шаблона поля. этот обработчик должен делать 2 вещи: 1. изменять локальную переменную, 2. пинать onChange() чтобы информация о новом значении всплывала в объект формы.

	validate срабатывает каждый раз когда меняется значение поля в шаблоне. если с валидацией всё ок, то он возвращает null, иначе произвольный объект (этот объект помещается в объект формы, в errors конкретного поля).

		@Component({
		  selector: 'hello',
		  template: `
		    <button (click)="minus()">minus</button>
		    <button (click)="plus()">plus</button>
		    {{ value }}
		  `,
		  providers: [
		    {
		      provide: NG_VALUE_ACCESSOR,
		      useExisting: forwardRef(() => HelloComponent),
		      multi: true,
		    },
		    {
		      provide: NG_VALIDATORS,
		      useExisting: forwardRef(() => HelloComponent),
		      multi: true,
		    },
		  ],
		})
		export class HelloComponent implements ControlValueAccessor, Validator {
		  value: number;

		  validate() {
		    return this.value > 0 ? null : { positive: true };
		  }

		  onChange: any = () => {};
		  onTouch: any = () => {};

		  registerOnChange(fn: any) {
		    this.onChange = fn;
		  }

		  registerOnTouched(fn: any) {
		    this.onTouch = fn;
		  }

		  writeValue(input: number) {
		    this.value = input;
		  }

		  minus() {
		    this.value -= 1;
		    this.onChange(this.value);
		  }

		  plus() {
		    this.value += 1;
		    this.onChange(this.value);
		  }
		}



	в родителе:

	    this.form = this.fb.group({
	      name: [null, [Validators.required]],
	      email: [null, [Validators.required, Validators.email]],
	      buttons: [2],
	      input: [null, [Validators.pattern('^asd$')]],
	    });

	тут больше:
	https://stackblitz.com/edit/angular-ivy-iecnm4?file=src/app/hello.component.ts

=========================================================
CVA validation

вешать валидаторы на cva-поле можно двумя способами:

	1. в родительском компоненте как обычный кастомный валидатор

		export class AppComponent {
		  myForm: FormGroup = new FormGroup({
		    login: new FormControl(null, Validators.required),
		    name: new FormControl(null, Validators.required),
		    isAdmin: new FormControl(false, this.ValidateAdmin),
		  });

		  ValidateAdmin(control: AbstractControl) {
		    if (control.value === false) {
		      return { ValidateAdminError: true };
		    }
		    return null;
		  }
		}	

	2. внутри cva-компонента. в этом случае при любом изменении срабатывает метод validate. он как и кастомный валидатор должен вернуть или null, или объект с ключом ошибки.

	  validate({ value }: FormControl) {
	    if (!value) {
	      return {
	        invalid: true,
	      };
	    }

	    return null;
	  }	

	в этом случае нужно не забыть прописать провайдер:

	    {
	      provide: NG_VALIDATORS,
	      useExisting: HelloComponent,
	      multi: true,
	    },	

	в шаблоне проверять валидацию так:

		*ngIf="myForm.get('isAdmin').hasError('invalid')"


    тут больше:
    https://stackblitz.com/edit/angular-ivy-sgaslf?file=src/app/hello.component.ts


	setDisabledState() срабатывает каждый раз когда из родителя поле делаю disabled/enabled. в этот обработчик можно поместить полезное действие, например, чтобы cva-поле дизейблилось изнутри(извне его задизейблить не получится)


	-------------

	метод validate срабатывает каждый раз. но если форма иметт вложенную структуру (например formArray), то события валидации будут всплывать до родительского уровня. в этом случае нужно реализовать метод registerOnValidatorChange так:

		  ngOnInit(): void {
		    this.form.valueChanges.subscribe(() => {
		      this.onValidationChange();
		    });
		  }

		  onValidationChange: any = () => {};

		  validate({value}: FormGroup): ValidationErrors | null {
		    return value.every(control => control.valid) ? null : {deviations: {valid: false}};
		  }

=========================================================
что такое control value accessor?

	CVA позволяет кастомный компонент связать с элементом реактивной формы и наладить двустороннюю связь между ними.

	в элементы input, select и т.д. CVA встроен изначально. но можно сделать рейтинг из 5 звёзд и привязать количество звёзд к полю реактивной формы:

	    this.galaxyForm = new FormGroup({
	      galaxy: new FormControl({value: null, disabled: false}, [Validators.required]),
	      rating: new FormControl({value: 2, disabled: true}, [Validators.required]),
	      name: new FormControl({value: null, disabled: false}, [Validators.required])
	    });

	------------
	в коде выше значение rating инициализируется двойкой. соответственно в кастомном компоненте сработает:

	  writeValue(val) {
	    console.log('writeValue', val)
	    this._value = val;
	  }

	 таким образом срабатывает связь от формы к компоненту.

	------------
	в кастомном компоненте есть обработчик события (click). после того как пользователь кликнет на звезду, он сработает:

	  setRating(star: any) {
	  	this._value = star.stars;
	  	this.ratingText = star.text
	  	this.onChanged(star.stars);
	  }

	  public _value: number;
	  onChanged: any = () => {}
	  
	  registerOnChange(fn: any){
	    this.onChanged = fn
	  }

	в результате значение star.stars будет отправлено в реактивную форму(при этом также сработает writeValue).

=========================================================
что такое сервис?

	сервис это класс, которые хранит состояние или используется в качестве поставщика данных. также он используется как канал связи между сильно разнесёнными в иерархии компонентами. он может быть определён на уровне:
		приложения(синглтон),
		модуля(синглтон),
		компонента(НЕ синглтон)

	все сервисы регистрируются инжектором, который делится на несколько уровней. если компоненту нужен сервис, то поиск начинается с нижнего уровня и идёт выше. но этот порядок может быть изменён при помощи декораторов @SkipSelf() и т. д.

=========================================================
инжектор сервисов 

	это фабрика, которая отдаёт объекты сервисов для заранее определённых частей приложения. существует разные уровни: компоненты, модули, роуты, платформа и т.д.

	если существует один сервис и два невложенных компонента ижектируют его отдельно на уровне компонета, то инжектор создаст 2 экземляра сервиса, каждый из которых будет независим. то есть содержать свой уникальный набор данных.

	если сервис объявлен на уровне модуля, то каждый компонент этого модуля получает один и тот же экземпляр сервиса (синглтон). то есть будет работать с одними тем же набором данных.

	поиск объекта сервиса происходит сначала в дереве компонентов в зависимости от html-вложенности их. если ничего не нашлось, то поиск начинает производиться в роуте и в модулях, к которым принадлежат эти компоненты. 
	 
	этот порядок можно изменить при помощи модификаторов Optional, Skip, SkipSelf, Host. причём последний из них актуален только для директив, которые, как известно, не имеют host-элемента.
	 
	существует механизм, при помощи которого можно подменить объект сервиса на уровне инжектора при помощи:
		useClass,
		useExisting,
		useValue ,
		useFactory 	

=========================================================
декораторы DI:

	@Optional говорит о том, что инжектирование сервиса не обязательно. то есть инжектор может не возвращать экземпляр, если он формируется динамически:

		@Injectable()
		export class OptionalS {}

		@Component({
		  selector: 'my-app',
		  template: '<h1> if you see me so app not break</h1>',
		  providers: [OptionalS], // dynamic providers
		})
		export class AppComponent {
		  constructor(@Optional() service1: OptionalS) {}
		}

		или же @Optional может пригодиться в ситуации когда @Self ничего не нашёл в текущем компоненте, тогда @Optional предотвратить выброс исключения.

	@Self говорит DI, чтобы искать зависимость только провайдерах своего компонента.

		@Component({
		  providers: [], <=== искать тут, в данном случае не найдет и выкинет ошибку
		})
		export class HelloComponent {
		  constructor(
		    @Self() private _tyapk: TyapkService,
		  ) {}
		}

	@SkipSelf говорит DI, чтобы искать зависимость исключая провайдеры текущего компонента.

		@Component({
		  providers: [TyapkService], <=== не искать тут, в данном случае не найдет и выкинет ошибку
		})
		export class HelloComponent {
		  constructor(
		    @SkipSelf() private _tyapk: TyapkService,
		  ) {}
		}		

	@Host используется для директив. зависимость ищется в директиве и в компоненте, который использует эту директиву. другими словами, поиск зависимости ограничивается одним уровнем вверх.

=========================================================
@Injectable
	
	Данный декоратор гарантирует, что класс можно инжектировать как зависимость.

=========================================================
change detection

	обнаружение изменений это сравнение значений в компоненте и в шаблоне. после срабатывания очередного цикла обнаружения изменений отображающиеся в шаблоне значения становятся актуальными. в общем, этот процесс состоит из двух подпроцессов:

		1. синхронизация значений компонента с привязками шаблонов. она происходит один раз при первой загрузке приложения.

		2. повторный запуск синхронизации при наступлении каких-нибудь событий(движение курсора мыши, выполнение асинхронного запроса и т.д.). важно понимать, что этот подпроцесс можно отключить, если выпилить ngZone в конфиге bootstrapModule.

	компоненты построены в виде дерева. когда в одном из компонентов происходит событие, то процесс сравнивания значений в компоненте и в шаблоне стартует во всeх компонентах приложения (даже в соседних). и этот процесс идёт от родительских компонентов к дочерним.	

	компонент и его потомков можно выключить из этого процесса, если включить стратегию onPush. в этом случае выключенный компонент и его потомки(но не onPush-потомки) будут проверяться только если:

		1. Изменение значения @Input (сравнение идет по ссылке).
		2. Наступление события, на которое подписались в шаблоне через () или в коде через @HostListener. причём подписка может быть даже вида: (click)="null"
		3. Проверка запущена руками — например, через методы ChangeDetectorRef.	
		4. сработает asyncPipe

		при этом если в контролере отработает subscribe и присвоит результат локальной переменной, то шаблон не будет выводить 	значение этой переменной (*). однако, если в этом шаблоне рядом выводится другое значение async pipe, то шаблон будет выводить значение переменной *. это происходит потому что async pipe пинает цикл обнаружения изменений.

		важно понимать, что если observable сработает в дочернем компоненте, то change detection не сработает. но если  observable сработает в родительском компоненте и результат будет передан в дочерний компонент при помощи синтаксиса [], то change detection сработает:

			https://stackblitz.com/edit/stackblitz-starters-hsqhyw?file=src%2Fapp%2Fapp.component.ts

	обнаружение изменений в текущем компоненте можно отключить при помощи detach. в этом случае данные не спускаются в более нижние компоненты (вернее, спускаются, но не отображаются в шаблоне).

	его можно включить при помощи reattach, но если родительский отключен, то это не будет иметь эффекта. 

	markForCheck позволяет единоразово включить обнаружение изменений во всех родительских компонентах(но не в потомках).

	detectChanges единоразово запускает обнаружение для текущего компонента и его потомков. а затем запускает проверку изменений во всём дереве компонентов всего приложения(tick). лучше не использовать по соображениям сохранения производительности.

	есть возможность запустить обнаружение изменений во всём дереве при помощи метода ApplicationRef.tick()

	При помощи объекта ChangeDetectorRef можно получить доступ к функционалу обнаружения изменений.

=========================================================
ViewEncapsulation 

  encapsulation: ViewEncapsulation.Emulated, 
  encapsulation: ViewEncapsulation.None, 
  encapsulation: ViewEncapsulation.ShadowDom, 

  отвечает за использование механизма работы со стилями. 

  по умолчанию он равен emulated. в этом случае стили, прописанные в css-файле компонента ограничены компонентом. это достигается добавлением уникального атрибута к тегам компонента и последующим использовании этого атрибута при формировании css-селекторов.

  none отключает изоляцию стилей компонентов. таким образом встили из всех компонентов перемещаются в глобальную область. это чревато кофликтами.

  ShadowDom использует shadowDOM. то есть все стили изолируются в shadowDOM хост-элемента.

  существует возможность в режиме emulated выборочно отключить изолирование. для этого для определённого селектора используется ::ng-deep. это означает, что на вложенные селекторы не вешается уникальный атрибут:

		::ng-deep {
			p {
		    color: red;
		  }
		}  

		обычно такой подход актуален для сторонних бибилиотек.

		нужно оборачивать ::ng-deep в :host или другие селекторы, на которых имеется инкапсуляция. Это ограничит распространение глобального стиля только данным компонентом.

  всегда существует глобальный файл стилей, но пользоваться им нужно осторожно. обычно в него выносят стили, которые переиспользуются во многих местах приложения.

	важно полнимать, что css-файлы загружаются лениво. то есть правила из css-файла начнут действовать только после того как в компоненте отработает ngOnInit(). тут больше: https://upmostly.com/angular/the-dangers-of-ng-deep-bleeding

=========================================================
changeDetectorRef

	это класс, который предоставляет доступ к функциональности обнаружения изменений. после того как пользователь инжектировал его, он может включать/отключать обнаружение изменений в любой части дерева компонентов. а так же вручную единоразово запускать обнаружение изменений вверх или вниз.

=========================================================
ngZone

  создаёт отдельный контекст выполнения для определённого участка кода. появляется возможность выполнять хуки для этого участка кода, в частности для начала выполнения, для появления исключения, для конца выполнения. важно то, что этот участок кода может содержать асинхронные вызовы. таки образом, например, можно измерить время выпонения.

  для ангуляра использование зон особенно важно потому что эта библиотека патчит все асинхронные события. в результате после завершения работы каждого события можно запускать обнаружение изменений.

  иногда это нежелательно по соображениям производительности. в этом случае участок кода можно умышленно запускать вне зоны. для этого используется метод runOutsideAngular().

=========================================================
Динамические компоненты

  это компоненты которые создаются когда приложение уже собрано и пользователь с ним работает. например это тултипы, модальные окна. создание происходит по шаблону, для этого нужно создать компонент. затем в целевом шаблоне прописать слот в виде тега, который помечен шаблонной переменной:

    <ng-template #dynamic></ng-template>

  в целевом контроллере нужно через @ViewChild получить доступ к элементу #dynamic:

    @ViewChild('dynamic', { read: ViewContainerRef })
    private viewRef: ViewContainerRef;

    ViewContainerRef содержит в себе ссылку на контейнер, а также методы, которые позволяют создавать компоненты.

  и затем по событию выполнить на  нём createComponent:

    this.viewRef.createComponent(DynamicComponent);

  удаление динамического компонента делается так:

    this.viewRef.clear();

  Чтобы избежать утечек памяти, стоит уничтожить компонент после использования

	ngOnDestroy() {
	 this.componentRef.destroy(); 
	}

=========================================================
ngTemplateOutlet

  это слот для вставки шаблона ng-template. вставлять можно многократно в пределах страницы. то есть это динамический шаблон

    <ng-container *ngTemplateOutlet="loading"></ng-container>
    <ng-template #loading>
        <div>Loading...</div>
    </ng-template>    

  в этот динамический шаблон можно преедавать переменные:

    <ng-container *ngTemplateOutlet="loading; context: { a: 123 }"></ng-container>
    <ng-template #loading let-variable="a">
        <div>{{ a }}</div>
    </ng-template>

=========================================================
createEmbeddedView

  работает подобно ngTemplateOutlet, только не из шаблона, а из контроллера. например, в шаблоне есть 2 ng-template:

      <ng-template #templateRef>
        <ul>
          <li>List Item 1</li>
          <li>List Item 2</li>
        </ul>
      </ng-template>
      <div #viewContainerRef class="testing">
      </div>  

  задача в том, чтобы #viewContainerRef был слотом для #templateRef. для этого в контроллере через @ViewChild получаем доступ к обоим шаблонам:

    @ViewChild('viewContainerRef', { read: ViewContainerRef, static: true }) viewContainerRef: ViewContainerRef;
    @ViewChild('templateRef', { read: TemplateRef, static: true }) templateRef: TemplateRef<any>;  

  и затем в OnInit() производим вставку:

    this.viewContainerRef.createEmbeddedView(this.templateRef);

  в результате под разметкой #viewContainerRef будет располагаться разметка #templateRef

  https://stackblitz.com/edit/angular-view-container-ref-create-embedded-view?file=src/app/app.component.ts

=========================================================
способы улучшить производительность.

	1. уменьшить количество http-запросов и используемых библиотек.
	2. применять различные алгоритмы сжатия на этапе сборки при помощи webpack
	3. использовать мемоизацию
	4. использовать стратегию OnPush
	5. использовать пагинацию
	6. использовать pure pipes

		потому что чистый пайп это синглтон, он создаётся один раз. и запускает метод transform только если входной аргумент изменился. 

		а грязные пайпы создаются каждый раз при использовании в шаблоне.

	7. использовать опцию trackBy для директивы *ngFor
	8. использовать веб воркеры для вычисления функций в другом потоке
	9. лениввая загрузка позволяет загружать ресурсы только когда они необходимы пользователю

		нужно в массиве роутов использовать loadChildren: () => import('./lazy-file').then(m => m.LazyComponent)

	10. предварительная загрузка 

		фоновая загрузка lazy-модулей, по которым пользователь пока не ходил

			imports: [
			    BrowserModule,
			    FormsModule,
			    RouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules }),
			],	

		фоновая загрузка lazy-модулей, которые связаны с текущей страницей

			imports: [
			    BrowserModule,
			    FormsModule,
			    RouterModule.forRoot(routes, { preloadingStrategy: QuicklinkStrategy }),
			],		

	11. отключение компонентов от changeDetection при помощи detach()	


-----

	lazy load это запрос части бандла по наличию перехода пользователя на роут. в случае автономныого компонента все зависимости этого компонента будут находиться в этом бандле тоже.

	@defer это запрос части бандла на основе анализа составляющих страницы. то есть какого-то блока может не быть, например, куска в виде аудио или видео или текста. в этом случае код этого куска выделяется в отдельную часть бандла.

	таким образом lazy load отвечает за ленивый вывод страницы полностью, а @defer отвечает за ленивый вывод частей страницы.



=========================================================
angular.json

  это файл конфигурации проекта, в котором содержатся информация о:

    включении оптимизаций(минификация стилей, встраивание шрифтов в index.html),
    путь к статическим файлам,
    путей к файлам стилей,
    путей к файлам сторонних библиотек,
    путей по которому будет находиться билд,
    путь к index.html,
    путь к tsconfig.app.json,
    директория с файлами всего проекта,
    тип проекта (приложение или библиотека),
    префикс, который используется для компоннетов и директив,



=========================================================
enviroments

  это каталог, в котором содержатся файлы с переменными окружения для разных сред. (продакшн и разработка). 

  при сборке билда можно указывать какой файл окружения использовать: 

    ng build или ng build --prod 

  также можно создать ещё один файл окружения и через angular.json подменить действующий:

    "vasya": {
      "fileReplacements": [
        {
          "replace": "src/environments/environment.ts",
          "with": "src/environments/environment.vasya.ts"
        }
      ]
    }    

  вызывать так:

    ng build --configuration=vasya
    ng build -c vasya

  итак, заменять файл с переменными окружения можно:

  	1. на лету (через команду консоли)
  	2. через конфиг (в angular.json сделав replace)


	пример файла:

		export const environment = {
		  production: false,
		  apiUrl: 'http://example.com/api/',
		};

	использовать так:

	import { environment } from 'src/environments/environment';
	url = environment.apiUrl;   


=========================================================
Webpack 
  
  это популярный инструмент для сборки модулей в один файл. в webpack.config.ts указываются пути, по котрым будут располагаться собранные файлы стилей, скриптов. а так же указывается файл, с которого начнёт работу приложение.

  создаётся appComponent, 
  затем он прописывается в appModule, 
  затем appModule прописывается в main.js,
  main.js прописывается в webpack.config.ts как точка входа в приложение

  кроме того в webpack.config.ts указываются зависимости для разработки и для приложения. при использовании определённой команды(которая тоже прописана в конфиге) эти зависимости скачиваются и помещаютсяв node_modules.

  в блоке resolve указываются расширения, которые можно не писать в импортах.

  результат работы webpack помещается в каталог build.

=========================================================
pipe

  отправляет параметры, которые указываются через двоеточине. их может не быть вообще. 

  если пайп самописный, то первым параметром всегда будет значение, которое находится слева от вертикальной черты, а перечисляемые через двоеточие будут идти за ним.

=========================================================
=========================================================
отличие promise от observable

  observable это многократный промис. его можно отменить. он выполняется только после подписки на него, то есть ленив. observable может использовать много операторов для обработки получаемых данных.

=========================================================
использование мультикастинга для уменьшения количества запросов в случае с async pipe

	import { Component } from '@angular/core';
	import { Observable } from 'rxjs';
	import { ajax } from 'rxjs/ajax';
	import { map, shareReplay } from 'rxjs/operators';

	@Component({
	  selector: 'app-root',
	  templateUrl: './app.component.html',
	  styleUrls: ['./app.component.css'],
	})
	export class AppComponent {
	    users$: Observable<any> = ajax(
	      'https://jsonplaceholder.typicode.com/users'
	    )
	    .pipe(
	      map((res: any) => res?.response),
	      shareReplay()
	    );
	}


	<div *ngIf="users$ | async">
	  <li *ngFor="let item of users$ | async">
	    {{ item.name }}
	  </li>

	  <li *ngFor="let item of users$ | async">
	    {{ item.name }}
	  </li>

	  <li *ngFor="let item of users$ | async">
	    {{ item.name }}
	  </li>
	</div>


=========================================================
query params

	можно передавать так:

		goProducts() {
		  this.router.navigate(
		    ['/products'],
		    { queryParams: { order: 'popular' } }
		  );
		}		

		// http://localhost:4200/products?order=popular

	но при переходе на следующую страницу (products -> users) они не сохранятся в url. можно сделать так чтобы они сохранились:

		goUsers() {
		  this.router.navigate(
		    ['/users'],
		    { queryParamsHandling: 'preserve' }
		  );
		}	

		// http://localhost:4200/users?order=popular

	или можно сделать так чтобы параметры и сохранялись, и добавлялись:

		goUsers() {
		  this.router.navigate(
		    ['/users'],
		    {
		      queryParams: { filter: 'new' },
		      queryParamsHandling: 'merge' }
		    );
		}	

		// http://localhost:4200/users?order=popular&filter=new


---------------------
всё вышеперечисленное можно делать не только из компонента, но и из шаблона:

	<a
	   [routerLink]="['/users']"
	   [queryParams]="{ filter: 'new' }"
	   queryParamsHandling="merge"
	>
	  Users
	</a>

=========================================================
подписаться на изменения query-параметров можно так:

	// http://localhost:4200/products?order=popular
  ngOnInit() {
    this.route.queryParamsHandling	
      .filter(params => params.order)
      .subscribe(params => {
        console.log(params); // { order: "popular" }
      }
    );
  }

  просто получать query-параметры можно так:

		param1: string;
		param2: string;
		constructor(private route: ActivatedRoute) {
		    console.log('Called Constructor');
		    this.route.queryParams.subscribe(params => {
		        this.param1 = params['param1'];
		        this.param2 = params['param2'];
		    });
		}


=========================================================
анимации

	можно пометить элемент директивой анимации и чередовать состояния:

		<div [@fade]=" show ? 'collapse' : 'expanded'">

	  animations: [
	    trigger('fade', [			// имя директивы
	      state(
	        'collapse',				// имя состояния
	        style({...})
	      ),
	      state(
	        'expanded',				// имя состояния
	        style({...})
	      ),
	      transition('collapse => expanded', [...]),		// характеристики перехода состояний
	      transition('expanded => collapse', [...]),		// характеристики перехода состояний
	    ]),
	  ],	

	  живой пример: https://stackblitz.com/edit/angular-animation-enter-leave-dom-solution-test-lcub4j?file=src/app/app.component.ts

	есть возможность повесить анимацию на хост компонента:

		@HostBinding('@fade')
		public myStatusExp;

	отслеживать события на анимируемом элементе можно так:

		(@fade.start)="animationStarted($event)"
		(@fade.done)="animationDone($event)"	

	можно обойтись без state:

    trigger('todoAnimation', [
       transition(':enter', [					// момент появления элемента в DOM
          style({ height: 0 }),				// перед стартом
          animate('0.3s ease-in', style({ height: '*' }))		// после старта анимации появления
       ]),
       transition(':leave', [					// момент удаления элемента из DOM
          animate('0.3s ease-out', style({ transform: 'scale(0)' })) 		// после старта анимации удаления
       ]),
    ])

  анимация дочерних элементов будет заблокирована. 

-------------------

Web Animations API

	позволяет работать с CSS-анимацией средствами JS. то есть у каждого элемента в DOM есть метод animate:

		const el = document.getElementById('cube');
		console.log(el);
		console.log('animate' in el);   // true	

	этому методу преедаётся объект, эмулирующий @keyframes и задающий повторяемость:

		document.getElementById('cube').animate(
		    cubeRotating,
		    cubeTiming
		)	

		let cubeRotating = [
		    {transform: 'rotate(0deg)', backgroundColor: 'pink'},
		    {backgroundColor: 'purple', offset: 0.3},
		    {transform: 'rotate(180deg)', backgroundColor: 'pink'}
		]	

		let cubeTiming = {
		    duration: 1000,
		    iterations: Infinity
		}	

=========================================================
tree shaking 

	включается, если сервис подключать через декоратор:

		@Injectable({
		  providedIn: 'root',
		})	

	если же сервис подключать через модуль, то tree shaking автоматически не включается.

=========================================================
если модуль подключен как lazy loaded, то сервисы, экспортируемые из него в lazy и в жадные модули, не являются синглтонами.

тут больше: https://www.youtube.com/watch?v=PU_xpHxZkrE&list=PLX7eV3JL9sfk0tbUkZwGCD1Y-kJ05NvOR&index=3&ab_channel=DecodedFrontend

=========================================================
viewProviders

	это массив providers, который не виден сущностям, вставленным через ng-content, но виден сущностям, вставленным через тег хоста. имеется в виду видимость когда поиск сервиса идёт по цепочке от дочернего компонента к родительским.

	больше тут: https://stackblitz.com/edit/angular-view-providers-example1?file=src%2Fapp%2Fchild.component.ts
	и тут: https://www.tektutorialshub.com/angular/viewproviders-in-angular/

	другими словами, мы можете встраивать в шаблон компонент как хост-тег(viewChild) и как проекцию(contentChild). если после этого мы начнём искать сервис из компонента, который встроили, то в родительской иерархии проецированным компоннетам не будут доступны сервисы, зарегистрированные через viewProviders. причём это правило выполняется для потомков любого уровня.

	другими словами, viewProviders это ограничение видимости сервисов для процированных компонентов.

	---------------

	в следующем примере существует иерархия компонентов: 

		my-app -> app-in1 -> app-deep -> app-deeper

		здесь: 

			my-app  		это viewChild
			app-in1 		это viewChild
			app-deep  	это contentChild
			app-deeper 	это contentChild

		сервис зарегистрирован в app-in1 через viewProviders. следовательно app-deep и app-deeper не могут вывести результаты этого сервиса через console.log()

		однако, если сервис в app-in1 зарегистрировать через providers, то app-deep и app-deeper смогут вывести результаты этого сервиса через console.log().

		при этом, если дополнительно зарегистрировать сервис в my-app через providers, то результаты сервиса будут доступны всем потомкам всегда потому что поиск зависимостей идёт по инжектору снизу вверх.

		важно то, что viewProviders не влияет на отрисовку ng-content. он влияет только на доступность сервисов.

		ссылка на пример: https://stackblitz.com/edit/at-ng-14-router-r3k4dm?file=src%2Fapp%2Fin1%2Fin1.component.ts

=========================================================
route providers

	недавно в ангуляре появился ещё один уровень инжектора - это инжектор роутера. он располагается между node injector и root injector(injectable decorator and module injector)

=========================================================
componentless router

	это добавление прослойки в виде path: '', которая технически не вносит никакого изменения в поведение роутера, но позволяет в конфиге роутера группировать составные части чтобы удобнее было применять гарды.

	это може пригодиться, если мы имеем на одном уровне несколько роутов, каждый из которых проверяет аутентификацию пользователя. вместо того чтобы много раз повторять вызов canActivate, можно сгруппировать роуты при помощи безкомпонентного роутинга и на верхнем уровне только один раз прописать canActivate



=========================================================
именованная маршрутизация

	роут содержит состояние. под ключом по умолчанию хранится состояние основного роута. но можно хранить в других ключах состояние дополнительных роутов, которые выводятся в скобках: 

		https://stackblitz.io/first(aside:money)

	для основого роута нужен тег: 

		<a routerLink="first" routerLinkActive="active">first</a>
		<router-outlet></router-outlet>

	для дополнительного роута нужен тег: 

		<a [routerLink]="[{ outlets: { aside: 'weather' } }]">clear</a>
		<router-outlet name="aside"></router-outlet>

	пример конфига роутов:

	  { path: '', redirectTo: '/first', pathMatch: 'full' },
	  { path: 'first', component: FirstComponent },
	  { path: 'second', component: SecondComponent },
	  { path: '', component: MoneyComponent, outlet: 'aside' },
	  { path: 'money', component: MoneyComponent, outlet: 'aside' },
	  { path: 'weather', component: WeatherComponent, outlet: 'aside' },		

	например, есть набор страниц, сбоку каждой из которых висит или виджет погоды, или виджет денег (зависит от того какую ссылки кликнул пользователь). состояние этого виджета хранится в скобочной части url и не зависит от смены основных страниц.

	живой пример: https://stackblitz.com/edit/angular-router-named-outlet-ftmv7f?file=src%2Fapp%2Fapp-routing.module.ts

=========================================================
custom title strategy

	для каждого роута можно прописать title. после этого на каждой странице начнёт отрабатывать класс TitleStrategy, который будет брать значение title из роута и выводить его в заголовке вкладки. однако в корневом модуле при помощи частного провайдера этот сервис можно подменить:

	  providers: [
	    {
	      provide: TitleStrategy,
	      useClass: SiteNamePageTitleStrategy
	    }
	  ]	

	здесь SiteNamePageTitleStrategy унаследуется от TitleStrategy так:

		@Injectable()
		export class SiteNamePageTitleStrategy extends TitleStrategy {
		  constructor(private title: Title) {
		    super();
		  }

		  updateTitle(routerState: RouterStateSnapshot) {
		    const title = this.buildTitle(routerState);		// получаем текущий title
		    console.log(title);
		    if (title !== undefined) {
		      this.title.setTitle(`${title} - Duotify Inc.`);		// устанавливаем обновлённый title
		    } else {
		      this.title.setTitle(`Home - Duotify Inc.`);
		    }
		  }
		}	


	теперь когда через роут мы будем передавать или не передавать title, то будет отрабатывать метод updateTitle() класса SiteNamePageTitleStrategy

		const routes: Routes = [
			{
				path: 'address',
				component: AddressComponent
			},
			{
				path: '',
				redirectTo: '/country',
				pathMatch: 'full'
			},
			{
				path: '**',
				component: PageNotFoundComponent,
				title: 'Page Not Found'
			}
		]; 	

	тут больше: https://www.concretepage.com/angular/angular-router-title-and-titlestrategy

=========================================================
title для динамических роутов

	если имеем вложенный роут с параметром, например, есть список пользователей, каждый элемент которого ведёт на профиль пользователя. задача в том, чтобы в тайтле вкладки браузера присутствовало имя пользователя. для этого используем резолвер:

		const routes: Routes = [
		  { path: '', component: UsersContainerComponent },
		  { path: ':id', component: UserComponent, title: UserTitleResolverService }
		];


		class UserTitleResolverService implements Resolve<string> {

		  constructor(private userLoader: UserLoaderService) { }	// это тривиальный сервис для получения объекта пользователя

		  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): string | Observable<string> | Promise<string> {
		    return this.userLoader.loadUser(route.paramMap.get('id')!).pipe(		// здесь id это то же самое, что id в конфиге роута
		      pluck('name'),
		      map(name => `User - ${name}`)		// здесь возвращаем обновлённый тайтл
		    )
		  }
		}

=========================================================
что такое jit и aot?

	AOT или Ahead-of-Time – 

		вариант компиляции приложения, которая выполняется один раз при сборке приложения, то есть перед рантаймом. в этом случае создаётся файл бандла, который можно закинуть на хостинг. 

		этот файл не включает map-схемы, из него удалены неиспользуемые участки кода, имена функций сокращениы, код минифицирован. в результате бандл меньше весит и приложение отрисовывается быстрее.

	JIT 

		выполняется каждый раз при запуске приложения при помощи ng serve. компиляция происходит частями во время рантайма по мере того ка пользователь обращается к разным частям приложения. при плохом интернет-соединении этот вариант может оказаться более выгодным чем AOT. но он более уязвим для атак типа XSS.

		во время рантайма могут произойти ошибки в шаблоне.

	тут больше: 
		https://www.geeksforgeeks.org/what-is-aot-and-jit-compiler-in-angular/ 
		https://www.code-sample.com/2023/02/aot-vs-jit-angular-compilation.html		

=========================================================
css-переменные 

	позволяют создать глобальные значения для стилей. для этого нужно в style.scss:

		:root {
		  --test: #f00;
		}	

	в шаблоне компонента:

		<div class="z">123</div>

	в файле стилей компонента:

		.z {
		  background: var(--test);
		}

=========================================================
динамические реактивные формы
	
	суть их в том, что все поля описываются в конфиге, которые представляет из себя массив объектов. каждый из этих объектов описывает поле и является наследником базового класса поля.	конфиг передаётся в цикл шаблона и тот отрисовывает поля на основе ngSwitch. 

	таким образом можно на лету создавать большое оличество однотипных форм.

	живой пример: https://stackblitz.com/edit/qpsqrm?file=src%2Fapp%2Fdynamic-form-question.component.html

=========================================================
типизированные формы

	позволяют выявить ошибки и опечатки на этапе написания кода. например, будут подсвечены строки для ошибочного patchValue, addControl, get, reset и прочих подобных операций.

	для использования типизированных форм необходимо импортировань типы из пакета(не касается свежих версий):

		import { IFormGroup, IFormBuilder } from “@rxweb/types”;

	и затем приенить их к существующей реактивной форме:

		formGroup: IFormGroup<User>;
		formBuilder: IFormBuilder;

	живой пример: 

		https://stackblitz.com/edit/rxweb-types-strongly-typed-reactive-form?embed=1&file=src/app/app.component.ts

=========================================================
service locator

	это паттерн, который позволяет инжектировать сервисы не через конструктор:

		import {inject} from '@angular/core'

		export class BaseComponent {
		  public loader;
		  
		  constructor() {
		    this.loader = inject(LoadingService)
		  }

		  showLoading() {
		    this.loader.show();
		  }
		}	

		здесь нужно не забыть в массиве providers зарегистрировать сервис.

	при этом классы наследники будут иметь у нему доступ потому что он привязан к свойству класса. этот паттерн позволяет избежать использования super() в конструкторах наследников. 

	демо: https://stackblitz.com/edit/angular-15-starter-pack-ssnbzt?file=src%2Fapp%2Fapp.component.ts

	этот способ появился в 14 версии.

=========================================================
как в шаблоне автономного компонента выводить дочерний компонент?

	создать модуль и в нём объявить дочерний компонент, а также экспортировать. затем в импортировать этот модуль в автономный компонент.

	автономный:

		@Component({
		  selector: 'my-app',
		  standalone: true,
		  imports: [CommonModule, MyModule],
		  template: `
		    <h1>parent component!</h1>
		    <app-child></app-child>
		  `,
		})
		export class App {}

	дочерний:

		@NgModule({
		  imports: [CommonModule],
		  declarations: [ChildComponent],
		  exports: [ChildComponent],
		})
		export class MyModule {}

	// https://stackblitz.com/edit/stackblitz-starters-vys1z3?file=src%2Fmain.ts

	-------

	важно то, что если нужно standalone компонент подключить в модуль, то имя этого компонента нужно прописывать в блоке imports, а не в блоке decalrations:


		@NgModule({
		  imports: [
		    CommonModule,
		    SharedModule,
		    DeviationCreateGroupComponent,
		    DeviationUpdateGroupComponent,
		  ],

=========================================================
signals

	это альтернативный подход к обнаружению изменений:

		export class AppComponent{
			count = signal(0)
			double = computed(() => this.count() * 2);

			changeCount() {
				this.count.set(5)
			}
		}	

		здесь после утсановки новго значения, сигнал сам оповещает своих потребителей.

		при этом потребители могут быть завёрнуты в computed() и в effect().

		computed():

			выполняет операцию и возвращает результат. таким образом этот результат можно присвоить свойству:

				const counter = signal(0);
				const isEven = computed(() => counter() % 2 === 0);			

			computed действует аналогично combineLatest.

		effect():

			выполняет операцию. ничего не возвращает.

				@Component({
				  selector: 'my-app',
				  standalone: true,
				  imports: [CommonModule],
				  template: `
				    {{ fullName() }} <button (click)="setName('John')">
				      {{firstName()}} - {{lastName()}}
				    </button>
				  `,
				})
				export class App {
				  firstName = signal('Jane');
				  lastName = signal('Doe');
				  fullName = computed(() => `${this.firstName()} ${this.lastName()}`);
				  constructor() {
				    effect(() => console.log('Name changed:', this.fullName()));
				  }
				  setName(newName: string) {
				    this.firstName.set(newName);
				  }
				}			

	можно проверять поступающее в сигнал значение и сравнивать его с заданным значением. в результате возможно не присваивать новое значение при совпадении условия:

		const counter = signal<number | string>("0", (a, b) => a == b);
		// Не будет обновлено, и изменения не применятся
		counter.set(0);

	сигналы можно преобразовать в observables:

		from = signal('Hamburg');
		to = signal('Graz');

		from$ = toObservable(this.from);
		to$ = toObservable(this.to);	

=========================================================
	signal принимает 2 аргумента: 
	 
	    первый это начальное значение
	 
	    второй это функция сравнения в форме { equal: functionName }
	 
	таким образом эффект будет срабатывать только когда новое значение сравнится со старым через функцию сравнения и будет установлено, что новое значение отличается от старого. в любом случае функция сравнения возвращаетс true/false
	 
	    <h2>{{Product$() | json}}</h2>
	    <button (click)="setProduct()">Set Products</button>
	 
	    product : IProduct = {
	        Id:  "1",
	        Title:"Pen",
	        inStock: true,
	        Price : 100
	 
	    }
	 
	    setProduct(){
	       let p : IProduct = 
	          {
	            Id:"1",
	            Title:"Pen",
	            Price: 300,
	            inStock: true
	          }; 
	        this.Product$.set(p);
	    }    
	 
	    function signalEquality(a:IProduct, b: IProduct) {
	      if(JSON.stringify(a)=== JSON.stringify(b)){
	        return true;
	      }
	      return false; 
	    }
	 
	    Product$ = signal<IProduct>(this.product,{equal:signalEquality});
	 
	    productEffect = effect(() => {
	        console.log(this.Product$());
	    });
	 
	в данном примере несмотря на то, что значение product устанавливается точно такое какое была раньше, всё же эффетк будет срабатывать.

=========================================================
router inputs

	существует возможность через входные параметры компонента назначать гет-параметры из роута.

		RouterModule.forRoot([], {
			bindToComponentInputs: true 
		})	

		---

		const routes: Routes = [
		 {
		   path: "articles",
		   component: ArticleComponent,
		 },
		];

		---

		@Component({})
		export class ArticleComponent implements OnInit {
		  
		  @Input() articleId?: string; 
		  
		  ngOnInit() {
		  
		  }
		}		

		---

		http://localhost:4200/articles?articleId=001

		---

		но есть возможность использовать псевдонимы:

			http://localhost:4200/articles?id=001

			@Input('id') articleId?: string;		

=========================================================
required inputs

	есть возможность сделать инпуты обязательными. для этого в декораторе нужно указать опцию:

		@Input({ required: true }) name: string = '';


=========================================================
standalone projects

	существует возможность сделать проект на автономных компонентах, то есть без модулей:

		ng new --standalone

=========================================================
esBuild

	есть возможность ускорить сборку не только в режиме билда, но и в режиме разработки

	"architect": {
	   "build": {
	       "builder": "@angular-devkit/build-angular:browser-esbuild",
	       "options": {
	           ...
	       }
	   }

=========================================================
что нового в 16 ангуляре:

	1. сигналы
	2. генерация полностью автономного проекта
	3. присваивание гет-параметров инпутам без использования сервиса
	4. ускорить сборку в режиме разработки через esBuild
	5. обязательные инпуты
	6. 

=========================================================
если инпутов нет, то первым отработает ngOnInit, а не ngOnChanges
	
	?? проверить

=========================================================
когда пригодится changeDetectorRef?

	1. runOutsideAngular
	2. используем внешнюю библиотеку, которая ничего не знает про ngZone
	3. когда потомок меняет родителя уже после того как change detection отработало.

=========================================================
updateValueAndValidity()

		нужен чтобы программно запустить валидацию. это полезно когда мы в рантайме добавляем и удаляем валидаторы.
		

=========================================================
способы передачи данных в дочерний компонент:

	Reacting to changes from @Inputs
	Setting properties with @ViewChild
	Using BehaviorSubjects in services
	Using the Angular Router
	Using NgRx

=========================================================
dependency injection

	это способ, при помощи которого класс может получить зависимость, инстанс которой создаётся вне класса. то есть класс-компонент отдаёт инжектору имя класса-сервиса, инжектор формирует инстанс(со всеми требуемыми зависимостями) и возвращает инстанс.

	сам инжектор представляет из себя класс, который содержит набор сервисов в виде объекта. ключами этого объекта являются имена сервисов, а значениями этого объекта являются инстансы. также инжектор имеет метод, который получает имя класса-зависимости, по этому имени он извлекает из вышеописанного объекта нужный инстанс и возвращает его классу-компоненту.

=========================================================
в Input() можно использовать функцию transform, которая действует аналогично сеттеру. то есть при получении входного параметра сразу обрабатывает его:

	function characterNameUppercase(character: Character): Character {
	  return {
	    ...character,
	    name: character.name.toUpperCase()
	  }
	}
	    
	@Component({
	  standalone: true,
	  //...
	  template: `<h1>{{ character.name }}`
	})
	export class CharactersComponent {
	  @Input({ $required: true, transform: characterNameUppercase }) 
	  character!: Character;
	}

при этом существуют встроенные преобразователи в число или в булево значение.:

	export class ProductComponent {
	  @Input({ transform: booleanAttribute }) 
	  showDetails!: boolean;
	}


	export class ProductComponent {
	  @Input({ transform: booleanAttribute }) 
	  showDetails!: boolean;
	}



=========================================================
в 17 версии фреймворка появился альтенативный синтаксис для if-else, switch, for. 

	его можно использовать без импорта NgIf и прочих подобных директив:

		@if (streamingService === 'Netflix'){
		  <div>Peaky Blinders</div>
		} @else {
		  <div>Ted Lasso</div>
		}

	кроме того можно в цикле использовать плейсхолдер пустого блока, если массив цикла пустой:

		@for (streamingService of streamingServices; track stramingService) { // или track $index
		  <div>{{ streamingService }}</div>
		} @placeholder {
		  <div>No streaming services available</div>
		}

	также в цикле можно использовать инлайновый trackBy:

		@for (product of products; track product.id) { 
		 {{ product.title }} 
		}


=========================================================
что такое директива?

	свойства компонента, которые поступают через декоратор Input обрабатываются обработчикаи, которые находятся внутри компонента. но свойства компонента, которые поступают через директивы обрабатываются вне компонента. при этом чтобы компонент знал об этих внешних обработчиках(directives) их нужно привязать к компоненту:

		1. или через модуль, к которому относятся и директива и компонент
		2. или, если компонент автономный, непосредственно через импорты компонента. важно, что при этом способе директива тоже должна быть автономной.

	вот пример отключения автозаполнения полю ввода внешней библиотеки:

		@Directive({
		  selector: '[autoComplete]',
		})
		export class AutoCompleteDirective {
		  @Input() autoComplete = 'off';
		  constructor(private elementRef: ElementRef) {}

		  ngAfterViewInit() {
		    const input = this.elementRef.nativeElement.querySelector('input');
		    input.setAttribute('autocomplete', this.autoComplete);
		  }
		}


		<tui-input
		  autoComplete="off"
		  formControlName="testValue"
		  [tuiTextfieldCleaner]="true"
		  [tuiTextfieldLabelOutside]="true"
		  [tuiTextfieldSize]="'m'"
		>
		  enter text
		</tui-input>

		пример: https://stackblitz.com/edit/angular-hdvmao-6h1bkx?file=src%2Fapp%2Fapp.component.ts

	директива может предоставить доступ к своему инстансу элементам, на которых она используется:

		@Directive({
		  selector: 'input[type="password"]',
		  exportAs: 'passwordStrength',
		})		

	в шаблоне доступ к свойству директивы strength выглядит так:

		<input type="password" #evaluator="passwordStrength">
		@switch (evaluator.strength) {		

	@HostBinding связывает свойство html-элемента и свойство компонента:

		директива:

			@Directive({
			  selector: '[appColorized]'
			})
			export class ColorizedDirective {

			  constructor() { }

			  private fontWeight = "bold";
			     
			  @HostBinding("style.fontWeight") get getFontWeight(){
			      return this.fontWeight;
			  }

			  @HostBinding('style.backgroundColor') bg = "red"; 

			}

		шабллон компонента:

			<p appColorized>page2 works!</p>


=========================================================
standalone компонент Page4Component можно встроить в модульный роутинг:

app-routing.module.ts

	const routes: Routes = [
	  { path: 'page1', component: Page1Component },
	  { path: 'page2', component: Page2Component },
	  { path: 'page3', component: Page3Component },
	  {
	    path: "page4",
	    loadComponent: () =>
	      import("./pages/page4/page4.component")
	      .then((m) => m.Page4Component),
	  },
	];

	@NgModule({
	  imports: [RouterModule.forRoot(routes)],
	  exports: [RouterModule]
	})
	export class AppRoutingModule { }


app.module.ts:

	@NgModule({
	  declarations: [
	    AppComponent,
	    Page1Component,
	    Page2Component,
	    Page3Component,
	  ],
	  imports: [
	    BrowserModule,
	    AppRoutingModule,
	    Page4Component,
	  ],
	  providers: [],
	  bootstrap: [AppComponent]
	})
	export class AppModule { }


app.component.html:

	<nav>
	  <a routerLink="/page1" routerLinkActive="active">page1</a>
	  <a routerLink="/page2" routerLinkActive="active">page2</a>
	  <a routerLink="/page3" routerLinkActive="active">page3</a>
	  <a routerLink="/page4" routerLinkActive="active">page4</a>
	</nav>

	<router-outlet></router-outlet>


=========================================================
DomSanitizer

	позволяет вставлять контент через innerHTML, не удаляя из него потенциально опасный код. по умолчанию в ангуляре действет базовая защита от XSS. DomSanitizer позволяет её точечно отключить:

		@Component({
		  selector: 'app-root',
		  template: `
		    <!-- black text -->
		    <div [innerHTML]="htmlContent"></div>   
		    <!-- red text -->
		    <div [innerHTML]="trustedHtml"></div>   
		`,
		})
		export class HomeComponent {
		  trustedHtml: any;
		  htmlContent = `<h1 style="color:red">Hello World</h1>`;

		  constructor(private sanitizer: DomSanitizer) {
		    this.trustedHtml = this.sanitizer.bypassSecurityTrustHtml(this.htmlContent);
		  }
		}

		то же самое можно оформить в пайп: 

			<div [innerHTML]="someHtmlContent | safeHtml"></div> `


	шаблоны в ангуляре представляют из себя исполняемый код поэтому интерполяция очищена фреймворком:

		<p>{{htmlSnippet}}</p>

	но в случае использования нативного механизма интерполяция не очищена:

		<p [innerHTML]="htmlSnippet"></p>

------------

если нужно встроить в href урл, который приходит из непроверенного источника, то его нужно проверить так:

	<a class="e2e-trusted-url" [href]="trustedUrl">Click me</a>

	constructor(private sanitizer: DomSanitizer) {    
		this.dangerousUrl = 'javascript:alert("Hi")';    
		this.trustedUrl = sanitizer.bypassSecurityTrustUrl(this.dangerousUrl);  
	}	

=========================================================
Resource API

	это ещё один способ получать асинхронные данные на основе отслеживания сигналов. основное его преимущество в том, что он позволяет избежать написания шаблонного кода при получении статусов процесса (загружается, загружено, ошибка  и т.д.)

	по сути своей Resource API это обёртка над сигналом, котрая возвращает набор свойств:

		Value,
		Status,
		Error,
		isLoading.

	другими словами, Resource API, это сущность, которая принимает сигнал и возвращает обогащённый сигнал.

	Resource API имеет два основных метода:

		request

			в него помещается отслеживаемый сигнал

		loader

			в него помещается конкретное действие (чаще всего http-запрос), которое будет запускаться когда отслеживаемая сущность из request изменит своё значение. например:

				const id = signal(123)

				productResource = resource({
				    request: id,
				    loader: async () => {
				      let c = id();
				      return Promise.resolve({ name: 'Book', price: 100 * c });
				    }
				})		

			важно то, что в блоке loader выражение 	let c = id() не следит за сигналом и не является триггиром запуска блока loader


		по аналогии с computed() можно создать внешнюю функцию, которая будет следить за наличием изменений в productResource:

		    this.productResource.update((value: any) => {

		      if (value.price == 500) {
		        console.log('value if:', value);
		        return { ...value, price: 1 };
		      }
		      console.log('value', value);
		      return { ...value };
		    })	

	если в блоке request значение меняется слишком часто и при этом предыдущие запросы не успевают отработать до конца, то есть смысл отменять их по модели switchMap. для этого нужно использовать второй параметр fetch:

		productId: WritableSignal<number> = signal(1);
		  productApiResource = resource({
		    request: () => ({ id: this.productId() }),
		    loader: async (param) => {
		      const { id } = param.request as { id: number };
		      let url = `http://localhost:3000/products?id=${id}`;
		      return fetch(url, { signal: param.abortSignal }).then((res) => res.json() as Promise<Product[]>);
		    },
		  });	


	тут больше: https://www.telerik.com/blogs/getting-started-resource-api-angular


=========================================================
что такое package-lock.json?

	существует файл package.json в нём указаны зависимости, который устанавливаются командой npm install. в нём зависимости могут быть указаны неконкретно. например больше или равно определённой версии. таким образом после npm install установятся актуальный на тот момент времени версии.

	иногода, особенно в командной разработке, требуется у каждого разработчика установить строго определённые версии библиотек вне зависимости от состояния удалённых репозиториев на настоящий момент. для этого используется файл package-lock.json и команда npm ci.

	при этом, файл package-lock.json обновляется после запуска каждой команды npm install. но после npm ci этот файл не обновляется.


=========================================================
runInInjectionContext 

	ограничивает область видимости, в которой будет доступен серсис, взятый из инжектора.

	если мы инжектируем сервис через конструктор или через коренвой уровень ser = inject(ser), то этот сервис будет доступен во всём инстансе класса.

	при помощи runInInjectionContext мы может ограничить доступность сервиса блоком кода.

	пример доступного сервиса во всём инстансе класса:

		@Component({
		  selector: 'app-root',
		  template: `<button (click)="press()">press</butto`,
		})
		export class HomeComponent {
		  service = inject(FirstService);

		  press() {
		    console.log(this.service.getValue());
		  }
		}

	пример доступного сервиса только в методе press():

		@Component({
		  selector: 'app-second',
		  template: `
			<button (click)="press()">press second</button>
			<button (click)="pressOut()">press second out</button>
		  `,
		  styleUrls: ['./second.component.css'],
		})
		export class SecondComponent {
		  environmentInjector = inject(EnvironmentInjector);

		  press() {
		    runInInjectionContext(this.environmentInjector, () => {
		      const service = inject(FirstService);
		      console.log(service.getValue());
		    });
		  }

		  pressOut() {
		    // error
		    // console.log(service.getValue());
		  }
		}	

	сам сервис:

		export class FirstService {
		  getValue() {
		    return [1, 2, 4];
		  }
		}

	демо: 

		https://stackblitz.com/edit/stackblitz-starters-6rm1q7bj?file=src%2Fapp%2Ffirst.service.ts



	пример ошибки, заключающейся в том, что инжектирование не может случиться после того как пользователь нажмёт на кнопку и тем самым запустить метод:

		export class SecondComponent {
		  service;
		  environmentInjector = inject(EnvironmentInjector);

		  press() {
		    // runInInjectionContext(this.environmentInjector, () => {
		    this.service = inject(FirstService);
		    console.log(this.service.getValue());
		    // });
		  }

		инжектирование может произойти или при инициализации инстанса через конструктор. или при инициализации инстанса через определени переменной в корневом уровне.

		если мы используем runInInjectionContext, то мы мемент инжектирования смещает от инициализации инстанса в более позднее время.




=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================