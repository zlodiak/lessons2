=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
@Injectable

	этим декоратором необходимо пометить классы, которые могут быть потребителями провайдеров. то есть эти классы через конструктор могут инжектировать зависимости.

	многие декораторы типа @NgModule, @Directive являются потомками @Injectable. поэтому для них не нужно явно прописывать @Injectable

	@Injectable({  
	   providedIn: 'root'
	})	
	// сервис является синглтоном для жадных и ленивых модулей


	@Injectable({  
	   providedIn: 'any'
	})	
	// сервис является не синглтоном, для ленивых модулей. и является синглтоном для жадных модулей

	@Injectable({  
	   providedIn: 'platform'
	})	
	// сервис является синглтоном для нескольких ангуляр-приложений

=========================================================
@Inject

	это декоратор, который используется в конструкторе класса. с помощью него инжектируются зависимости по названию токена.

=========================================================
angular 

	это клиентсикй фреймворк для создания одностраничных приложений. он предоставляет возможность обновлять страницу при помощи AJAX запросов на сервер, а так же возможности роутинга и компонентную структуру.

	компоненты выстроены в форме дерева,в этом дереве действиет механизм обнаружения изменений.

	использует TS, rxjs. существует возможность добавления сторонних модулей таких как ngrx, primeNG.



=========================================================

APP_INITIALIZER:

	это возможность стартануть сервис перед началом работы модуля. таким образом из компонент можно сразу брать готовые данные, а не подписываться на них и ждать.

	useFactory это функция внутри которой пинается метод сервиса.

	deps передаёт аргумент в useFactory, то есть сервис, метод которого нужно пнуть.

	обычно сервис создаётся таким образом чтобы его переменные содержали результат работы метода. иногда в виде subject

		function initUser(curSrv: CurService) {
		  return () => curSrv.init();
		}

		@NgModule({
		  imports: [
		  	.....
		  ],
		  providers: [
		    CurService,
		    {
		      provide: APP_INITIALIZER,
		      useFactory: initUser,
		      deps: [CurService],
		      multi: true
		    }
		  ],
		  declarations: [AppComponent],
		  bootstrap: [AppComponent],
		})
		export class AppModule {}

	здесь важно, что CurService прописан не только в deps, но и в providers.

	multi необходим для того чтобы многократно добавлять подобные конструкции, в том числе интерсепторы. важно понимать, что у каждого типа токена свой multi

=========================================================
map
 
	этот оператор работает почти так же как обычный джаваскриптовый map. то есть берёт каждый элемент потока, преобразует его и возвращает тоже поток.
	в джаваскриптовом map элементы результирующего массива можно получить при помощи синтаксиса квадратных скобок, а в реактивном map элементы результирующего потока можно получить при помощи синтаксиса .subscribe()
	 
	    const source = from([1,2,3,4,5,6,7]);
	    const result = source.pipe(map(v => v+1));
	    result.subscribe(v => console.log(v));
 
=========================================================
concatMap для обработки стримов по очереди;
mergeMap для обработки стримов параллельно;
switchMap если нужно отменять стримы, созданные ранее;
exhaustMap для игнорирования создания новых стримов, если текущий стрим ещё не был завершён;

=========================================================
кастомный провайдер 

	позволяет вынести часть зависимостей за пределы компонента. 

	например компонент делает запрос в зависимости от параметра роута. создадим отдельный файл:

		// это просто название, которое используется при инжектировании в конструкторе
		export const ORGANIZATION_INFO = new InjectionToken<Observable<Organization>>(
		   'A stream with current organization information',
		);

		// это название, котрое используется при инжектировании в массиве providers
		export const ORGANIZATION_PROVIDERS: Provider[] = [
		   {
		       provide: ORGANIZATION_INFO,
		       deps: [ActivatedRoute, OrService],
		       useFactory: organizationFactory,
		   },
		];

		// функционал провайдера. тут вся логика
		export function organizationFactory(
		   {params}: ActivatedRoute,
		   orService: OrService,
		): Observable<Organization> {
		   return params.pipe(
		       switchMap(params => {
		           const id = params.get('orgId');

		           return orService.getOrById$(id);
		       }),
		   );
		}


	в компоненте применять так:

		@Component({
		   selector: 'or',
		   templateUrl: 'or.template.html',
		   styleUrls: ['or.style.less'],
		   changeDetection: ChangeDetectionStrategy.OnPush,
		   providers: [ORGANIZATION_PROVIDERS],
		})
		export class OrganizationComponent {
		   constructor(
		       @Inject(ORGANIZATION_INFO) readonly or$: Observable<Organization>,
		   ) {}
		}

	в шаблоне применять так:

		<p *ngIf="or$ | async as or">
		   {{or.name}} from {{or.city}}
		</p>


=========================================================
частный провайдер это поставщик данных. почти такой же как сервис. 

	но у сервиса название класса и токен, по котрому обращаются к сервису совпадает.

		@NgModule({
		    providers: [DeService]
		})

	а у провайдера они могут различаться:

		providers: [
		  { provide: DeService, useClass: OtherService },		// имя токена, имя класса
		]
	 
	у провайдера есть дополнительная конфигурация:

		providers: [
		  {
		    provide: UserService,
		    useFactory: userServiceFactory,
		    deps: [AuthService],
		  },
		]

	вот все варианты тела провайдера:

		- useClass - каждый раз при обращении к зависимости, указанной в provide, создается новый экземпляр класса, указанного в useClass;
		- useExisting - каждый раз при обращении к зависимости, указанной в provide, будет использоваться один и тот же экземпляр класса, указанного в useClass;
		- useValue - позволяет при обращении к зависимости, указанной в provide, использовать предопределенный объект;
		- useFactory и deps - эти свойства позволяют создавать переопределяющее значение динамически уже в процессе работы приложения.


	@Inject

		constructor(private _uService: UserService) {}

		Она эквивалентна:

		constructor(@Inject(UserService) private _uService) {}

		она эквивалента:

		const service = inject(HelloService);

		или же можно обойтись вообще без конструктора(поюс этого подхода в том, что при наследовании не нужно пробрасывать из дочернего компонента зависимости родительского конструктора).

			@Injectable()
			abstract class Storage {
			  private logger = inject(Logger);
			}

			@Injectable()
			class LocalStorage extends Storage {
			  constructor(private selfDependency: SelfDepService){
			    super();
			  }
			}		


	-----------------------

	есть возможность подменить один сервис другим, но для этого необходимо чтобы оба сервиса были заимпортированы.

	допустим, существуют два сервиса: OldServiceService, SitesService который реализуют интерфейс getValues(). подмена происходит в блоке providers на уровне компонента:

		@Component({
		  selector: 'my-app',
		  // providers: [OldServiceService],
		  providers: [{ provide: OldServiceService, useExisting: SitesService }],
		})
		export class AppComponent implements OnInit {
		  constructor(public data: OldServiceService) {}

		  ngOnInit() {
		    console.log(this.data.getValues());
		  }
		}	

	важно понимать, что происходит не замена, а всего лишь создание псевдонима. то есть по токену, которые совпадает с названием класса сервиса доступ остаётся:

		@Component({
		  selector: 'my-app',
		  template: ``,
		  providers: [
		    { provide: 'DDD', useClass: SitesService },
		    OldServiceService,
		    SitesService,
		  ],
		})
		export class AppComponent implements OnInit {
		  constructor(
		    @Inject('DDD') public ddd: SitesService,
		    public old: OldServiceService,
		    public sites: SitesService
		  ) {}

		  ngOnInit() {
		    console.log(this.ddd.getValues());		// 123
		    console.log(this.old.getValues());		// 777
		    console.log(this.sites.getValues());	// 123
		  }
		}	

		тут больше: https://stackblitz.com/edit/reactive-dumb-components-qupk4k?file=src%2Fapp%2Fapp.component.ts

	---------------------------

	текстовый токен может быть заменён на уникально сгенерированный. результат будет тот же:

		@Component({
		  selector: 'my-app',
		  template: ``,
		  providers: [
		    { provide: DATA, useClass: SitesService },
		    OldServiceService,
		    SitesService,
		  ],
		})
		export class AppComponent implements OnInit {
		  constructor(
		    @Inject(DATA) public ddd: SitesService,
		    public old: OldServiceService,
		    public sites: SitesService
		  ) {}

		  ngOnInit() {
		    console.log(this.ddd.getValues());
		    console.log(this.old.getValues());
		    console.log(this.sites.getValues());
		  }
		}


=========================================================
InjectionToken

	можно использовать для создания объекта, который будет инжектироваться потом через конструктор

	в отдельном файле создаём токен, который привязан к объекту:

		export const DATA = new InjectionToken<Record<string, number>>('MyObj', {
		  factory: () => {
		    return {
		      a: 111,
		      b: 222,
		    };
		  },
		});

	теперь можно его инжектировать в компоненте:

		export class AppComponent implements OnInit {
		  constructor(@Inject(DATA) public readonly data: Record<string, number>) {}
		  ngOnInit() {
		    console.log(this.data);
		  }
		}

	существует 3 вида токена:

		1. type token - когда название токена совпадает с именем класса сервиса
		2. string token - просто идентификатор в виде строки
		3. injection token - сгненерированный при помощи new уникальный токен


=========================================================
что такое шаблонная переменная?

	это помеченный # элемент в шаблоне. на который можно ссылаться из шаблона же:

		<input type="text" [(ngModel)]="name" #username />
		<p>{{username.value}}</p>

	и из компонента:

		<div #editor id="jsoneditor">

		@ViewChild('editor') 
		editor: ElementRef;
		this.editor.nativeElement.innerHTML  = 'qwerty';

=========================================================
ng-container и ng-template это обёртки. их теги не существуют в DOM, но содержимое первого отображается всегда, а содержимое второго отображается только в результате использования структурных директив.

	<!-- hide -->
	<ng-template #qwerty>qwerty</ng-template>
	 
	<!-- show -->
	<div *ngIf="true; else qwerty">zzz</div>
	 
	<!-- show -->
	<ng-container>xxxxx</ng-container>



ngTemplateOutlet это слот для вставки ng-template. если этот слот видим, то вставка производится, если нет, то не производится. 

ngTemplateOutlet можно использовать на странице несколько раз.


	<ng-template #detail> 123 </ng-template>
	 
	<div class="outer">
	  Outer Box
	  <div [ngTemplateOutlet]="detail" *ngIf="outside"></div>
	  <div class="inner">
	    inner box
	    <div [ngTemplateOutlet]="detail" *ngIf="!outside"></div>
	  </div>
	</div>
	 
	<button (click)="outside = !outside">
	  Move {{ outside ? 'inside' : 'outside' }}
	</button>

=========================================================
через ng-content можно передавать отдельный части разметки и отображать их соответственно в разных целевых контейнерах.

	<app-child>
	  <div header>This should be rendered in header selection of ng-content</div>
	  <div body>This should be rendered in body selection of ng-content</div>
	</app-child>


	<div class="header-css-class">
	  <h4>Header</h4>
	  <ng-content select="[header]"></ng-content>
	</div>
	<div class="body-css-class">
	  <h4>Body</h4>
	  <ng-content select="[body]"></ng-content>
	</div>

=========================================================
что такое пайп?

	это фильтр, которые получает на вход данные и возвращет изменённые данные. в основном ипользуется в шаблоне, но есть возможность использовать пайпы в компоненте.

=========================================================
pipes pure & pipes impure

	по умолчанию пайпы чистые. то есть они реагируют только на изменение ссылки, но не внутренностей объекта. если ссылка не меняется, то метод transform не отрабатывает заново, а отдаётся предыдущее замемоизированное значение. ресурсы экономятся.

	если в декораторе пайпа прописать pure: false, то пайп будет реагировать на изменение внутренностей передаваемого объекта. это опасно с точки зрения производительности. потому что метод transform будет срабатывать каждый раз при изменении элемента объекта.

	нечистые пайпы запускают метод transform при каждом цикле обнаружения изменений.

=========================================================
trackBy

	используется при циклическом выводе элементов в шаблоне. проблема в том, что если мы отрисовали при помощи *ngFor 4 элемента, а затем по событию добавили в середину новый элемент, то в DOM будут перерисованы все элементы.

	но если мы используем trackBy, который принимает index и item, а возваращает какую-нибудь уникальную строку, то то каждый элемент будет помечен этой уникальной строкой, а в DOM будет перерисован только новый элемент и те, которые ниже него.

		<li *ngFor="let item of items; trackBy: trackByFn">{{ item }}</li>
		trackByFn(index, item) {   
		  return item.id;
		}	

=========================================================
catchError позволяет вместо в случае возникновения ошибки подменить результат новым observable продолжить выполнение, тем самым позволить сработать коллбеку успешной операции. при этом коллбек ошибки не сработает.

если catchError не вернёт observable, то сработает коллбек ошибки в блоке подписки.

  public ngOnInit() {
    this.http
      .get('data.json')
      .pipe(
        tap(() => console.log('start...')),
        catchError((error) => {
          console.log('error!!!', error);
          return of([1, 2, 3]);					// shape new result for success callback
        })
      )
      .subscribe(
        (data) => console.log('OK', data),		// success
        (err) => console.log('err', err)		// error
      );
  }


=========================================================
IVY

	это механизм, который преобразует компоненты и шаблоны в чистый HTML и javaScript.

=========================================================
interceptor это просто сервис, который срабатывает при отправке запроса. он может изменить исходящие данные и изменить получаемые данные:

	export class InterService implements HttpInterceptor {
	  constructor() {}

	  intercept(
	    req: HttpRequest<any>,
	    next: HttpHandler
	  ): Observable<HttpEvent<any>> {
	    const authReq = req.clone({
	      headers: req.headers.set('Session', '123456789'), // добавить заголовок при отправке запроса
	    });

	    return next.handle(authReq).pipe(
	      map((event) => {
	        // изменить id в полученном результате
	        event['body'] = event['body']?.map((x) => {
	          const newR = x;
	          newR.id = newR.id * 10;
	          return newR;
	        });
	        return event;
	      }),
	      tap((event) => {
	        if (event instanceof HttpResponse)
	          console.log('Server response', event);
	      })
	    );
	  }
	}


а встраивается он в модуль так же как другие сервисы тоесть через массив providers.

	providers: [
	    {
	      provide: HTTP_INTERCEPTORS,
	      useClass: InterService,
	      multi: true,
	    },
	  ],

=========================================================
ExpressionChangedAfterItHasBeenCheckedError выводится только в dev режиме.

переменные в компоненте и вывод их в шаблоне связаны. change detection актуализирует эту связь. но бывает так, что после того как CD отработал переменная в компоненте меняется, при этом соответствующее значение в шаблоне не обновляется. в этом случае dev режим извещает об этом разработчика при помощи ExpressionChangedAfterItHasBeenCheckedError, запуская дайджест цикл ещё раз после того как CD отработает. но prod режим не этого не делает.

чтобы избежать этой ошибки нужно после того как отработает CD инициировать событие(например при помощи setTimeout) или запустить changeDetection().

	export class AppComponent {
	  name = 'I am a component with Ivy 🍃';
	  text = 'A message for the child component';
	  @ViewChild(ChildComponent) childComponent: ChildComponent;

	  constructor(private cdRef: ChangeDetectorRef) {}

	  ngAfterViewInit() {
	    this.childComponent.input = 'Changed Name';

	    // this.cdRef.detectChanges();

	    // setTimeout(() => {
	    //   this.childComponent.input = 'Changed Name';
	    // });
	  }
	}


	@Component({
	  selector: "hello",
	  template: `
	    <h1>Hello {{ input }}!</h1>
	  `,
	})
	export class ChildComponent {
	  @Input() input: string;
	}

тут живой пример: https://stackblitz.com/edit/expressionchangedafterithasbeencheckederror-ivy-byszyj?file=src/app/child.component.ts


--------------

представим, что мы хотим изменить какое-то значение родителя из дочернего элемента. 
Angular как всегда пройдёт «сверху вниз», отследит изменения, и… его только что проверенное состояние снова меняет какой-то дочерний элемент. 
Отсюда и возникает ошибка ExpressionChangedAfterItHasBeenCheckedError

=========================================================
hostDirectives это альтернативный способ привязать директиву к компоненту. раньше необходимо ьыло прописывать директиву в виде атрибута

	<a-comp dir></a-comp>

но сейчас возможно это делать в декораторе компонента:

	@Component({
	  selector: 'admin-menu',
	  template: 'admin-menu.html',
	  hostDirectives: [MenuBehavior],
	})
	export class AdminMenu { }

при этом отпадает необходимость в лишнем звене @Input\@Output при передаче параметров. 

Так же есть возможность реализовать наследование в директивах, если в декораторе директивы тоже использовать hostDirectives.

важно помнить, что хуки жизненного цикла сначала выполняются в директивах и только потом в использующих их компонетнах.


=========================================================
NgOptimizedImage позволяет оптимизировать загрузку изображений. при этом является просто надстройкой над обычным html-элементом img.

	1. при подключении в модуль позволяет указать несколько CDN-поставщиков через providers. при этом в в атрибуте rawSrc не требуется указывать полный путь к поставщику, а только конечную его часть. 

		<img rawSrc="1-4000x3000_ag.jpg" />

	2. чтобы при после завершения загрузки картинки экран не дёргался можно сразу указать ширину и высоту. по сути в нативном img делается то же самое
		
		<img [rawSrc]="img.url"  width="4000" height="3000"/>

	3. в консоли будет предупреждение, если html не содержит <link rel="preconnect" href="https://ik.imagekit.io">

	4. браузер сам подбирает разные размеры изображения в зависимости от размера экрана, это нативная способность. использование rawSrcset позволяет сократить запись
		
		<img [rawSrc]="img.url" rawSrcset="200w, 400w, 600w, 800w, 1000w" />

	 5. при помощи priority можно пометить наиболее приоритетную картинуц. это дублирование нативного функционала img-элемента.

		<img [rawSrc]="img.url" priority />

=========================================================
angular 15: что нового

	1. hostDirectives

		появились директивы, привязанные к компоненту. при этом директивы можно наследовать

	2. NgOptimizedImage 

		появилась директива для оптимизации загрузки изображений

	3. появилась солкращённая запись guards (без класса, реализующего интерфейс и возвращающего true/false):

		const route = {
		  path: 'admin',
		  canActivate: [() => inject(LoginService).isLoggedIn()]
		};  


		раньше было:

			@Injectable({ providedIn: 'root' })
			export class MyGuardWithDependency implements CanActivate {
			  constructor(private loginService: LoginService) {}

			  canActivate() {
			    return this.loginService.isLoggedIn();
			  }
			}

			const route = {
			  path: 'somePath',
			  canActivate: [MyGuardWithDependency]
			};		

		сейчас стало:

			const route = {
			  path: 'admin',
			  canActivate: [() => inject(LoginService).isLoggedIn()]
			};		



	4. упростилась запись ленивой загрузкт в роутере (теперь не нужно указывать конкретный компонент, он сам будет найден на основе пути к файлу)

		раньше было:

			{
			  path: 'lazy',
			  loadChildren: () => import('./lazy-file').then(m => m.LazyComponent),
			}		

		сейчас стало:

			{
			  path: 'lazy',
			  loadComponent: () => import('./lazy-file'),
			}


	5. улучшенные сообщения об ошибках в консоли, которые, в частности, игнорируют сообщения от сторонних библиотек.

	6. общий рефакторинг кода реймворка

=========================================================
новое в angular15:

	1. возможность использовать автономные компоненты стала частью стабильной версии, а не предварительной.

	2. возможность построить роутинг на основе автономных компонентов

	3. возможность привязать директиву к компоненту через hostDirectives

	4. директива для оптимизации изображений стала стабильной. она позволяет сократить время загрузки изображений и дёргание экрана при загрузке изображения. также можно использовать режим заполнения родительского контейнера изображением.

	5. возможность более лаконично записывать гарды в маршрутизаторе

	6. возможность более лаконично записывать ленивый роутинг для автономных компонентов

	7. вывод ошибок консоли теперь не содержит ошибок от сторонних модулей

	8. был произведён рефакторинг material компонентов

	9. стало возможным генерировать через CLI автономные компоненты, директивы, пайпы

=========================================================
angular elements это npm-пакет, который позволяет отдельные angular-компоненты: 

	1. запаковывать
	2. импортировать результирующие js/css файлы в любую среду
	3. в любой среде использовать кастомный тег типа <my-tag></my-tag>

	на такой тег в среде HTML можно повесить addEventListener, который будет слушать событие, которое генерировано angular-компонентом при помощи emit(). кроме того, такой тего может принимать значения, передаваемые через атрибут при помощи @Input.

=========================================================
динамические компоненты это компоненты, кторые создаются в рантайме. Например тултипы, модальные окна и т.д.

с 13 версии ДК создаются без использования componentFactoryResolver.

	export class AppComponent {
	  @ViewChild('dynamic', { read: ViewContainerRef })
	  private viewRef: ViewContainerRef;

	  showDynamicComponent(): void {
	    this.viewRef.clear();
	    this.viewRef.createComponent(DynamicComponent);
	  }

	  removeDynamicComponent(): void {
	    this.viewRef.clear();
	  }
	}

то есть нужно просто получить элемент и выполнить на нём createComponent()

=========================================================
<base href="/"> 

	служит для того чтобы быть префиксом перед относительными ссылками.

=========================================================
какие виды директив бывают в ангуляре?

	атрибутивные(изменяют поведение), структурные(создают и удаляют элементы в DOM)

=========================================================
что такое резолвер в ангуляр?

	Резолверы в Angular используются для предварительной выборки данных: пока пользователь перенаправляется с одного маршрута на другой, новая доступная страница уже будет содержать те данные, которые требуется на ней отобразить.

=========================================================
что такое route guards в ангуляр?

RG ограничивают навигацию по определённым маршрутам.

сначала создаётся отдельный файл гуарда, в котром есть класс, реализующий интерфейс, например, canActivate. метод canActivate возвращает булево значение. затем имя этого класса используется в роутере:

    { 
        path: 'about', 
        component: AboutComponent, 
        canActivate: [AboutGuard],
    }

при этом существуют другие типы гуардов:

	canActivate - для проверки доступа к роуту
	canDeactivate - для проверки ухода с роута
	resolve - выполняет действие перед переходом на роут

=========================================================
что такое tree shaking? где для него прописываются настройки?

	Tree shaking (Встряхивание дерева) — это метод оптимизации библиотек путем удаления любого кода из окончательного файла, который фактически не используется.

	включается в webpack.config.js. а файлы-исключения указываются в package.json

=========================================================
что такое веб-воркеры?

	это механизм, который предоставляет возможность запускать скрипт в отдельном процессе. 
	после создания веб-воркера через cli создастся файл веб воркера и шаблонный код в компоненте, для которого он создан.
	таким образом из компонента можно будет отправлять сигналы на совершение определённого действия. при этом ответы веб-воркера будут в компоненте же отлавливаться при помощи onmessage и onerror

	веб-воркеры бывают выделенные и разделяемые. первые работают только с одним компонентом, вторые - со многими.

	  // webWorker-demo/src/app/webWorker.ts
	  function fibonacci(num) {
	      if (num == 1 || num == 2) {
	          return 1
	      }
	      return fibonacci(num - 1) + fibonacci(num - 2)
	  }
	  self.addEventListener('message', (evt) => {
	      const num = evt.data
	      postMessage(fibonacci(num))
	  })


	  // webWorker-demo/arc/app/app.component.ts
	  @Component({
	      selector: 'app',
	      template: `
	          <div>
	              <input type="number" [(ngmodel)]="number" placeholder="Enter any number">
	              <button (click)="calcFib">Calc. Fib</button>
	          </div>
	          <div>{{output}}</div>
	      `
	  })
	  export class App implements OnInit{
	      private number
	      private output
	      private webworker: Worker
	      ngOnInit() {
	          if(typeof Worker !== 'undefined') {
	              this.webWorker = new Worker('./webWorker')
	              this.webWorker.onmessage = function(data) {при
	                  this.output = data
	              }
	          }
	      }
	      calcFib() {
	          this.webWorker.postMessage(this.number)
	      }
	  }

=========================================================
что такое сервис-воркеры?

	СВ это система кеширования, которая была добавлена в ангуляр. все запросы проходят через СВ. после первого запроса весь ответ кешируется. при последующих запросах сравниваются контрольные суммы принятных файлов. если они не отличаются, то пользователю отдаются ране загруженные файлы.
	контрольные суммы хранятся в manifest.json, который создаётся в момент сборки приложения.

=========================================================
что такое HostListener?

	это декоратор, который связывает события DOM и обработчик. например после наведения курсора должен вывестись console.log

	    @HostListener("mouseenter") 
	    onMouseEnter() {
	        console.log('start');
	    }

	при этом возможно отлавливать события не только на элементе директивы, но и на window. здесь второй аргумент это то, что передаётся в обработчик когда событие произойдёт.

		@HostListener('window:keyup', ['$event'])
		KeyUp(event: KeyboardEvent) {
			console.log("KeyUp", event);
		}


=========================================================
что такое HostBinding?

	это декоратор, который связывает свойство компонента со свойством элемента

		private fontWeight = 'bold'

		@HostBinding('style.fontWeight') 
		get getFontWeight() {
			return this.fontWeight;
		}

=========================================================
что такое модуль в angular?

	модуль это контейнер, который содержит структурные компоненты приложение: компоненты, директивы, пайпы, сервисы. модули могут быть вложенными. 
	типы модулей:
		CoreModule - содержит сервисы, общие для всего приложения.
		SharedModule - содержит компоненты, директивы и фильтры для всего приложения.
		RoutingModule - содержит описание роутов и соответствующих им компонентов.
		корневой - он загружается в первую очередь и содержит второстепенные модули.

	технически модуль представляет собой класс с декоратором ngModule. декоратор содержит следующие поля:
		declarations - для описания использующихся компоннетов, директив, пайпов.
		providers - для импорта сервисов
		imports - для импорта других модулей
		exports - массив компонентов, директив и фильтров, которыми пользуются другие модули, если они импортируют текущий;

=========================================================
как отписаться от потока?

	первый способ: 
		1. создать переменную типа ISubscription
		2. присвоить ей поток
		3. в хуке ngOnDestroy или в блоке next прописать .unsubscribe()

	второй способ:
		1. создать s = Subject
		2. .pipe(takeUntil(s))
		3. в хуке ngOnDestroy использовать this.s.next();

	третий способ:
		1. в шаблоне использовать async pipe

	четвёртый способ:
		использовать стороннюю библиотеку с методом untilDestroy().

	что будет, если не отписываться?
		будет происходить утечка памяти. например, если пользователь 10 раз зайдёт на одн и туже страницу, то будет работать 10 коллбеков.


=========================================================
что такое ngrx?

	это шаблон, позволяющий централизировать изменения состояния. когда проект становтся большим, то состояния могут быть изменены из разных мест программы. это приводит к ошибкам и трудностям юнит-тестирования.

	ngrx предполагает наличие глобального стейта, при изменении которого каждый раз создаётся клон с добавленными изменениями. таким образом в приложении есть только один источник правды.

	редюсер содержит условный оператор, который на основе входящего сигнала(экшена) изменяет стейт. и возвращает изменённую копию.

	экшен это название действия в виде строки, которое отправляется в редюсер. возможно, с полезной нагрузкой.

	для повышения производительности стейт можно запрашивать частями. например, если требуется на экране отобразить определённую часть стейта.


=========================================================
какие подходы к мультиязычности существуют?

	пакет ngx-translate (https://stackblitz.com/edit/ngx-translate-example):
	в этом случае после подключения его в главный модуль приложения необходимо в assets создать в формате json описания констант и соответвтующие им переводы. для каждого языка отдельный файл. далее в компоненте нужно инжектировать сервис TranslateService и использовать pipe для описанной константы:

		<h2>{{ 'HOME.TITLE' | translate }}</h2>

	язык можно менять динамически, используя метод 
		
		TranslateService.use('en-US')

=========================================================
как можно проводить тестирование?

	в angular можно использовать jest юнит-тесты. они могут быть изолированные и неизолированные.

	в первом случае класс не имеет зависимостей и тестируется как изолированный функционал.

	во втором случае необходимо перед каждым тестом создать среду при помощи встроенного фреймворка testBed. создание среды предполагает эмуляцию компонента и установка зависимостей. в этом случае обычно сервисы, пайпы и прочие зависимости заменяют на моковые данные.

=========================================================
на каком шаблоне построен angular?

	mvvm

		model - сервисы. содержат данные и логику работы с данными(отправка в БД, получение из БД и т.п.)

		view - html,css. разметка и стили

		modelView - контроллер, в котором есть:
			1. связь с данными из модели, и
			2. хранятся данные-стейт шаблона, которые не должны попадать в БД(на каких полях побывал фокус, какие ошибки валидации сейчас активны и т.д). таким образом modelView тоже является миниатюрной моделью.

=========================================================
отличие конструктора от ngOnInit

	конструктор это не часть ангуляра, а часть ES6. он выполняется раньше хуков. в конструкторе недоступны входные параметры компонента.

=========================================================
можно ли в конструкторе получить значения инпутов?

	нет, в результате получим  undefined. для этого нужно использовать ngOnInit		

=========================================================
работали с вебсокетами?

	да, в частности они применялись для получения пуш-уведомлений в PWA. ВС обеспечивают такую возможность потому что протокол WSS использует постоянное соединение.

	чтобы работать с ВС необходимо создать экземпляр объекта:
		let socket = new WebSocket("wss://.....");

	и затем повесить на него обработчики:
		onopen,
		onmessage,
		onerror,
		onclose


=========================================================
что такое viewEncapsulation?

	это инкапсуляция стилей в пределах компонента. по умолчанию установлено значение emulated. в этом случае после компиляции каждому элементу добавляется атрибут. также генерируются стили, привязанные к этому атрибуту, которые находятся в секции head.

	если установлено значение none, то все стили добавляются в глобальную область видимости.

	если значение утановлено в shadowDom, то инкапсуляция осуществляется средствами теневого дома.

=========================================================
загрузка файлов через reactive form

	используется <input type="file" formControlName="file">

	но значение содержит не файл а путь к файлу. чтобы путь заменить на файл нужно или повесить слушатель на поле и в нём произвести замену или в шаблоне использовать событие (change)

	затем сформировать POST-запрос из обычных и файловых полей.

	шаблон:

		<form [formGroup]="myForm" (ngSubmit)="submit()">
		  <input formControlName="name" type="text" />

		  <input
		    formControlName="fileSource"
		    type="file"
		    (change)="onFileChange($event)"
		  />

		  <button class="btn btn-primary" type="submit">Submit</button>
		</form>

	компонент:

	  myForm = new FormGroup({
	    name: new FormControl('', [Validators.required]),
	    fileSource: new FormControl('', [Validators.required]),
	  });

	  constructor(private http: HttpClient) {}

	  onFileChange(event) {
	    if (event.target.files.length > 0) {
	      const file = event.target.files[0];
	      console.log(event.target.files);
	      console.log(file);
	      this.myForm.patchValue({
	        fileSource: file,
	      });
	    }
	  }

	  submit() {
	    const formData = new FormData();
	    formData.append('file', this.myForm.get('fileSource').value);
	    formData.append('name', this.myForm.get('name').value);

	    this.http
	      .post('http://localhost:8001/upload.php', formData)
	      .subscribe((res) => {
	        console.log(res);
	        alert('Uploaded Successfully.');
	      });
	  }		


=========================================================
как использовать валидатор на уровне группы? (случай изменения пароля со старого на новый, с подтверждением)

	нельзя использовать кастомные валидаторы, в которых объект валидации затирается при помоши setErrors

	вот правильное решение:

	@Component({
	  selector: 'my-app',
	  standalone: true,
	  imports: [
	    CommonModule,
	    ReactiveFormsModule
	  ],
	  template: `
	    <ng-container [formGroup]="form">
	      <input formControlName="field_1" [class.error]="form.get('field_1').invalid"> 
	      <br>
	      <input formControlName="field_2" [class.error]="form.get('field_2').invalid"> 
	    </ng-container>
	    <br>
	    <ng-container *ngIf="form.errors?.nonEqualPasswords">
	      Пароли то разные
	    </ng-container>
	  `,
	})
	export class App {
	  name = 'Angular';
	  form = inject(FormBuilder).group({
	    field_1: [null, Validators.required],
	    field_2: [null, Validators.required]
	  }, {
	    validators: [(group) => {
	      const c1 = group.get('field_1');
	      const c2 = group.get('field_2');

	      return c1.valid && c2.valid && c1.value !== c2.value ? {nonEqualPasswords: true} : null
	    }]
	  })
	}	

=========================================================
=========================================================
описать хуки жизненного цикла.

	ngOnChange 

		срабатывает только когда ссылка Input элемента меняется или составляющая объекта.

		в том случае, если изменяется внутренняя часть Input объекта, то имеет значение стратегия. в частности OnPush разрешает отслеживать в шаблоне только изменение ссылки. а  Default разрешает отслеживать в шаблоне такжеи зменение внутренней части объекта.

	ngOnInit 

		срабатывает один раз при создании компонента. предназначен для логики инициализации.

	ngDoCheck 

		срабатывает при любой стратегии. и при любом изменении Input объекта (и по ссылке, и по внутренней части). кроме того этот хук срабатывает при любом событии компонента.

		таким образом при помощи ngDoCheck можно обойти ограничение стратегии OnPush:
		  ngDoCheck() {
		      if (this.id !== this.o.id) {
		        this.cd.markForCheck();
		        this.id = this.o.id;
		      }
		    }

	ngAfterContentInit, ngAfterContentChecked 

		срабатывают когда отрисовался встроенный при помощи ng-content компонент. и когда он был изменён.

	ngAfterViewInit, ngAfterViewChecked 

		срабатывают когда отрисовался встроенный при помощи тега компонент. и когда он был изменён.

	ngOnDestroy 

		срабатывает один раз когда пользователь покидает компонент. обычно в этом хуке очищаются подписки и прочие ресурсы, а так же отключаются слушатели событий.

		если пользователь просто закрывает вкладку или браузер, то ngOnDestroy не успеет сработать, чтобы это исправить нужно использовать hostListener:

		  @HostListener('window:beforeunload')
		  async ngOnDestroy() {
		    if (this.myValueSub) {
		        this.myValueSub.unsubscribe();
		    }
		 
		    await this.authService.logout();
		  }

	конструктор не относится к хукам, он срабатывает до них. поэтому в нём недоступны входные свойства класса.

=========================================================
чем конструктор отличается от ngOnInit?

	процесс запуска ангуляр-приложения состоит из двух этапов:
		1. создание дерева компонентов
		2. запуск обнаружения изменений

	конструкторы вызываются на первом этапе. ngOnInit и другие хуки - на втором.

	конструктор используется для иньекции зависимостей, ngOnInit - для логин инициализации.

	в конструкторе недоступны Input-свойства, но доступны обычные свойства класса.


=========================================================
что такое структурные директивы?

	это директивы, действие которых изменяет DOM. ngIf, ngFor, ngSwitch

	ngIf можно использовать в альтернативном синтаксисе:

		<p *ngIf="condition;else unset">
			Привет мир
		</p>
		<ng-template #unset>  
			<p>Пока мир</p>  
		</ng-template>   	

	при помощи ngSwitch можно создать в шаблоне аналог switch-оператора:

	<div [ngSwitch]="count">
		<ng-template ngSwitchCase="1">{{count * 10}}</ng-template>
		<ng-template ngSwitchCase="2">{{count * 100}}</ng-template>
		<ng-template ngSwitchDefault>{{count * 1000}}</ng-template>
	</div>	

	важно понимать, что знак * это просто синтаксический сахар. без него запись более многословна.

=========================================================
что такое атрибутивные директивы?

	это директивы, которые меняют поведение уже существующего компонента. ngClass, ngStyle динамически добавляют классы или стили.

=========================================================
что такое @Input/@Output

	существует возможность передавать значение из родительского компонента в дочерний при помощи синтаксиса квадратных скобок. для этого в дочернем компоненте входное свойство должно быть помечено декоратором @Input.

	кроме того можно это свойство устанавливать через сеттер, если требуется обработка/проверка входящего значения:

	    @Input()
	    set userAge(age:number) {
	        if(age<0)
	            this._userAge=0;
	        else if(age>100)
	            this._userAge=100;
	        else
	            this._userAge = age;
	  	}	

	если нужно передать значение из дочернего компонента в ролительский, то используется всплывающее событие. для этого выходное свойство должно быть помечено декоратором @Output:

    @Output() onChanged = new EventEmitter<boolean>();
    change(increased:any) {
        this.onChanged.emit(increased);
    }

    в родительском компоненте срабатывает событие onChanged

=========================================================
чем отличаются директивы и компоненты?

	у директивы нет шаблона потому что она работает с существующими в DOM элементами. у компонента есть шаблон поэтому он создаёт разметку внутри тега, который используется для вставки компонента в DOM.

=========================================================
template-driven forms

	чтобы создать шаблонную форму нужно в компоненте определить объект с полями формы:

	  form = {
	    name: '',
	    position: '',
	  };

	  submit() {
	    console.log(this.form);
	  }

	затем в шаблоне прописать элементы этого объекта при помощи специального синтаксиса:

	  <div>
	    <input
	      type="text"
	      [(ngModel)]="form.name"
	      name="name"
	      #name="ngModel"
	      required
	    />
	    <ng-container *ngIf="name.touched && name.invalid">
	      name error
	    </ng-container>
	  </div>

	  <div>
	    <input
	      type="text"
	      [(ngModel)]="form.position"
	      name="position"
	      appPositionValidator
	      #position="ngModel"
	    />
	    <ng-container *ngIf="position.touched && position.invalid">
	      position error
	    </ng-container>
	  </div>


	как видите, валидация осуществояется или при помощи встроенных атрибутов required/pattern или при помощи директивы, если требуется кастомная валидация:

		@Directive({
		  selector: '[appPositionValidator]',
		  providers: [
		    {
		      provide: NG_VALIDATORS,
		      useClass: PositionValidatorDirective,
		      multi: true,
		    },
		  ],
		})
		export class PositionValidatorDirective {
		  validator: ValidatorFn;

		  constructor() {
		    this.validator = this.positionValidator();
		  }

		  validate(c: FormControl) {
		    return this.validator(c);
		  }

		  positionValidator(): ValidatorFn {
		    return (control: FormControl) => {
		      if (control.value !== 'boss') {
		        return {
		          positionValidatorError: true,
		        };
		      }

		      return null;
		    };
		  }
		}


	тут больше:
	https://stackblitz.com/edit/angular-ivy-gqy6hs?file=src/app/position-validator.directive.ts

=========================================================
reactive forms

	модель формы описывается в контроллере. formControls это поля, которые помещаются в контейнер formGroup. затем в шаблоне прописывается подобная структура через атрибуты.

	существует возможность в контроллере задать начальные значения, валидаторы, disabled-состояние. для удобства используется formBuilder, который нужно предварительно заинжектить.

	для конкретного поля можно написать кастомный валидатор. он будет возвращать или null или объект с ошибкой. также валидатор можно написать для группы полей.

	если необходимо динамически добавлять и выводить поля, то используетс formArray. в шаблоне для него используется конструкция ngFor.

	из шаблона можно получить доступ к состоянию полей. это нужно для вывода сообщений валидации. также доступ к состоянию полей можно получить в контроллере.

=========================================================
route guards

	позволяют ограничить навигацию по маршрутам. в блок, в котором описываются роуты, добавляется один или несколько роут гардов:

		CanActivate - ограничивает доступ к роуту.
		CanActivateChild - ограничивает доступ к дочерним роутам.
		CanDeactivate - срабатывает когда пользователь покидает роут.
		Resolve - срабатывает перед открытием роута(часто это асинхронное получение данных).
		Canload - ограничивает загрузку роута при lazy loading подходе.

	все гарды кроме Resolver возвращают булево значение. класс, который прописан в роутах должен реализовывать определённый интерфейс. но в angular15 появилась сокращённая запись для гардов: canActivate: [() => inject(LoginService).isLoggedIn()]

	существует приоритет гардов, по правилам котрого гарды в массиве выполняются параллельно, но все они прежде чем начать действовать, будут ждать завершения первого по счёту гарда в массиве. в случае редиректов есть нюансы: https://habr.com/ru/articles/689682/

=========================================================
ленивая загрузка модулей 

	используется для уменьшения бандла, который изначально загружается в браузер. есть роуты, на которые пользователь, возможно, не зайдёт. поэтому они ИМПОРТИРУЮТСЯ по требованию. форма записи такая:

		const routes: Routes = [
		  {
		    path: 'customers',
		    loadChildren: () => import('./customers/customers.module').then(m => m.CustomersModule)
		  }
		];	

	здесь, CustomersModule подгружается когда пользователь заходит на роут customers. при это CustomersModule имеет свой конфиг роуктера, в котром прописан компонент для относительного роута '':

		const routes: Routes = [
		  { path: '', component: UsersContainerComponent },		// <--------------
		  { path: ':id', component: UserComponent }
		];	


	есть возможность лениво загружать компоненты. например в каждой вкладке аккордиона есть тяжёлый компонент. для этого случая нужно воспользовать директиву ngTemplateOutlet, которая представляет из себя слот для вставки <ng-template #name>qwerty</ng-template>. также есть возможность передавать контекст.

=========================================================
ленивая загрузка компонентов

	так как существуют автономные компоненты, то есть возможность импортировать их лениво. для этого вместо loadChildren используется loadComponent

=========================================================
type guards

	это просто функция, которая делает проверку типа и возвращает булево значение.

	проверки могут делать при помощи:

		instanceof,
		typeof,
		in

=========================================================
Resolver

	используется для предварительной загрузки данных перед переходом на страницу. например чтобы не показывать пользователю вёрстку без данных, то сначала отрабатывает асинхронный запрос на сервер.ю получаются данные и только после этого происходит переход на страницу и отрисовка контента.

	в компоненте чтобы получить данные резолвера нужно на них подписаться:

		constructor(private _routes: ActivatedRoute) { }

		ngOnInit(): void {
			this._routes.data.subscribe((response: any) => {
			  this.empList = response.employees;
			})
		}	

=========================================================
события роутера

  после клика по ссылке происходит переход на роут. последовательно запускаются события роута, на которые можно подписаться из компонента, на который происходит переход:

    constructor(private router: Router) {
      this.router.events.subscribe( (event: RouterEvent) => console.log(event))
    }

  событий много, вот основные:

    NavigationStart - старт перехода на новый роут
    GuardsCheckStart - начало выполнение роут гародв 
    ResolveStart - начало выполнения росолверов
    NavigationEnd - навигация выполнена успешно
    NavigationCancel - навигация была отменена в результате действий роут гардов
    NavigationError - навигация закончена

  существует возможность включить вывод событий в консоль:

    RouterModule.forRoot(ROUTES, {
      enableTracing: true
    })

  в подписке события можно ловить так:

    if (evt instanceof NavigationStart) {
      this.displayMessage = true;
    }

=========================================================
что такое @viewChild?

	при помощи viewChild можно получить доступ к вложенному компоненту. допустим в компонент импортирован вложенный компонент:

		import { ChildComponent } from './child.component';

	в этом случае обратиться к нему можно так:

		@ViewChild(ChildComponent) 
		child: ChildComponent;
		ngAfterViewInit() {
			console.log(this.child.whoAmI());
		}	

	то же самое будет, если вложенный компонент не импортирован, а указан в шаблоне:

		<input #someInput placeholder="Your favorite pizza toping">

		@ViewChild('someInput') 
		someInput: ElementRef;
		ngAfterViewInit() {
			this.someInput.nativeElement.value = "qwerty";
		}	

=========================================================
viewChild(ren)

viewChild это декоратор, который позволяет обращаться к свойствам компонентов/директив, которые были встроены в шаблон. а так же к провайдерам, сервисам встроенных компонентов. 

в качестве встроенных компонентов могут рассматриваться обычные html элементы такие как span.

viewChildren возвращает то же самое но в виде queryList, по кторому нужно ходить при помощи toArray().foreach()

параметр read позволяет обращаться к токену провайдера:

	@Component({
	  selector: 'first-child',
	  providers: [
	    SampleService,
	    { provide: 'TokenA', useValue: 'valueA' },
	    { provide: 'TokenB', useValue: 123 },
	    { provide: ExampleServiceToken, useExisting: SampleService },
	    { provide: 'TokenC', useValue: true }
	  ]
	})

	export class FirstChildComponent{}

	@Component({
	  selector: 'parent',
	  template: `<first-child></first-child>`
	})

	export class ParentComponent{
	  @ViewChild(FirstChildComponent, { read: 'TokenA' }) dependencyA: string;
	  @ViewChild(FirstChildComponent, { read: 'TokenB' }) dependencyB: number;
	  @ViewChild(FirstChildComponent, { read: 'TokenC' }) dependencyC: boolean;
	  @ViewChild(FirstChildComponent, { read: SampleService }) sampleService: SampleService;
	  @ViewChild(FirstChildComponent, { read: ElementRef }) fcElementRef: ElementRef;
	  @ViewChild(FirstChildComponent, { read: FirstChildComponent }) fcComponent: FirstChildComponent;
	  @ViewChild(FirstChildComponent, { read: ExampleServiceToken }) exampleService: SampleService;
	}

свойство static определяет в какой момент будут считываться viewChild (до отрисовки шаблона компанента или после. это событие ngAfterViewInit)


декорировать можно импортированные элементы или помеченные в шаблоне при помощи #.


https://dev-gang.ru/article/ponimanie-dekoratorov-viewchild-i-viewchildren-v-angular--bpb46hqf3i/

----------------
@Component({
  selector: 'my-app',
  template: `
    <hello></hello>
    <p #p>Start</p>
  `,
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  @ViewChild(HelloComponent)
  hello: HelloComponent;

  @ViewChild('p')
  p: ElementRef;

  ngOnInit() {
    console.log('ngOnInit', this.hello);		// undefined
    console.log('ngOnInit', this.p);			// undefined
  }

  ngAfterViewInit() {
    console.log('ngAfterViewInit', this.hello.greetings);	// hello i am hello comp
    console.log('ngAfterViewInit', this.p);					// *nativeElement*
  }
}


@Component({
  selector: 'hello',
  template: `<h1>Hello</h1>`,
  styles: [`h1 { font-family: Lato; }`],
})
export class HelloComponent {
  public greetings = 'i am hello comp';
}


----------------


contenChild(ren)

этот декоратор используется в дочернем элементе для доступа к элементу, которые пришёл из родительского элемента и был вставлен при помощи ng-content

	родитель:

		@Component({
	    selector: 'my-app',
	    template: `<child-comp>
	                    <h3 #headerContent>Добро пожаловать {{name}}!</h3>
	               </child-comp>`
		})

	дочерний компонент:

		@Component({
		    selector: 'child-comp',
		    template: `<ng-content></ng-content>
		               <button (click)="change()">Изменить</button>`
		})
		export class ChildComponent{ 
		      
		    @ContentChild("headerContent", {static:false})
		    header: ElementRef|undefined;	

		}

=========================================================
стандартные валидаторы

  для template-driven форм в теге прописываются атрибуты: 

    required, 
    pattern, 
    maxlength, 
    minLength
    email.

    кастомные валидаторы пишутся как директива, которая реализует интерфейс NG_VALIDATORS, и тоже прописываются в тег.

  для reactive форм стандартные валидаторы живут в классе Validators:

    Validators.required
    Validators.maxLength
    Validators.minLength
    Validators.pattern
    Validators.min
    Validators.max
    Validators.email

    асинхронные валидаторы прописываются третьим аргументом, простые - вторым. кастомные валидаторы представляют из себя функцию, которая принимает поле и возвращает null для успешно пройденной валидации и объект с ошибкой для неуспешно пройденной валидации.

=========================================================
CVA это преобразователь html-элемента в поле реактивной формы.

	в первую очередь нужно создать компонент, в котором будут описаны правила и вид кастомного поля формы. затем прописать его в imports модуля. после этого в шаблоне родительского компонента использовать кастомный тег.

	кастомный компонент будет реализовывать интерфейс NG_VALUE_ACCESSOR и, возможно, NG_VALIDATORS. важно понимать, что валидатор можно использовать или в кастомном компоннете или в родительском компоненте(стандартный или самописный). одновременно их использовать нельзя.

	в кастомном компоненте определить свойство, которое с одной стороны будет связано с элементом формы, а сдругой с отображением кастомного элемента. связь (установка/синхронизация) осуществляется при помощи методов writeValue/onChanged соответственно.

	при изменении значения нужно повесить обработчик в элемент шаблона поля. этот обработчик должен делать 2 вещи: 1. изменять локальную переменную, 2. пинать onChange() чтобы информация о новом значении всплывала в объект формы.

	validate срабатывает каждый раз когда меняется значение поля в шаблоне. если с валидацией всё ок, то он возвращает null, иначе произвольный объект (этот объект помещается в объект формы, в errors конкретного поля).

		@Component({
		  selector: 'hello',
		  template: `
		    <button (click)="minus()">minus</button>
		    <button (click)="plus()">plus</button>
		    {{ value }}
		  `,
		  providers: [
		    {
		      provide: NG_VALUE_ACCESSOR,
		      useExisting: forwardRef(() => HelloComponent),
		      multi: true,
		    },
		    {
		      provide: NG_VALIDATORS,
		      useExisting: forwardRef(() => HelloComponent),
		      multi: true,
		    },
		  ],
		})
		export class HelloComponent implements ControlValueAccessor, Validator {
		  value: number;

		  validate() {
		    return this.value > 0 ? null : { positive: true };
		  }

		  onChange: any = () => {};
		  onTouch: any = () => {};

		  registerOnChange(fn: any) {
		    this.onChange = fn;
		  }

		  registerOnTouched(fn: any) {
		    this.onTouch = fn;
		  }

		  writeValue(input: number) {
		    this.value = input;
		  }

		  minus() {
		    this.value -= 1;
		    this.onChange(this.value);
		  }

		  plus() {
		    this.value += 1;
		    this.onChange(this.value);
		  }
		}



	в родителе:

	    this.form = this.fb.group({
	      name: [null, [Validators.required]],
	      email: [null, [Validators.required, Validators.email]],
	      buttons: [2],
	      input: [null, [Validators.pattern('^asd$')]],
	    });

	тут больше:
	https://stackblitz.com/edit/angular-ivy-iecnm4?file=src/app/hello.component.ts

=========================================================
CVA validation

вешать валидаторы на cva-поле можно двумя способами:

	1. в родительском компоненте как обычный кастомный валидатор

		export class AppComponent {
		  myForm: FormGroup = new FormGroup({
		    login: new FormControl(null, Validators.required),
		    name: new FormControl(null, Validators.required),
		    isAdmin: new FormControl(false, this.ValidateAdmin),
		  });

		  ValidateAdmin(control: AbstractControl) {
		    if (control.value === false) {
		      return { ValidateAdminError: true };
		    }
		    return null;
		  }
		}	

	2. внутри cva-компонента. в этом случае при любом изменении срабатывает метод validate. он как и кастомный валидатор должен вернуть или null, или объект с ключом ошибки.

	  validate({ value }: FormControl) {
	    if (!value) {
	      return {
	        invalid: true,
	      };
	    }

	    return null;
	  }	

	в этом случае нужно не забыть прописать провайдер:

	    {
	      provide: NG_VALIDATORS,
	      useExisting: HelloComponent,
	      multi: true,
	    },	

	в шаблоне проверять валидацию так:

		*ngIf="myForm.get('isAdmin').hasError('invalid')"


    тут больше:
    https://stackblitz.com/edit/angular-ivy-sgaslf?file=src/app/hello.component.ts


	setDisabledState() срабатывает каждый раз когда из родителя поле делаю disabled/enabled. в этот обработчик можно поместить полезное действие, например, чтобы cva-поле дизейблилось изнутри(извне его задизейблить не получится)

=========================================================
что такое control value accessor?

	CVA позволяет кастомный компонент связать с элементом реактивной формы и наладить двустороннюю связь между ними.

	в элементы input, select и т.д. CVA встроен изначально. но можно сделать рейтинг из 5 звёзд и привязать количество звёзд к полю реактивной формы:

	    this.galaxyForm = new FormGroup({
	      galaxy: new FormControl({value: null, disabled: false}, [Validators.required]),
	      rating: new FormControl({value: 2, disabled: true}, [Validators.required]),
	      name: new FormControl({value: null, disabled: false}, [Validators.required])
	    });

	------------
	в коде выше значение rating инициализируется двойкой. соответственно в кастомном компоненте сработает:

	  writeValue(val) {
	    console.log('writeValue', val)
	    this._value = val;
	  }

	 таким образом срабатывает связь от формы к компоненту.

	------------
	в кастомном компоненте есть обработчик события (click). после того как пользователь кликнет на звезду, он сработает:

	  setRating(star: any) {
	  	this._value = star.stars;
	  	this.ratingText = star.text
	  	this.onChanged(star.stars);
	  }

	  public _value: number;
	  onChanged: any = () => {}
	  
	  registerOnChange(fn: any){
	    this.onChanged = fn
	  }

	в результате значение star.stars будет отправлено в реактивную форму(при этом также сработает writeValue).

=========================================================
что такое сервис?

	сервис это класс, которые хранит состояние или используется в качестве поставщика данных. также он используется как канал связи между сильно разнесёнными в иерархии компонентами. он может быть определён на уровне:
		приложения(синглтон),
		модуля(синглтон),
		компонента(НЕ синглтон)

	все сервисы регистрируются инжектором, который делится на несколько уровней. если компоненту нужен сервис, то поиск начинается с нижнего уровня и идёт выше. но этот порядок может быть изменён при помощи декораторов @SkipSelf()

=========================================================
инжектор сервисов 

	это фабрика, которая отдаёт объекты сервисов. существует разные уровни: компоненты, модули, роуты, платформа и т.д.

	если существует один сервис и два компонента ижектируют его отдельно на уровне компонета, то инжектор создаст 2 экземляра сервиса, каждый из которых будет независим. то есть содержать свой уникальный набор данных.

	если сервис объявлен на уровне модуля, то каждый компонент этого модуля получает один и тот же экземпляр сервиса (синглтон). то есть будет работать с одними тем же набором данных.

	поиск объекта сервиса происходит сначала в дереве компонентов в зависимости от html-вложенности их. если ничего не нашлось, то поиск начинает производиться в модулях, к которым принадлежат эти компоненты. 
	 
	этот порядок можно изменить при помощи модификаторов Optional, Skip, SkipSelf, Host. причём последний из них актуален только для директив, которые, как известно, не имеют host-элемента.
	 
	существует механизм, при помощи которого можно подменить объект сервиса на уровне инжектора при помощи:
		useClass,
		useExisting,
		useValue ,
		useFactory 	

=========================================================
декораторы DI:

	@Optional говорит о том, что инжектирование сервиса не обязательно. то есть инжектор может не возвращать экземпляр, если он формируется динамически:

		@Injectable()
		export class OptionalS {}

		@Component({
		  selector: 'my-app',
		  template: '<h1> if you see me so app not break</h1>',
		  providers: [OptionalS], // dynamic providers
		})
		export class AppComponent {
		  constructor(@Optional() service1: OptionalS) {}
		}

		или же @Optional может пригодиться в ситуации когда @Self ничего не нашёл в текущем компоненте, тогда @Optional предотвратить выброс исключения.

	@Self говорит DI, чтобы искать зависимость только провайдерах своего компонента.

		@Component({
		  providers: [], <=== искать тут, в данном случае не найдет и выкинет ошибку
		})
		export class HelloComponent {
		  constructor(
		    @Self() private _tyapk: TyapkService,
		  ) {}
		}

	@SkipSelf говорит DI, чтобы искать зависимость исключая провайдеры текущего компонента.

		@Component({
		  providers: [TyapkService], <=== не искать тут, в данном случае не найдет и выкинет ошибку
		})
		export class HelloComponent {
		  constructor(
		    @SkipSelf() private _tyapk: TyapkService,
		  ) {}
		}		

	@Host используется для директив. зависимость ищется в директиве и в компоненте, который использует эту директиву. то же самое для ng-content

=========================================================
@Injectable
	
	Данный декоратор гарантирует, что класс умеет инжектировать зависимости.

=========================================================
change detection

	обнаружение изменений это сравнение значений в компоненте и в шаблоне. после срабатывания очередного цикла обнаружения изменений отображающиеся в шаблоне значения становятся актуальными. 

	компоненты построены в виде дерева. когда в одном из родительских компонентов происходит событие, то процесс сравнивания значений в компоненте и в шаблоне стартует во всех дочерних компонентах. это называется dirty checking. даже, если иерархия компонентов не связана через передачу параметров при помощи синтаксиса квадратных скобок, то при стратегии default всё равно во всех компонентах срабатывает цикл обнаружения изменений. это происходит потому что в шаблонах встроены теги других компонентов, образуя дерево.

	таким образом обнаружение изменений может быть запущено или событием в конкретном компоненте, или событием, спустившимся из вышестоящих компонентов.

	можно включить стратегию onPush и тогда изменения от вышестоящих компонентов будут обнаружиться только в случае передачи по ссылке нового значения. 

	обнаружение изменений в текущем компоненте можно отключить при помощи detach. в этом случае данные не спускаются в более нижние компоненты (вернее, спускаются, но не отображаются в шаблоне).

	его можно включить при помощи reattach, но если родительский отключен, то это не будет иметь эффекта. markForCheck позволяет единоразово включить обнаружение изменений во всех вышестоящих компонентах.

	detectChanges одноразово запускает обнаружение для текущего компонента и его потомков и его родителей. лучше не использовать по соображениям сохранения производительности.

	обнаружение изменений распространияется вниз по дереву компонентов после того как произошло событие или изменились передаваемые данные.

	его можно ограничить. например, если в дочернем компоненте установить стратегию onPush, то он будет реагировать только на поступающие через @Input значения или на всплывающие от более нижних компонентов события или на события происходящие в этом самом компоненте. при этом @Input значения должны изменяться по ссылке.

	важно понимать, что при включенной стратегии onPush придётся вручную пинать цикл обнаружение события через detectChanges или через markForCheck после того как отработает асинхронная операция типа setTimeout, promise, http и т. д. если цикл не пинать, то сами свойства внутри класса изменятся, но не отобразятся в шаблоне.

	есть возможность запустить обнаружение изменений во всём дереве при помощи метода ApplicationRef.tick()

=========================================================
ViewEncapsulation 

  отвечает за использование механизма работы со стилями. 

  по умолчанию он равен emulated. в этом случае стили, прописанные в css-файле компонента ограничены компонентом. это достигается добавлением уникального атрибута к host-элементу компонента и последующим использованием этого атрибута для каждого селектора.

  none отключает изоляцию стилей компонентов. таким образом встили из всех компонентов перемещаются в глобальную область. это чревато кофликтами.

  native использует shadowDOM. то есть все стили изолируются в shadowDOM хост-элемента.

  существует возможность в режиме emulated выборочно отключить изолирование. для этого для определённого селектора используется ::ng-deep

  всегда существует глобальный файл стилей, но пользоваться им нужно осторожно. обычно в него выносят стили, которые переиспользуются во многих местах приложения.

=========================================================
что такое jit и aot?

	AOT или Ahead-of-Time – вариант компиляции приложения, которая выполняется один раз при сборке приложения. в этом случае создаётся файл бандла.

	JIT выполняется каждый раз при запуске приложения в браузере.

=========================================================
changeDetectorRef

	это класс, который предоставляет доступ к функциональности обнаружения изменений. после того как пользователь инжектировал его, он может включать/отключать обнаружение изменений в любой части дерева компонентов. а так же вручную единоразово запускать обнаружение изменений вверь или вниз.

=========================================================
ngZone

  создаёт отдельный контекст выполнения для определённого участка кода. появляется возможность выполнять хуки для этого участка кода, в частности для начала выполнения, для появления исключения, для клнца выполнения. важно то, что этот участко кода может содержать асинхронные вызовы. таки образом, например, можно измерить время выпонения.

  для ангуляра использование зон особенно важно потому что эта библиотека патчит все асинхронные события. в результате после завершения работы каждого события можно запускать обнаружение изменений.

  иногда это нежелательно по соображениям производительности. в этом случае участок кода можно умышленно запускать вне зоны. для этого используется метод runOutsideAngular().

=========================================================
Динамические компоненты

  это компоненты которые создаются когда приложение уже собрано и пользователь с ним работает. например это тултипы, модальные окна. создание происходит по шаблону, для этого нужно создать компонент. затем в целевом шаблоне прописать тег, который помечен шаблонной переменной:

    <ng-template #dynamic></ng-template>

  в целевом контроллере нужно через @ViewChild получить доступ к элементу #dynamic:

    @ViewChild('dynamic', { read: ViewContainerRef })
    private viewRef: ViewContainerRef;

  и затем по событию выполнить на  нём createComponent:

    this.viewRef.createComponent(DynamicComponent);

  удаление динамического компонента делается так:

    this.viewRef.clear();

=========================================================
ngTemplateOutlet

  это слот для вставки шаблона ng-template. вставлять можно многократно в пределах страницы. то есть это динамический шаблон

    <ng-container *ngTemplateOutlet="loading"></ng-container>
    <ng-template #loading>
        <div>Loading...</div>
    </ng-template>    

  в этот динамический шаблон можно преедавать переменные:

    <ng-container *ngTemplateOutlet="loading; context: { a: 123 }"></ng-container>
    <ng-template #loading let-variable="a">
        <div>{{ a }}</div>
    </ng-template>

=========================================================
createEmbeddedView

  работает подобно ngTemplateOutlet, только не из шаблона, а из контроллера. например, в шаблоне есть 2 ng-template:

      <ng-template #templateRef>
        <ul>
          <li>List Item 1</li>
          <li>List Item 2</li>
        </ul>
      </ng-template>
      <div #viewContainerRef class="testing">
      </div>  

  задача в том, чтобы #viewContainerRef был слотом для #templateRef. для этого в контроллере через @ViewChild получаем доступ к обоим шаблонам:

    @ViewChild('viewContainerRef', { read: ViewContainerRef, static: true }) viewContainerRef: ViewContainerRef;
    @ViewChild('templateRef', { read: TemplateRef, static: true }) templateRef: TemplateRef<any>;  

  и затем в OnInit() производим вставку:

    this.viewContainerRef.createEmbeddedView(this.templateRef);

  в результате под разметкой #viewContainerRef будет располагаться разметка #templateRef

  https://stackblitz.com/edit/angular-view-container-ref-create-embedded-view?file=src/app/app.component.ts

=========================================================
способы улучшить производительность.

	1. уменьшить количество http-запросов и используемых библиотек.
	2. применять различные алгоритмы сжатия на этапе сборки при помощи webpack
	3. использовать мемоизацию
	4. использовать стратегию OnPush
	5. использовать пагинацию
	6. использовать pure pipes

		потому что чистый пайп это синглтон, он создаётся один раз. и запускает метод transform только если входной аргумент изменился. 

		а грязные пайпы создаются каждый раз при использовании в шаблоне.

	7. использовать опцию trackBy для директивы *ngFor
	8. использовать веб воркеров для вычисления функций в другом потоке
	9. лениввая загрузка позволяет загружать ресурсы только когда они необходимы пользователю

		нужно в массиве роутов использовать loadChildren: () => import('./lazy-file').then(m => m.LazyComponent)

	10. предварительная загрузка 

		фоновая загрузка lazy-модулей, по которым пользователь пока не ходил

			imports: [
			    BrowserModule,
			    FormsModule,
			    RouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules }),
			],	

		фоновая загрузка lazy-модулей, которые связаны с текущей страницей

			imports: [
			    BrowserModule,
			    FormsModule,
			    RouterModule.forRoot(routes, { preloadingStrategy: QuicklinkStrategy }),
			],		

	11. отключение компонентов от changeDetection при помощи detach()	

=========================================================
angular.json

  это файл конфигурации проекта, в котором содержатся информация о:

    включении оптимизаций(минификация стилей, встраивание шрифтов в index.html),
    путь к статическим файлам,
    путей к файлам стилей,
    путей к файлам сторонних библиотек,
    путей по которому будет находиться билд,
    путь к index.html,
    путь к tsconfig.app.json,
    директория с файлами всего проекта,
    тип проекта (приложение или библиотека),
    префикс, который используется для компоннетов и директив,



=========================================================
enviroments

  это каталог, в котором содержатся файлы с переменными окружения для разных сред. (продакшн и разработка). 

  при сборке билда можно указывать какой файл окружения использовать: 

    ng build или ng build --prod 

  также можно создать ещё один файл окружения и через angular.json подменить действующий:

    "vasya": {
      "fileReplacements": [
        {
          "replace": "src/environments/environment.ts",
          "with": "src/environments/environment.vasya.ts"
        }
      ]
    }    

  вызывать так:

    ng build --configuration=vasya
    ng build -c vasya

=========================================================
Webpack 
  
  это популярный инструмент для сборки модулей в один файл. в webpack.config.ts указываются пути, по котрым будут располагаться сибранные файлы стилей, скриптом. а так же указывается файл, с которого начнёт работу приложение.

  создаётся appComponent, 
  затем он прописывается в appModule, 
  затем appModule прописывается в main.js,
  main.js прописывается в webpack.config.ts как точка входа в приложение

  кроме того в webpack.config.ts указываются зависимости для разработки и для приложения. при использовании определённой команды(которая тоже прописана в конфиге) эти зависимости скачиваются и помещаютсяв node_modules.

  в блоке resolve указываются расширения, которые можно не писать в импортах.

=========================================================
pipe

  отправляет параметры, которые указываются через двоеточине. их может не быть вообще. 

  если пайп самописный, то первым параметром всегда будет значение, которое находится слева от вертикальной черты, а перечисляемые через двоеточие будут идти за ним.

=========================================================
=========================================================
отличие promise от observable

  observable это многократный промис. его можно отменить. он выполняется только после подписки на него, то есть ленив. observable может использовать много операторов для обработки получаемых данных.

=========================================================
использование мультикастинга для уменьшения количества запросов в случае с async pipe

	@Component({
	  selector: 'my-app',
	  templateUrl: './app.component.html',
	  styleUrls: ['./app.component.css'],
	})
	export class AppComponent {
	  users$: Observable<any> | null = ajax(
	    'https://jsonplaceholder.typicode.com/users'
	  ).pipe(
	    map((res) => res.response),
	    share()
	  );

	  constructor(private http: HttpClient) {}
	}

	<div *ngIf="users$ | async">
	  <li *ngFor="let item of users$ | async">
	    {{ item.name }}
	  </li>

	  <li *ngFor="let item of users$ | async">
	    {{ item.name }}
	  </li>

	  <li *ngFor="let item of users$ | async">
	    {{ item.name }}
	  </li>
	</div>

=========================================================
query params

	можно передавать так:

		goProducts() {
		  this.router.navigate(
		    ['/products'],
		    { queryParams: { order: 'popular' } }
		  );
		}		

		// http://localhost:4200/products?order=popular

	но при переходе на следующую страницу (products -> users) они не сохранятся в url. можно сделать так чтобы они сохранились:

		goUsers() {
		  this.router.navigate(
		    ['/users'],
		    { queryParamsHandling: 'preserve' }
		  );
		}	

		// http://localhost:4200/users?order=popular

	или можно сделать так чтобы параметры и сохранялись, и добавлялись:

		goUsers() {
		  this.router.navigate(
		    ['/users'],
		    {
		      queryParams: { filter: 'new' },
		      queryParamsHandling: 'merge' }
		    );
		}	

		// http://localhost:4200/users?order=popular&filter=new


---------------------
всё вышеперечисленное можно делать не только из компонента, но и из шаблона:

	<a
	   [routerLink]="['/users']"
	   [queryParams]="{ filter: 'new' }"
	   queryParamsHandling="merge"
	>
	  Users
	</a>

=========================================================
подписаться на изменения query-параметров можно так:

	// http://localhost:4200/products?order=popular
  ngOnInit() {
    this.route.queryParamsHandling	
      .filter(params => params.order)
      .subscribe(params => {
        console.log(params); // { order: "popular" }
      }
    );
  }

=========================================================
singnals

	это альтернативный подход к обнаружению изменений:

		export class AppComponent{
			count = signal(0)
			double = computed(() => this.count() * 2);

			changeCount() {
				this.count.set(5)
			}
		}	

		здесь после утсановки новго значения, сигнал сам оповещает своих потребителей.

=========================================================
анимации

	можно пометить элемент директивой анимации и чередовать состояния:

		<div [@fade]=" show ? 'collapse' : 'expanded'">

	  animations: [
	    trigger('fade', [			// имя директивы
	      state(
	        'collapse',				// имя состояния
	        style({...})
	      ),
	      state(
	        'expanded',				// имя состояния
	        style({...})
	      ),
	      transition('collapse => expanded', [...]),		// характеристики перехода состояний
	      transition('expanded => collapse', [...]),		// характеристики перехода состояний
	    ]),
	  ],	

	  живой пример: https://stackblitz.com/edit/angular-animation-enter-leave-dom-solution-test-lcub4j?file=src/app/app.component.ts

	есть возможность повесить анимацию на хост компонента:

		@HostBinding('@fade')
		public myStatusExp;

	отслеживать события на анимируемом элементе можно так:

		(@fade.start)="animationStarted($event)"
		(@fade.done)="animationDone($event)"	

	можно обойтись без state:

    trigger('todoAnimation', [
       transition(':enter', [					// момент появления элемента в DOM
          style({ height: 0 }),				// перед стартом
          animate('0.3s ease-in', style({ height: '*' }))		// после старта анимации появления
       ]),
       transition(':leave', [					// момент удаления элемента из DOM
          animate('0.3s ease-out', style({ transform: 'scale(0)' })) 		// после старта анимации удаления
       ]),
    ])

  анимация дочерних элементов будет заблокирована. 

-------------------

Web Animations API

	позволяет работать с CSS-анимацией средствами JS. то есть у каждого элемента в DOM есть метод animate:

		const el = document.getElementById('cube');
		console.log(el);
		console.log('animate' in el);   // true	

	этому методу преедаётся объект, эмулирующий @keyframes и задающий повторяемость:

		document.getElementById('cube').animate(
		    cubeRotating,
		    cubeTiming
		)	

		let cubeRotating = [
		    {transform: 'rotate(0deg)', backgroundColor: 'pink'},
		    {backgroundColor: 'purple', offset: 0.3},
		    {transform: 'rotate(180deg)', backgroundColor: 'pink'}
		]	

		let cubeTiming = {
		    duration: 1000,
		    iterations: Infinity
		}	

=========================================================
tree shaking 

	включается, если сервис подключать через декоратор:

		@Injectable({
		  providedIn: 'root',
		})	

	если же сервис подключать через модуль, то tree shaking автоматически не включается.

=========================================================
если модуль подключен как lazy loaded, то сервисы, экспортируемые из него в lazy и в жадные модули, не являются синглтонами.

тут больше: https://www.youtube.com/watch?v=PU_xpHxZkrE&list=PLX7eV3JL9sfk0tbUkZwGCD1Y-kJ05NvOR&index=3&ab_channel=DecodedFrontend

=========================================================
viewProviders

	это массив providers, который не виден сущностям, вставленным через ng-content, но виден сущностям, вставленным через тег хоста. имеется в виду видимость когда поиск сервиса идёт по чепочке от дочернего компонента к родительским.

	больше тут: https://stackblitz.com/edit/angular-view-providers-example1?file=src%2Fapp%2Fchild.component.ts
	и тут: https://www.tektutorialshub.com/angular/viewproviders-in-angular/

=========================================================
route providers

	недавно в ангуляре появился ещё один уровень инжектора - это инжектор роутера. он располагается между node injector и root injector(injectabke decorator and module injector)

=========================================================
componentless router

	это добавление прослойки в виде path: '', которая технически не вносит никакого изменения в поведение роутера, но позволяет в конфиге роутера группировать составные части чтобы удобнее было применять гарды.

	это може пригодиться, если мы имеем на одном уровне несколько роутов, каждый из которых проверяет аутентификацию пользователя. вместо того чтобы много раз повторять вызов canActivate, можно сгруппировать роуты при помощи безкомпонентного роутинга и на верхнем уровне только один раз прописать canActivate

=========================================================
именованная маршрутизация

	роут содержит состояние. под ключом по умолчанию хранится состояние основного роута. но можно хранить в других ключах состояние дополнительных роутов, которые выводятся в скобках: 

		https://stackblitz.io/first(aside:money)

	для основого роута нужен тег: 

		<a routerLink="first" routerLinkActive="active">first</a>
		<router-outlet></router-outlet>

	для дополнительного роута нужен тег: 

		<a [routerLink]="[{ outlets: { aside: 'weather' } }]">clear</a>
		<router-outlet name="aside"></router-outlet>

	пример конфига роутов:

	  { path: '', redirectTo: '/first', pathMatch: 'full' },
	  { path: 'first', component: FirstComponent },
	  { path: 'second', component: SecondComponent },
	  { path: '', component: MoneyComponent, outlet: 'aside' },
	  { path: 'money', component: MoneyComponent, outlet: 'aside' },
	  { path: 'weather', component: WeatherComponent, outlet: 'aside' },		

	например, есть набор страниц, сбоку каждой из которых висит или виджет погоды, или виджет денег (зависит от того какую ссылки кликнул пользователь). состояние этого виджета хранится в скобочной части url и не зависит от смены основных страниц.

	живой пример: https://stackblitz.com/edit/angular-router-named-outlet-ftmv7f?file=src%2Fapp%2Fapp-routing.module.ts

=========================================================
custom title strategy

	для каждого роута можно прописать title. после этого на каждой странице начнёт отрабатывать класс TitleStrategy, который будет брать значение title из роута и выводить его в заголовке вкладки. однако в корневом модуле при помощи частного провайдера этот сервис можно подменить:

	  providers: [
	    {
	      provide: TitleStrategy,
	      useClass: SiteNamePageTitleStrategy
	    }
	  ]	

	здесь SiteNamePageTitleStrategy унаследуется от TitleStrategy так:

		@Injectable()
		export class SiteNamePageTitleStrategy extends TitleStrategy {
		  constructor(private title: Title) {
		    super();
		  }

		  updateTitle(routerState: RouterStateSnapshot) {
		    const title = this.buildTitle(routerState);		// получаем текущий title
		    console.log(title);
		    if (title !== undefined) {
		      this.title.setTitle(`${title} - Duotify Inc.`);		// устанавливаем обновлённый title
		    } else {
		      this.title.setTitle(`Home - Duotify Inc.`);
		    }
		  }
		}	

=========================================================
title для динамических роутов

	если имеем вложенный роут с параметром, например, есть список пользователей, каждый элемент которого ведёт на профиль пользователя. задача в том, чтобы в тайтле вкладки браузера присутствовало имя пользователя. для этого используем резолвер:

		const routes: Routes = [
		  { path: '', component: UsersContainerComponent },
		  { path: ':id', component: UserComponent, title: UserTitleResolverService }
		];


		class UserTitleResolverService implements Resolve<string> {

		  constructor(private userLoader: UserLoaderService) { }	// это тривиальный сервис для получения объекта пользователя

		  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): string | Observable<string> | Promise<string> {
		    return this.userLoader.loadUser(route.paramMap.get('id')!).pipe(		// здесь id это то же самое, что id в конфиге роута
		      pluck('name'),
		      map(name => `User - ${name}`)		// здесь возвращаем обновлённый тайтл
		    )
		  }
		}

=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================