APP_INITIALIZER:

это возможность стартануть сервис перед началом работы модуля. таким образом из компонент можно сразу брать готовые данные, а не подписываться на них и ждать.

useFactory это функция внутри которой пинается метод сервиса.

deps передаёт аргумент в useFactory, то есть сервис, метод которого нужно пнуть.

обычно сервис создаётся таким образом чтобы его переменные содержали результат работы метода. иногда в виде subject

	function initUser(curSrv: CurService) {
	  return () => curSrv.init();
	}

	@NgModule({
	  imports: [
	  	.....
	  ],
	  providers: [
	    CurService,
	    {
	      provide: APP_INITIALIZER,
	      useFactory: initUser,
	      deps: [CurService],
	      multi: true
	    }
	  ],
	  declarations: [AppComponent],
	  bootstrap: [AppComponent],
	})
	export class AppModule {}

здесь важно, что CurService прописан не только в deps, но и в providers.

multi необходим для того чтобы многократно добавлять подобные конструкции, в том числе интерсепторы. важно понимать, что у каждого типа токена свой multi

=========================================================
map
 
этот оператор работает почти так же как обычный джаваскриптовый map. то есть берёт каждый элемент потока, преобразует его и возвращает тоже поток.
в джаваскриптовом map элементы результирующего массива можно получить при помощи синтаксиса квадратных скобок, а в реактивном map элементы результирующего потока можно получить при помощи синтаксиса .subscribe()
 
    const source = from([1,2,3,4,5,6,7]);
    const result = source.pipe(map(v => v+1));
    result.subscribe(v => console.log(v));
 
=========================================================
concatMap для обработки стримов по очереди;
mergeMap для обработки стримов параллельно;
switchMap если нужно отменять стримы, созданные ранее;
exhaustMap для игнорирования создания новых стримов, если текущий стрим ещё не был завершён;

=========================================================
кастомный провайдер позволяет вынести часть зависимостей за пределы компонента. 

например компонент делает запрос в зависимости от параметра роута. создадим отдельный файл:

	// это просто название, которое используется при инжектировании в конструкторе
	export const ORGANIZATION_INFO = new InjectionToken<Observable<Organization>>(
	   'A stream with current organization information',
	);

	// это название, котрое используется при инжектировании в массиве providers
	export const ORGANIZATION_PROVIDERS: Provider[] = [
	   {
	       provide: ORGANIZATION_INFO,
	       deps: [ActivatedRoute, OrService],
	       useFactory: organizationFactory,
	   },
	];

	// функционал провайдера. тут вся логика
	export function organizationFactory(
	   {params}: ActivatedRoute,
	   orService: OrService,
	): Observable<Organization> {
	   return params.pipe(
	       switchMap(params => {
	           const id = params.get('orgId');

	           return orService.getOrById$(id);
	       }),
	   );
	}


в компоненте применять так:

	@Component({
	   selector: 'or',
	   templateUrl: 'or.template.html',
	   styleUrls: ['or.style.less'],
	   changeDetection: ChangeDetectionStrategy.OnPush,
	   providers: [ORGANIZATION_PROVIDERS],
	})
	export class OrganizationComponent {
	   constructor(
	       @Inject(ORGANIZATION_INFO) readonly or$: Observable<Organization>,
	   ) {}
	}

в шаблоне применять так:

	<p *ngIf="or$ | async as or">
	   {{or.name}} from {{or.city}}
	</p>


=========================================================
провайдер это поставщик данных. почти такой же как сервис. 

но у сервиса название класс и токен, по котрому обращаются к сервису совпадает.

	@NgModule({
	    providers: [DeService]
	})

а у провайдера они могут различаться:

	providers: [
	  { provide: DeService, useClass: OtherService },		// имя токена, имя класса
	]
 
у провайдера есть дополнительная конфигурация:

	providers: [
	  {
	    provide: UserService,
	    useFactory: userServiceFactory,
	    deps: [AuthService],
	  },
	]

вот все варианты тела провайдера:

	- useClass - каждый раз при обращении к зависимости, указанной в provide, создается новый экземпляр класса, указанного в useClass;
	- useExisting - каждый раз при обращении к зависимости, указанной в provide, будет использоваться один и тот же экземпляр класса, указанного в useClass;
	- useValue - позволяет при обращении к зависимости, указанной в provide, использовать предопределенный объект;
	- useFactory и deps - эти свойства позволяют создавать переопределяющее значение динамически уже в процессе работы приложения.


@Inject

	constructor(private _uService: UserService) {}

	Она эквивалентна:

	constructor(@Inject(UserService) private _uService) {}

=========================================================
обнаружение изменений это сравнение значений в компоненте и в шаблоне. после срабатывания очередного цикла обнаружения изменений отображающиеся в шаблоне значения становятся актуальными. 

компоненты построены в виде дерева. когда в одном из родительских компонентов происходит событие, то процесс сравнивания значений в компоненте и в шаблоне стартует во всех дочерних компонентах. это называется dirty checking.

таким образом обдаружение изменений может быть запущено или событием в конкретном компоненте, или событием, спустившимся из вышестоящих компонентов.

можно включить стратегию onPush и изменения от вышестоящих компонентов будут обнаружиться только в случае передачи по ссылке нового значения. 

обнаружение изменений в текущем компоненте и спустившееся из родительского компонента можно отключить при помощи detach. в этом случае данные не спускаются в более нижние компоненты (вернее, спускаются, но не отображаются в шаблоне).

его можно включить при помощи reattach, но если родительский отключен, то это не будет иметь эффекта. markForCheck позволяет единоразово включить обнаружение изменений во всех вышестоящих компонентах.

detectChanges одноразово запускает обнаружение для текущего компонента и его потомков и его родителей. лучше не использовать по соображениям сохранения производительности.

обнаружение изменений распространияется вниз по дереву компонентов после того как произошло событие или изменились передаваемые данные.

его можно ограничить. например, если в дочернем компоненте установить стратегию onPush, то он будет реагировать только на поступающие через @Input значения или на всплывающие от более нижних компонентов события или на события происходящие в этом самом компоненте. при этом @Input значения должны изменяться по ссылке.

важно понимать, что при включенной стратегии onPush придётся вручную пинать цикл обнаружение события через detectChanges или через markForCheck после того как отработает асинхронная операция типа setTimeout, promise, http и т. д. если цикл не пинать, то сами свойства внутри класса изменятся, но не отобразятся в шаблоне.

даже, если иерархия компонентов не связана через передачу параметров при помощи синтаксиса квадратных скобок, то при стратегии default всё равно во всех компонентах срабатывает цикл обнаружения изменений. это называется dirty checking

=========================================================
CVA это преобразователь html-элемента в поле реактивной формы.

в первую очередь нужно создать компонент, в котором будут описаны правила и вид кастомного поля формы. затем прописать его в imports модуля. после этого в шаблоне родительского компонента использовать кастомный тег.

кастомный компонент будет реализовывать интерфейс NG_VALUE_ACCESSOR и, возможно, NG_VALIDATORS. важно понимать, что валидатор можно использовать или в кастомном компоннете или в родительском компоненте(стандартный или самописный). одновременно их использовать нельзя.

в кастомном компоненте определить свойство, которое с одной стороны будет связано с элементом формы, а сдругой с отображением кастомного элемента. связь (установка/синхронизация) осуществляется при помощи методов writeValue/onChanged соответственно.

при изменении значения нужно повесить обработчик в элемент шаблона поля. этот обработчик должен делать 2 вещи: 1. изменять локальную переменную, 2. пинать onChange() чтобы информация о новом значении всплывала в объект формы.

validate срабатывает каждый раз когда меняется значение поля в шаблоне. если с валидацией всё ок, то он возвращает null, иначе произвольный объект (этот объект помещается в объект формы, в errors конкретного поля).

	@Component({
	  selector: 'hello',
	  template: `
	    <button (click)="minus()">minus</button>
	    <button (click)="plus()">plus</button>
	    {{ value }}
	  `,
	  providers: [
	    {
	      provide: NG_VALUE_ACCESSOR,
	      useExisting: forwardRef(() => HelloComponent),
	      multi: true,
	    },
	    {
	      provide: NG_VALIDATORS,
	      useExisting: forwardRef(() => HelloComponent),
	      multi: true,
	    },
	  ],
	})
	export class HelloComponent implements ControlValueAccessor, Validator {
	  value: number;

	  validate() {
	    return this.value > 0 ? null : { positive: true };
	  }

	  onChange: any = () => {};
	  onTouch: any = () => {};

	  registerOnChange(fn: any) {
	    this.onChange = fn;
	  }

	  registerOnTouched(fn: any) {
	    this.onTouch = fn;
	  }

	  writeValue(input: number) {
	    this.value = input;
	  }

	  minus() {
	    this.value -= 1;
	    this.onChange(this.value);
	  }

	  plus() {
	    this.value += 1;
	    this.onChange(this.value);
	  }
	}



в родителе:

    this.form = this.fb.group({
      name: [null, [Validators.required]],
      email: [null, [Validators.required, Validators.email]],
      buttons: [2],
      input: [null, [Validators.pattern('^asd$')]],
    });

тут больше:
https://stackblitz.com/edit/angular-ivy-iecnm4?file=src/app/hello.component.ts


=========================================================
CVA validation

вешать валидаторы на cva-поле можно двумя способами:

	1. в родительском компоненте как обычный кастомный валидатор

		export class AppComponent {
		  myForm: FormGroup = new FormGroup({
		    login: new FormControl(null, Validators.required),
		    name: new FormControl(null, Validators.required),
		    isAdmin: new FormControl(false, this.ValidateAdmin),
		  });

		  ValidateAdmin(control: AbstractControl) {
		    if (control.value === false) {
		      return { ValidateAdminError: true };
		    }
		    return null;
		  }
		}	

	2. внутри cva-компонента. в этом случае при любом изменении срабатывает метод validate. он как и кастомный валидатор должен вернуть или null, или объект с ключом ошибки.

	  validate({ value }: FormControl) {
	    if (!value) {
	      return {
	        invalid: true,
	      };
	    }

	    return null;
	  }	

	в этом случае нужно не забыть прописать провайдер:

	    {
	      provide: NG_VALIDATORS,
	      useExisting: HelloComponent,
	      multi: true,
	    },	

	в шаблоне проверять валидацию так:

		*ngIf="myForm.get('isAdmin').hasError('invalid')"


    тут больше:
    https://stackblitz.com/edit/angular-ivy-sgaslf?file=src/app/hello.component.ts


setDisabledState() срабатывает каждый раз когда из родителя поле делаю disabled/enabled. в этот обработчик можно поместить полезное действие, например, чтобы cva-поле дизейблилось изнутри(извне его задизейблить не получится)

=========================================================
viewChild(ren)

viewChild это декоратор, который позволяет обращаться к свойствам компонентов/директив, которые были встроены в шаблон. а так же к провайдерам, сервисам встроенных компонентов. 

в качестве встроенных компонентов могут рассматриваться обычные html элементы такие как span.

viewChildren возвращает то же самое но в виде queryList, по кторому нужно ходить при помощи toArray().foreach()

параметр read позволяет обращаться к токену провайдера:

	@Component({
	  selector: 'first-child',
	  providers: [
	    SampleService,
	    { provide: 'TokenA', useValue: 'valueA' },
	    { provide: 'TokenB', useValue: 123 },
	    { provide: ExampleServiceToken, useExisting: SampleService },
	    { provide: 'TokenC', useValue: true }
	  ]
	})

	export class FirstChildComponent{}

	@Component({
	  selector: 'parent',
	  template: `<first-child></first-child>`
	})

	export class ParentComponent{
	  @ViewChild(FirstChildComponent, { read: 'TokenA' }) dependencyA: string;
	  @ViewChild(FirstChildComponent, { read: 'TokenB' }) dependencyB: number;
	  @ViewChild(FirstChildComponent, { read: 'TokenC' }) dependencyC: boolean;
	  @ViewChild(FirstChildComponent, { read: SampleService }) sampleService: SampleService;
	  @ViewChild(FirstChildComponent, { read: ElementRef }) fcElementRef: ElementRef;
	  @ViewChild(FirstChildComponent, { read: FirstChildComponent }) fcComponent: FirstChildComponent;
	  @ViewChild(FirstChildComponent, { read: ExampleServiceToken }) exampleService: SampleService;
	}

свойство static определяет в какой момент будут считываться viewChild (до отрисовки шаблона компанента или после. это событие ngAfterViewInit)


декорировать можно импортированные элементы или помеченные в шаблоне при помощи #.


https://dev-gang.ru/article/ponimanie-dekoratorov-viewchild-i-viewchildren-v-angular--bpb46hqf3i/

----------------
@Component({
  selector: 'my-app',
  template: `
    <hello></hello>
    <p #p>Start</p>
  `,
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  @ViewChild(HelloComponent)
  hello: HelloComponent;

  @ViewChild('p')
  p: ElementRef;

  ngOnInit() {
    console.log('ngOnInit', this.hello);		// undefined
    console.log('ngOnInit', this.p);			// undefined
  }

  ngAfterViewInit() {
    console.log('ngAfterViewInit', this.hello.greetings);	// hello i am hello comp
    console.log('ngAfterViewInit', this.p);					// *nativeElement*
  }
}


@Component({
  selector: 'hello',
  template: `<h1>Hello</h1>`,
  styles: [`h1 { font-family: Lato; }`],
})
export class HelloComponent {
  public greetings = 'i am hello comp';
}


----------------


contenChild(ren)

этот декоратор используется в дочернем элементе для доступа к элементу, которые пришёл из родительского элемента и был вставлен при помощи ng-content

	родитель:

		@Component({
	    selector: 'my-app',
	    template: `<child-comp>
	                    <h3 #headerContent>Добро пожаловать {{name}}!</h3>
	               </child-comp>`
		})

	дочерний компонент:

		@Component({
		    selector: 'child-comp',
		    template: `<ng-content></ng-content>
		               <button (click)="change()">Изменить</button>`
		})
		export class ChildComponent{ 
		      
		    @ContentChild("headerContent", {static:false})
		    header: ElementRef|undefined;	

		}


=========================================================
rxjs common operators

все операторы принимают поток, меняют его внутренности и возвращают изменённый поток чтобы потом можно было на него подписаться при помощи subscribe.

map:
	преобразует каждый элемент последовательности по определённому правилу.

concat:
	объединяет потоки последовательно. то есть по мере их регистрации, ане по мере выполнения.

merge:
	объединяет потоки по мере их выполнения. последовательность регистрации значения не имеет.

mergeAll:
	если существует поток, элементами которого являются другие потоки, то этот оператор подписывается на каждый внутренний поток, получает его результат и возвращает только внешний поток, содержащий уже не потоки, а результаты. 

	таким образом этот оператор уменьшает вложенность потоков. порядок результатов внутри потока зависит от порядка в котором разрешилась подписка.

concatAll:
	 делает то же самое, но порядок результатов в потоке зависит от регистрации, а не от скорости разрешения подписок.

mergeMap:
	позволяет избежать подписки в подписке. для каждого элемента потока он создаёт новый поток, разрешает его и получает результат. таким образом на выходе получает поток, который содержит набор результатов. на него теперь нужно подписаться только один раз.

	порядок результатов в финальном потоке зависит от того в какой последовательности разрешались внутренние потоки.

concatMap:
	делает то же самое, но активна всегда только одна подписка. пока она не разрешится не произойдёт следующей подписки. таким образом поледовательно выполнятся все подписки

switchMap:
	похож на mergeMap, но при появлении нового потока внутри основного потока отменяет выполняющиеся в данный момент потоки. таким образом актуален всегда только последний внутренний поток.

exhaustMap:
	то же самое, но делает актуальным только первый поток, а запустившиеся позже отключает.


=========================================================
custom pipe. это функция, которая принимает поток, изменяет его и возвращает поток.

создать пользовательский оператор можно двумя способами:
	1. с использованием pipe второго уровня,
	2. полностью создав новый поток с тремя коллбеками.


1:
	export function hmm(n: number) {
	  console.log(n);
	  return <T>(source$: Observable<T>) => {
	    return source$.pipe(tap(console.log, console.error));
	  };
	}
	 
	const source = of('World').pipe(
	  map((x) => `Hello ${x}!`),
	  hmm(111)
	);
	 
	source.subscribe();


	видно, что hmm это просто функция-обёртка, которая возвращает сам оператор. этото оператор подобен map(x => x + 1). разница только в том, что он принимает поток и обрабатывает его стандартным pipe(tap()).

	при желании в функцию обёртку можно передать аргумент n. в данном примере он передаётся, но не используется.

2:
	function custom() {
	  return (src) => {
	    return new Observable((sub) => {
	      return src.subscribe({
	        next(value) {
	          sub.next(value + '_extra');
	        },
	        error(error) {
	          console.log(error);
	        },
	        complete() {
	          console.log('complete');
	        },
	      });
	    });
	  };
	}

	const obs$ = of(1, 2, 3, 4, 5);

	obs$
	  .pipe(
	    map((x) => x + '___addition'),
	    custom()
	  )
	  .subscribe(console.log);


	  видно, что новый оператор представляет из себя обёртку над new Observable(), в котором происходит: подписка, изменение и next изменённого значения.

=========================================================
ng-container и ng-template это обёртки. их теги не существуют в DOM, но содержимое первого отображается всегда, а содержимое второго отображается только в результате использования структурных директив.

	<!-- hide -->
	<ng-template #qwerty>qwerty</ng-template>
	 
	<!-- show -->
	<div *ngIf="true; else qwerty">zzz</div>
	 
	<!-- show -->
	<ng-container>xxxxx</ng-container>



ngTemplateOutlet это слот для вставки ng-template. если этот слот видим, то вставка производится, если нет, то не производится. 

ngTemplateOutlet можно использовать на странице несколько раз.


	<ng-template #detail> 123 </ng-template>
	 
	<div class="outer">
	  Outer Box
	  <div [ngTemplateOutlet]="detail" *ngIf="outside"></div>
	  <div class="inner">
	    inner box
	    <div [ngTemplateOutlet]="detail" *ngIf="!outside"></div>
	  </div>
	</div>
	 
	<button (click)="outside = !outside">
	  Move {{ outside ? 'inside' : 'outside' }}
	</button>

=========================================================
через ng-content можно передавать отдельный части разметки и отображать их соответственно в разных целевых контейнерах.

	<app-child>
	  <div header>This should be rendered in header selection of ng-content</div>
	  <div body>This should be rendered in body selection of ng-content</div>
	</app-child>


	<div class="header-css-class">
	  <h4>Header</h4>
	  <ng-content select="[header]"></ng-content>
	</div>
	<div class="body-css-class">
	  <h4>Body</h4>
	  <ng-content select="[body]"></ng-content>
	</div>

=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
=========================================================
========================================================