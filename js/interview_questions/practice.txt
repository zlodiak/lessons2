У нас есть 2 массива arr1 и arr2 с одинаковым содержимым [1, 2], то что выведет arr1 == arr2? Как сравнить массивы, чтобы в примере вывелось true?

================================
посчитать его сумму [5, 4, 3, 2, 1]

================================
Есть 5 горизонтальных блоков - они должны быть в одну линию (на одном уровне). Как это сделать? (Желательно с flex)

	.wrap {
	  display: flex;
	  flex-wrap: nowrap;
	  justify-content: space-between;
	  align-items: center;
	  background: red;
	  height: 100px;
	}

	  .in {
	     height: 50px;
	     background: lime;
	  }

================================-
есть шапка, есть три колонки в центральной части (левая 200, правая 200, центральная резиновая) и футер. Как это сверстать?

	<div class="wrapper">
	  <div class="header">header</div>
	  
	    <div class="main">
	      <div class="column column1">1</div>
	      <div class="column column2">2</div>
	      <div class="column column3">3</div>
	    </div>
	  
	  <div class="footre">footer</div>
	</div>


	html,
	body {
	  height: 100%;
	}

	body {
	  margin: 0;
	}

	.wrapper {
	  display: flex;
	  flex-direction: column;
	  height: 100%;
	}

	.main {
	  background: yellow;
	  display: flex;
	  flex-direction: row;
	  flex-wrap: nowrap;
	  flex-grow: 1;
	}

	.column1 {
	  width: 200px;
	}

	.column2 {
	  background: red;
	  flex-grow: 1;
	}


	.column3 {
	  width: 200px;
	}	

================================
есть два блока, один внутри другого. как позиционировать внутренний блок по центру внешнего?

	.wrap {
	  	display: flex;
		  justify-content: center;
		  align-items: center;
	    background: lime;
	    width: 300px;
	    height: 300px;    
	}

	  .in {
	    background: red;
	    width: 30px;
	    height: 30px;
	  }

================================
написать или описать скрипт палиндрома

	const word = 'topot';
	const w2rj = word.split('').reverse().join('');

	console.log('word', word)
	console.log('w2rj', w2rj)

	if(word === w2rj) {
	  console.log('is palyndrom')
	} else {
	  console.log('is not palyndrom')
	} 	

================================
написать скрипт, эмулирующий  Object.create

	function inherit(proto) {
	  function F() {}
	  F.prototype = proto;
	  var object = new F;
	  return object;
	}


================================
Как проверить что элемент массив?
Array.isArray(obj)

================================
как программно посчитать количество свойств в объекте?
	var counter = 0;
	for (let key in menu) {
	  counter++;
	}

второй способ:

	Object.keys(menu).length.


================================
написать пример функции, которая переполнить стек вызовов:

	function foo() {
	    foo();
	}
	foo();

================================
есть два объекта, связанные прототипом. написать функцию, которая выводит свойства только дочернего объекта

	const obj1 = {
	  prop1: true
	};

	const obj2 = {
	  prop2: true,
	  __proto__: obj1
	};

	for (let prop in obj2) {
	  if (obj2.hasOwnProperty(prop)) {
	  	console.log(prop);
	  }
	}


================================
есть массив, ножно преобразовать его в массив с уникальными значениями.

	const arr1 = [1, 2, 3, 2, 4];
	const arr2 = [];
	const set1 = new Set();
	arr1.forEach(v => set1.add(v));
	set1.forEach(v => arr2.push(v));


================================
Обратить массив [3, 2, 1] и посчитать его сумму

	const arr1 = [3, 2, 1];
	const arr2 = arr1.reverse().reduce((sum, value) => sum + value);
	console.log(arr3)

================================
при помощи rxjs написать код, который будет выводить в консоль название нажатой клавиши

	import { fromEvent } from 'rxjs'; 
	import { pluck, tap } from 'rxjs/operators';
	fromEvent(document, 'keyup').pipe(
	  pluck('code'),
	).subscribe(console.log);

================================
написать скрипт, который делает неглубокую копию объекта

	let user = {
	  name: "Вася",
	  age: 30,
	  meth: function(a) { console.log(a, this.name); },
	};

	let clone = {};
	for (let key in user) {
	  clone[key] = user[key];
	}

	clone.name = "Петя"; 

	console.log(user);
	console.log(clone);

	user.meth('us');
	clone.meth('cl');

второй способ:

	let user = {
	  name: "Вася",
	  age: 30,
	  meth: function(a) { console.log(a, this.name); },
	};

	let clone = Object.assign({}, user);

	clone.name = "Петя"; 

	console.log(user);
	console.log(clone);

	user.meth('us');
	clone.meth('cl');

================================
как проверить является ли число целым?

	function(num) {
	return bum % 1 === 0;
	}

================================
тут i живёт вне блока потому что её область видимости это уровень скрипта. следовательно цикл создась 4 блока, которые будут искать i во внешней области видимости. то есть после того как очередь начнёт работать она будет получать одну и ту же цифру.

  for (var i = 1; i < 5; i++) {
    setTimeout(() => console.log(i), 0);
  }

исправить можно так:

  for (let i = 1; i < 5; i++) {
    setTimeout(() => console.log(i), 0);
  }

  let помещает i в область видимости блока. соответтсвенно создастся 4 блока, в каждом из которых своё значение i. так как в замыкании внешний блок живёт пока внутренний к нему обращается, то console.log будет выводить различные значения

=====================
написать функцию, которая получала бы индекс и возвращала бы соответсвующее число Финобаччи:

  function fino(n) {
    let prev = 0;
    let next = 1;

    for (let i = 0; i < n; i++) {
      let temp = next;
      next = prev + next;
      prev = temp;
    }

    return prev;
  }

  console.log('result', fino(5));
================================
let f = function () {
  var a = 1;
  this.b = 2;
  return a;
};
f.c = 3;
console.log(f.hasOwnProperty('c')); // true
console.log(f.hasOwnProperty.c); // undefined
console.log(new f().a); // undefined
console.log(new f().b); // 2
console.log(f()); // 1

================================
const user = {
  getName: function () {
    console.log(this.userName);
  },
  userName: 'Alex',
};

user.getName.userName = 'Nick';
user.getName(); // Alex
console.log(user); // {getName: ƒ, userName: "Alex"}
console.log(user.getName); // function { name: "getName" }
console.log(user.getName.hasOwnProperty('userName')); // true
console.log(user.getName.userName); // Nick

const { getName } = user;
console.log(getName); // function { name: "getName" }
getName(); // undefined ?

--------------------------------
в предыдущем примере заменить getName на стрелочную функцию. что изменится?

================================
console.log(1);

setTimeout(function() {
	console.log(2);
})

Promise.resolve(3).then(console.log)

console.log(4);

setTimeout(function() {
	console.log(5);
})

console.log(6);


// 1 4 6 3 2 5

================================
Promise.resolve(1)
	.then(x => console.log(1))
	.catch(x => console.log(2))
	.then(x => console.log(3))

Promise.reject(2)
	.then(x => console.log(4))
	.then(x => console.log(5))
	.catch(x => console.log(6))
	.then(x => console.log(7))

// 1 3 6 7

--------------------------------
Promise.resolve(1)
  .then((x) => console.log(1))
  .catch((x) => console.log(2))
  .then((x) => console.log(3));

Promise.reject(2)
  .then((x) => console.log(4))
  // .then((x) => console.log(5))
  .catch((x) => console.log(6))
  .then((x) => console.log(7));

// 1 6 3 7


================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================