================
HTML
  
  это язык разметки страницы. разметка представляет из себя систему вложенных тегов. теги могут быть парные и одиночные. HTML в отлияие от DOM может содержать ошибки разметки, например, незакрытий парный тег. 

  XHTML более строгий язык разметки, он не прощает некоторые неточности. такие как:

    1. незакрытые теги
    2. регистр имён атрибутов
    3. логические атрибуты не в полной форме (selected="selected")

  смысл HTML в том чтобы расположить текст, картники, ссылки, видео и почие элементы в определённой последолвательности, которую потом сделает красивой CSS.

  HTML  принципе может обойтись без CSS и JS, при этом он имеет примитивные возможности стилизации, такие как bgcolor (только для body, table, tr, td), color (только для тега font), width (только для тега img, iframe, canvas).

  <!DOCTYPE html>
  <html lang="ru">
     <head>
        <meta charset="UTF-8">
        <title>HTML Document</title>
     </head>
     <body>
         123
     </body>
  </html>

  DOCTYPE

    указывает какой набор правил следует использовать для интерпретации тегов.

  HEAD

    блок, в котором содержатся неотображаемые элементы(стили, скрипты, метаинформация), а так же заголовок окна баузера

  BODY

    блок, в котором содержатся отображаемые элементы (теги). он тоже может содержать неотображаемые элементы, но лучше не использовать эту возможность.

  Если тип документа не объявлен или объявлен некорректно, браузер всегда работает в режиме quirks (режим работы движков веб-браузеров, в котором они обратно совместимы с веб-страницами, созданными для старых браузеров.).

  <!DOCTYPE> указывает, в соответствии с каким стандартом HTML написана ваша Web-страница.
  например, некоторые стандарты требуют обязательного:
    1. наличия кавычек у значений атрибутов, 
    2. нижнего регистра названий атрибутов, 
    3. закрытия даже единичных тегов, 
    4. строгую вложенность,
    5. полную форму для булевых атрибутов
    6. запрет вкладывать блочные элементы в строчные
    7. наличие описаний у картинок alt
    8. использовать собственные теги

  доктайп указывает как разрешать подобные конфликты.


================
DOM

  это объектная модель документа, которую браузер создает в памяти компьютера на основании тегов HTML-кода. то есть это представление тегов в виде объектов. при этом DOM исправляет некторые допустимые в HTML ошибки, такие как:

    1. незакрытые теги
    2. отсутствие коревого тега html
    3. отсутствие thead/tbody у таблиц

  DOM создаётся дл ятого чтобы была возможность изменять HTML средствами JS. например:

    document.body.style.background = 'red';
    document.body.addEventListener('click', () => console.log(123));

  при изменении DOM страница перерисовывается.

  теневой дом представляет из себя отдельную область видимости в обычном DOM. эта область видимости включает в себя html и css. хост-элемент это корневой элемент теневого дерева. этот элемент является обычным тегом, но не интерактивным.

  Чтобы прикрепить теневой DOM к нашему хосту, мы используем метод attachShadow().

    const shadowEl = document.querySelector(".shadow-host");
    const shadow = shadowEl.attachShadow({mode: 'open'});
    shadow.appendChild(document.createElement("a"));

  стили добавляются через:

    const styles = document.createElement("style");
    shadow.appendChild(styles);

  virtual DOM это упрощённое представление DOM. в этом случае он тоже представляет из себя объект. при изменении составляющих этого объекта формируется diff, но все изменения из этого diff разом применятся только один раз. в результате html страница перерисуется только один раз. другими словами при помощи virtual DOM изменения публикуются пакетно.

================
как встраивать скрипты?

  скрипты можно встраивать двумя способами:

    1. написав js-код между тегами script
    2. в теге script указать ссылку на внешний файл. в этом случае скрипт будет кешироваться и выглядеть более структурированным и переиспользуемым.

  при этом теги script могут находиться в секции head и body. иногда скрипты располагают в конце блока body для того чтобы их загрузка не тормозила отрисовку контента. но в современном HTML есть атрибуты defer и async, которые позволяют избежать прописывание скриптов в блоке body.

================
TAG

  это именованная метка, которая содержит некоторый контент.большая часть тегов имеют открывающий и закрывающий элемент, но встречаются одиночные теги(br, hr, img). кроме того некоторым тегом разрешено не иметь закрывающий(p, li), их действие длится до следующего блочного тега.

  возможности тегов расширяются атрибутами. с помощью атрибутов можно задать ширину, размер текста, тип шрифта, путь перехода.

  в html5 появились новые семантические теги: main, section, article, nav, aside, footer, header, time, hgroup.

================
браузеры

  состоят из браузерного движка(парсит и отрисовывает html), js-движка(парсит и исполняет js), пользовательского интерфейса (то, что видит пользователь + адресная строка), хранилища данных(оперативная память, LS, SS, indexDB, cookies), сетевого модуля(взаимодействие с сервером).

  firefox использует браузерный движок geckoб, js-движок SpiderMonkey.
  chrome использует браузерный движок blink, js-движок V8.
  safari использует браузерный движок webkit, js-движок JavaScriptCore.

================
doctype   

  объясняет браузеру, в какой версии языка разметки он сверстан. то есть по каким правилам парсить html-теги.

  до HTML5 существовало несколько версий HTML, а также более строгий вариант разметки XHTML, который не прощал некоторые виды ошибок(незакрытые теги, регистр атрибутов)

  если doctype не указан или указан неправильно, то браузер перейдёт в режим quirks, то есть будет отображать разметку в режиме обратной совместимости с древними браущерами.

  раньше браузеры отображали контент не по единосму стандарту поэтому невозможно было ввести сразу единый стандарт(многие сайты поползли бы). поэтому было решено разработчикам самим выбирать doctype. со временем везде начал использоваться строгий стандарт:

    <!DOCTYPE html>

================
span и div

  div - блочный элемент. он занимает всю строку по ширине, следовательно каждый div отображается под предыдущим элементом. высота элемента зависит от его содержимого

    <div>, <p>, <ul>, <ol>, <h1>

  вертикальные margins для блочных элементов схопываются. 

  span - строчный элемент. не занимает 100% ширины, поэтому spanы можно расположить по горизонтали. если ширины родителя не хватает, то лишний текст строчного элемента переносится на следующую строку (однако при этом элемент не принимает формы прямоугольника). высота элемента тоже зависит от его содержимого. 

    <a>, <span>, <strong>, <em>, <img>

================
поток документа

  это правила взаимодействия соседних элементов на странице. если css отключен, то блоки выстраиваются очевидным образом на основе того строчные они или блочные. 

  при помощи некоторых правил css можно элемент извлечь из потока. при этом он перестаёт взаимодействовать с соседними элементами и создаёт внутри себя новый поток.

  float отключает взаимодействие с соседними блочными элементами, но соседние строчные элементы продолжают взаимодействовать.

  position: absolute отключает взаимодействие с блочными элементами. а если применяется top/bottom/left/right, то и со строчными

================
атрибуты

  бывают глобальные (можно добавить к любому тегу: id, class, title, style, hidden). 

  бывают специфические (можно добавить только к определённым тегам: href, bgcolor, cellpadding, width)

================
атрибуты data-*

  дают возможность использовать пользовательские атрибуты, например, data-myid. получить к значениям этих атьрибутов можно из js:

    // <div class="block" data-qwerty="123">block</div>
    const el = document.querySelector('.block');
    console.log(el.dataset);  // { qwerty: '123' }

  значения могут быть только строками.

  можно наоборот создать атрибут средствами js:

  //
  el.dataset.newattr = '666';

  важно в js использовать только camelCase а в html kebab-case.

  можно удалить втрибут:

    delete element.dataset.testid

  data-* отличается от id тем, что не должен быть уникальным в пределах страницы.


================
шаблонизаторы

  позволяют не писать повторяющуюся разметку несколько раз, а создать кусок разметки и при помощи пользовательского тега include использовать его на разных страницах. например, footer, header.

  также шаблонизаторы позволяют подставлять значения в разметку (привязка значений).

  шаблонизаторы делятся на:

    1. те которые точечно вставляют в html свои динамические блоки (smarty, jinja2, django-встроенный-шаблонизатор, angular-встроенный-шаблонизатор)
    2. те которые при помощи своего синтаксиса описывают и html, и динамические блоки (PUG, HAML)

================
какими шаблонизаторами пользовались?

  HAML в ruby on Rails,
  jinja2 в django

================
как оформлять страницу для разных языков?

  нужно использовать глобальный атрибут lang, обычно его ставят в тег html. после этого специфические символы (например, кавычки) будут соответствовать указанному языку.

  Кроме того, атрибут lang позволяет браузеру понять, отличается ли язык страницы от языка вашей системы. Если да, то браузер предложит пользователю использовать онлайн-переводчик.

================
какие спецификации существуют?

  W3C

    организация, которая разрабатывает стандарты для веба. в частности она выпускает спецификации для:

      css
      html,
      xhtml,
      dom,
      xml,
      http,
      url,
      svg

  W3C и WHATWG  

  W3C изначально разрабатывала спецификацию для html, но она не успевала за новыми возможностями, которые появлялись в современных браузерах. поэтому была создана группа WHATWG, которая ориентировалась на фактические возможности браузеров. 

    WHATWG не использует номер версии потому что находится в постоянной разработке.

  WHATWG

    занимается разраблоткой стандартов DOM и HTML

  Рекомендации, применяемые W3C, открыты для общего пользования и не защищены авторским патентом. Они могут использоваться любой компанией, даже не имеющей связи с Консорциумом.  

  из WHATWG поступают предложения в W3C, которая с задержкой формирует стандарт, учитывая или отклоняя их.

================
W3C валидация
  
  это процесс проверки страницы на соответствие стандарту. дело в том, что поисковые системы уделяют внимание насколько хорошо страница соответствует стандартам. поэтому после завершения работы над страницей её полезно проверить валидатором.

  проверять можно 

    html: https://validator.w3.org/
    css: https://jigsaw.w3.org/css-validator/

  валидаторы существуют в виде онлайн-сервисов, которые имеют поле для воода url. после анализа выводится список ошибок и некритичных предупреждений.

  если ошибок нет или мало, то растёт вероятность единообразного отображения страницы во всех браузерах и отсутствия проблем с адаптивностью на мобильных устройтсвах.
  такеж это даёт некоторую гарантию, что в будущих версиях браузеров вёрстка не сломается.  


================
iFrame

  элемент, который позволяет встраивать на страницу html-документ, расположенный по другому url. например, видео с ютуба или лендинг другого сайта. вставленный таким образом контент полностью изолирован от кода страницы, в которую вставлен, однако может запускать всплывающие окна.

  src прописывается url ресурса, который вставляется.
  srcdoc прописывается html-код, который используется как заглушка, если src не подгрузился.
  onload/onerror это обработчики загрузки/ошибки. их можно использовать из js-кода.
  sandbox настраивает поведение iframe.

  для общения между родителем и iframe используется postMessage.

  от родительского элемента к iframe:

    const myiframe = document.getElementById('myIframe');
    myIframe.contentWindow.postMessage('message', '*');

  И послушайте его в iframe:

    window.onmessage = function(event){
        if (event.data == 'message') {
            console('Message received!');
        }
    };  


================
form/submit

  form предназначен для отправки данных полей на сервер. отправка происходит после клика по input type="submit"

  отправка происходит при помощи метода, указанного в атрибуте method, на адрес, указанный в атрибуте action. каждое поле помечено атрибутом name. отправляемый объект состоит из ключей всех name.

  кнопка отправки может быть такая:

    <input type="submit" value="Submit" />

  или такая:

    <button type="submit">Submit</button>

  или для отправки формы достаточно нажать энтер когда фокус находится в одном из полей

================
input/label

  кажфдый элемент формы подписан текстом. этот текст заключается в тег label. после клика на label происходит перемещение курсора на связанный инпут.

  для того чтобы связать input и label нужно поместить input в label:

    <label>Click me <input type="text" /></label>

  или использовать атрибуты for и id:

    <label for="username">Click me</label>
    <input type="text" id="username">

================
tabindex 

    атрибут, который устанавливает порядок обхода тегов при помощи клавиатуры. значение - положительное число, соответствующее порядку. если значение 0, то порядок на усмотрение браузера. если отрицательное число, то тег не может быть выделен.

    можно применять, например, для inputs. перемещаться при помощи клавиши tab.

================
input types

  input позволяет создавать различные типы элементов форм. тип формы завист от атрибута type:

    text - текстовое поле (по умолчанию, то есть type можно не указывать)
    email - поле для воода email (браузер проверит есть ли в нём @ и домен)
    tel - номер телефона (формат не проверяется)
    password - для ввода пароля (экранируется звёздочками)
    hidden - скрытое поле, не видно пользователю(для передачи csrf-токена)
    number - для ввода числа (есть стрелочки вверх-вниз)
    date/time/week/datetime - для ввода дат (пикер появляется)          
    range - диапазон чисел <input type="range" min="30" max="300">
    color - пикер для выбора цвета
    radio - единичный выбор:

      <input name="dzen" type="radio" value="nedzen"> Не дзен
      <input name="dzen" type="radio" value="dzen"> Дзен
      <input name="dzen" type="radio" value="pdzen" checked> Полный дзен

    checkbox - галочка:

          <input type="checkbox" name="favorite_pet" value="Cats">Cats
          <input type="checkbox" name="favorite_pet" value="Dogs">Dogs
          <input type="checkbox" name="favorite_pet" value="Birds">Birds

================
Семантические элементы 

  это элементы с смыслом. то есть его назначение ясно в отличие от div. кроме того поисковые системы, речевые браузеры лучше понимают значение блоков.

  старые:

    form,
    table,
    h1

  новые:
    nav (набор кнопок навигации),
    aside (дополнительное содержание),
    article (самостоятельный контент, статья),
    section (тематическая группировка контента),
    footer (нижний колонтитул),
    header (верхний колонтитул),
    main (основное содержимое)

================
что такое SVG

  это формат векторных картинок, представляет из себя XML-код. в отлиие от растровых картинок SVG масштабируется без потери качества. кроме того есть возможность применять стили.

  состоит из корневого тега svg и одного или нескольких вложенных контуров. в атрибтах тега svg содержится служебная информация, такая как:

    ссылка на спецификацию xmlns
    высота
    ширина
    окно кадрирования viewBox 
    толщина контура
    цвет контура
    цвет заливки
    признак сохранения пропорций
    класс

  встраивать svg можно :

    1. через атрибут scr тега img
    2. как css-background
    3. напрямую в html

      <a class="navigation-link" href="#">
        <svg class="navigation-icon" width="20" height="19" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="m1" fill="#000"/>
        </svg>
      </a>    

================
атрибуты SVG

  могут применяться к корневому элементу или у одному из вложенных:

    width - ширина
    height - высота
    fill - цвет заливки
    stroke - цвет контура
    stroke-width - толщина контура

================
ПО для создания SVG

  фотошоп (нарисовать картинку и использовать export as)
  фигма
  CorelDRAW
  Illustrator
  InkScape
  Vectr
  SVG-editor online 

================
SVG используется 

  для создания изображений, которые не теряют качества при масштабировании,
  для моздания картинок, которые мало весят,
  для создания редактируемых картинок

================
встраивание аудио, видео, картинок

  картинки

    если изображение имеет семантический смысл, то нужно его вставлять при помощи тега img, если нет, то можно его вставить как css-background.

    существует специальный контейнер для изображения и соответствующего ему заголовка:

      <figure>
        <img src="images/dinosaur.jpg>
        <figcaption>Museum.</figcaption>
      </figure>

    background-size можно настроить так чтобы пропорции сохранялись или по высоте или по ширине блока.

  видео

    html5 tags

      <video>
        <source src="URL" type='video/mp4'>
      </video>

    html

      <embed type="video/webm" src="movie.mp4" width="400" height="300">

    iframe

      <iframe width="560" height="315" src="https://www.youtube.com/embed/I4c7SmAAiMg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>   

    js-плеер

      скачать плеер,
      встроить его в html,
      указать источник

  аудио

    <audio controls>
      <source src="audio/music.mp3" type="audio/mpeg">
      Тег audio не поддерживается вашим браузером. 
    </audio>  


  embed используется для вставки другой страницы, видео, аудио, картинок. этот способ не рекомендуется современными браузерами

  object оже встраивает любое содержимое, но устарел

    <object
      type="video/mp4"
      data="https://www.youtube.com/watch?v=dQw4w9WgXcQ"
      width="1280"
      height="720">
    </object>

================
форматы изображений

  есть возможность отобразить наиболее подходящее изображение(с точки зрения формата или размера) или фоллбек img

    <picture>
      <source srcset="320.jpg" media="(max-width: 800px)">
      <img src="640.jpg" alt="Абстрактное изображение">
    </picture>

  распространённые форматы: jpeg, png, svg, gif, png. 
  но на смену им приходят более современные: webP, avif, JPEG XL, HEIC.
  нельзя использовать форматы, которые открываются при помощи редактора: psd, cdr, xcf

================
SEO

  это оптимизация сайта, в результате которой он находится выше в результатах поисковиков. существуют факторы, на которые разработчик может повлиять и факторы, на которые разработчик не может повлиять.

  разработчик не может влиять на количество внешних ссылок, которые ведут на сайт. время жизни домена.

  разработчик может влиять на следующие акторы:

    1. сделать семантическую вёрстку на сайте
    2. увеличить скорость загрузки сайта
    3. использовать адаптивную вёрстку
    4. добавить robots.txt (перечисляет имена файлов, на которые поисковик смотреть не должен), sitemap.xml (полный список ссылок, которые должны попасть в БД поиска)
    5. уникальность текста

================
скринридеры

  это вспомогательная технология, которая озвучивает контент сайта для людей с ограниченными возможностями. скринридер активно использует возможности семантической вёрстки, а когда их не хватает, то атрибут ARIA.

  скринредер работает на дереве доступности, которое почти в точности копирует дерево DOM за исключением невидимых и декортаивных элементов.

ARIA

  это вспомогательные атрибуты, которые дают скринридерам дополнительную информацию о роли элемента, состоянии, свойствах.

  роль

    это назначение элемента. например button это кнопка, но если кнопку нужно сделать на основе div, то чтобы скринридер её увидел нужно использовать role="button"

  состояние

    это один из режимов показа блока, который может изменяться. напримерь раскрывающаяся панель может быть в двух состояниях:

      aria-expanded=”true”

  свойство

    это один из режимов показа блока, который НЕ может изменяться. например input может быть обязательным для заполнения:

      <input type="password" aria-describedby="pass-requirements">      

================
метатеги

  содержат дополнительную информацию о странице для поисковиков, соц.сетей, браузеров. прописываются в секции head. в большинстве случаев содержат два атрибута:

    name,
    content

  meta charset 

    информация о кодировке

  meta description

    строка для вывода результатов в поисковике

  meta keywords

    слова, описывающие контент страницы. в настоящее время не учитываются поисковиками из-за злоупотреблений

  meta refresh

    количество секунд, через которое произойдёт переход на другую страницу

  meta viewport

    параметры окна при просмотре на мобильном устройстве    

================
способы оптимизации страницы

  1. использовать отдельные файлы для css и js. в этом случае браузер их кеширует и не загружает повторно.

  2. заранее оптимизировать качество изображения. то есть чтобы не приходилось большую по размеру картинку сжимать до маленькой средствами css.

  3. загружать скрипты в конце документа или использовать defer|async

  4. использовать CDN. то есть составные части страницы будут загружаться с более близко расположенных серверов.

  5. использовать css-анимации вместо js-анимаций

  6. использовать делегирование событий (например не вешать обработчики на каждую кнопку меню, а вешать только на родительский блок)

  7. использовать варианты debounce

  8. уменьшить количество запросов путём замены загрузки картинок через src="path" на src="data: . то есть захардкодить картинки.

  9. использовать css-спрайты. то есть много иконок расположить в пределах одной картинки и средствами css вырезать нужные.

  10. объединение нескольких внешних файлов в один.

  11. минимизация файла (удаление лишних символов с целью уменьшения объёма)

  12. использовать алгоритмы сжатия(gzip). включается в настройках сервера.

  13. 

================
google page speed

  онлайн инструмент для оценки производительности страницы вне зависимости от качества интернет-соединения. даёт информацию о минимальном времени после которого:

    1. отрисуется первый графический объект
    2. отрисуется первый наиболее крупный графический объект
    3. пользователю станут доступны интерактивные элементы
    4. отрисуется весь контент
    5. насколько сильно смещается контент во время загрузки соседних элементов

  учитываются только не зависящие от типа интернет-соединения факторы: JavaScript, CSS, структура HTML, конфигурация сервера, размер изображений и т. д.

  запускается встраиванием скрипта в html. после загрузки страница будет отображать метрики

lighthouse

  подобный инструмент от компании google, тоже даёт оценку производительности и даёт рекомендации как её улучшить.

  способы использования:

    1. chromedevTools
    2. npm install -g lighthouse
    3. chrome plugin

  оценивает:

    1. доступность
    2. использования лучших практик
    3. может ли PWA работать без доступа в интернет
    4. скорость загрузки
    5. наличие адаптивной вёрстки

    используется через вкладку в dev tools

================
что такое defer и async?

  в процессе загрузки страницы может получиться так, что подключенный скрипт блокирует отрисовку html. чтобы решить эту проблему в элемент скрипта можно добавить атрибут defer. в этом случае скрипты начнут загружаться в фоновом режиме, а запустятся только после того как html отрисован(событие DOMContentLoaded). порядок скриптов сохраняется. defer используется когда этим скриптам необходим доступ к элементам страницы.

  также можно пометить скрипт атрибутом async. в этом случае скрипты загружаются в фоновом режиме. порядок не сохраняется. запускаться они будут по мере загрузки. async используется когда скриптам не нужен доступ к элементам страницы, например, счётчики посещений и статистика от гугла.

================
порядок загрузки страницы

  1. загрузка index.html
  2. парсинг html
  3. если встречаются неблокирующие ресурсы(картинки), то они запрашиваются с сервера параллельно с парсингом. если попадаются блокирующие ресурсы(скрипты, стили), то их запрос ссервера приостанавшивает парсинг.
  4. строится DOM
  5. строится CSSOM
  6. DOM и CSSOM объединяются в Render Tree
  7. отрисовка элементов страницы
  8. если есть css-анимации, то происходит добавление слоёв, в котрых отрисовка не затрагивает соседние элементы

================
================
================
================
================
================
================
================

как запретить ввод отрицательных чисел в input?

  <input matInput type="number" min="0" oninput="validity.valid||(value='')" />

================
================
================
================
================
================