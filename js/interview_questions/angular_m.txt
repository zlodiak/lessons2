SOLID

1. принцип единой ответственности
	Класс должен иметь только одну ответственность. ("Класс должен иметь одну и только одну причину для изменений").

	например, есть класс, который описывает данные пользователя. если этот класс включает правила валидацтт email тоже, то этот класс нарушает принцип. 

	нужно вынести правила валидации email в отдельный класс.

2. принцип открытости-закрытости
	Программные сущности должны быть открыты для расширения и закрыты для модификации.

	например есть функция, которая на основе полученного экземпляра класса вычисляет площать фигуры. эта функция при помощи блока if определяет фигуру и вычисляет результат. проблема в том, что если появится новая фигура, то придётся изменять уже написанный функционал. 

	здесь необходимо в каждый класс фигуры добавить метод getArea. таким образом придётся функция будет вызывать метод получения площади у любого полученного экземпляра.

3. принцип подстановки Барбары Лисков.
	Необходимо, чтобы подклассы могли бы служить заменой для своих родительских классов.

	в предыдущем примере функция получала инстанс фигуры для вычисления площади. должно быть так чтобы она могла принимать любой инстанс, который реализует класс фигуры.

4. принцип разделения интерфейсов.
	Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.

	если есть несколько классов фигур и требуется описать их при помощи интерфейсов, то создавать один жирный интерфейс будт неправильно. нужно создать несколько и класс каждый фигуры имплементировать от нескольких мелких.

5. принцип инверсии зависимостей
	стараться использовать в качестве зависимостей интерфейсы а не конкретные их реализации. или модули верхних уровней не должны зависеть от модулей нижних уровней, оба типа модулей должны зависеть от абстракций.

	например, пусть компонент ангулара инжектирует сервис. внутренняя рализация сервиса может быть любой, но он реализует определённый интерфейс. реализация на низком уровне может измениться, но если интерфейс остался прежним, то компонент не почувствует разницы. потому что он не зависит от конкретной реализации.

------------------------------------------------------
внедрение зависимостей — это метод, с помощью которого объект получает другие объекты, от которых он зависит, называемые зависимостями, а не создает их сам.

	import { Engine } from './Engine';

	class Car {
	    private engine: Engine;

	    public constructor (engine: Engine) {
	        this.engine = engine;
	    }
	    
	    public startEngine(): void {
	        this.engine.fireCylinders();
	    }
	}



dependency injection делится на 3 вида:

1. constructor injection. в этом случае зависимость передаётся через конструктор класса и далее присваивается свойству класса

class A:
	def __init__(self, logger):
		self.logger = logger

2. method injection. в этом случае зависимость передаётся через метод класса и в большинстве случаев на присваивается свойству класса, но присваивается локальной переменной метода

class A:
	def set_logger(self, logger):
		logger_obj = logger
		logger_obj.write('blabla')

3. property injection. в этом случае зависимость приравнивается свойству объекта

a = A()
a.prop = B()

------------------------------------------------------
рассказать об основных принциипах ООП

Инкапсуляция — ограничение доступа к составляющим объект компонентам.
инкапсуляция  в js действует только на уровне соглашений. но в ES6 появился знак #, при помощи которого можно установить приватность переменной или метода.

наследование связывает классы. при этом потомок содержит все методы и свойства родителя.
самый верхний объект для классов это object. 

полиморфизм это когда в различных классах методы с одинаковыми названиями выполняют различные действия.

	'qwerty'.length
	6
	[1, 2, 3, 4].length
	4

в TS инкапсуляция реализована при помощи модификаторов доступа: public, private, protected.
В TypeScript наследование реализуется с помощью ключевого слова extends
в TS полиморфизм доступен через несколько объявлений одной функции о одной реализации с максимально общим типом:
	function add(x: string, y: string): string;
	function add(x: number, y: number): number;
	function add(x: any, y: any): any {
	    return x + y;
	}
	 
	let result1 = add(5, 4);      // 9
	let result2 = add("5", "4");  // 54

------------------------------------------------------
mvvm

model - сервисы. содержат данные

view - html,css. разметка и стили

modelView - контроллер, в котором есть данные из модели, и данные из шаблона. и методы, которые могут их менять.

------------------------------------------------------
отличие промиса от observable.

observable это типизированный объект, который следит за событиями. на него можно подписаться, после этого он начнёт многократно отдавать значения.
promise тоже следит за событием, но отдаёт результат только один раз.

------------------------------------------------------
отличие конструктора от ngOnInit

конструктор это не часть ангуляра, а часть ES6. он выполняется раньше хуков. в конструкторе недоступны входные параметры компонента.

------------------------------------------------------
что такое generics в ts

Обобщённый тип позволяет резервировать место для неизвестного типа, который будет заменён на конкретный, переданный пользователем(явно или не явно).

	function identity<T>(arg: T): T {
		return arg;
	}

Конструкция <T> после имени функции указывает на то, что эта функция собирается захватить тип и подменить им все T. при вызове этой функции нужно явно указывать обобщённый тип:

	identity<number>(115);

но можно вызвать и так. в этом случае обобщённый тип в угловых скобках определится автоматически:

	identity('string');

------------------------------------------------------
HTTP

Чтобы отобразить веб страницу, браузер отправляет начальный запрос для получения HTML-документа этой страницы. После этого браузер изучает этот документ, и запрашивает дополнительные файлы, необходимые для отбражения содержания веб-страницы (исполняемые скрипты, информацию о макете страницы - CSS таблицы стилей, дополнительные ресурсы в виде изображений и видео-файлов), которые непосредственно являются частью исходного документа, но расположены в других местах сети. Далее браузер соединяет все эти ресурсы для отображения их пользователю в виде единого документа — веб-страницы.

после ввода адреса в адресную строку формируется запрос, который состоит из 3 составляющих: 
	метод, 
	путь к ресурсу, 
	версия http-протокола,
	заголовки запроса,
	тело запроса (присутствует на всегда, зависит от метода запроса)

ответ сервера содержит: 
	версию http-протокола, 
	код ответа, 
	человекточитаемый статус ответа, 
	заголовки ответа, 
	тело ответа (присутствует на всегда, зависит от метода запроса)

Пример запроса:
    GET http://ya.ru/index.html HTTP/1.1

Пример ответа:
    HTTP/1.1 200 Ok


методы:
	OPTIONS - используется для проверки возможностей сервера. в частности для случая кроссдоменных запросов.
	GET - Используется для запроса содержимого указанного ресурса.
	HEAD - Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело.
	POST - предназначен для передачи данных на сервер. при повторении не обязательно возвращает одинаковые результаты. в контексте REST используется для изенения данных. предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого.
	PUT - 
	PATCH - 
	DELETE - удаляет ресурс.


Код состояния информирует клиента о результатах выполнения запроса. 
	1** - информационный
	2** - успешно
	3** - редирект
	4** - ошибка на строне клиента
	5** - ошибка на стороне сервера

	200 - ОК
	404 - not found
	401 - запрещено
	500 - ошибка сервера


Заголовок HTTP (HTTP Header) — это строка в HTTP-сообщении, содержащая разделённую двоеточием пару вида «параметр-значение

HTTP-заголовки разделяются на четыре основных группы:
General Headers (Основные заголовки) — должны включаться в любое сообщение клиента и сервера.
Request Headers (Заголовки запроса) — используются только в запросах клиента.
Response Headers (Заголовки ответа) — присутствуют только в ответах сервера.
Entity Headers (Заголовки сущности) — сопровождают каждую сущность сообщения.

Присутствие тела сообщения в запросе отмечается добавлением к заголовкам запроса поля заголовка Content-Length или Transfer-Encoding.

------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------