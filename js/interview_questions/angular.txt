================================
================================
что такое change detection в angular?

================================
какие виды связывания есть в angular?

================================
чем отличаются pure и impure пайпы?

если в пайп передан объект, то pure пайп отслеживает любое изменение внутри объекта, а impure отслеживает изменения только если ссылка на объект изменилась. по умолчанию  действуют Pure пайпы.

================================
чем в ангуляре отличаются компоненты и директивы?

директива не имеет шаблона потому что работает с существующим в DOM элементом. в остальном она является компонентом.

================================
какие виды директив бывают в ангуляре?

структурные(изменяют поведение), атрибутивные(создают и удаляют элементы в DOM)

================================
что такое жизненный цикл компонента в ангуляр? описать основные хуки

================================
что такое резолвер в ангуляр?

================================
что такое route guards в ангуляр?

RG ограничивают навигацию по определённым маршрутам.

сначала создаётся отдельный файл гуарда, в котром есть класс, реадизующий интерфейс, например, canActivate. метод canActivate возвращает булево значение. затем имя этого класса используется в роутере:

    { 
        path: 'about', 
        component: AboutComponent, 
        canActivate: [AboutGuard],
    }

при этом существуют другие типы гуардов:

	canActivate - для проверки доступа к роуту
	canDeactivate - для проверки ухода с роута
	resolve - выполняет действие перед переходом на роут

================================
что такое tree shaking? где для него прописываются настройки?

включается в webpack.config.js. а файлы-исключения указываются в package.json

================================
что такое веб-воркеры?

это механизм, который предоставляет возможность запускать скрипт в отдельном процессе. 
после создания веб-воркера через cli создастся файл веб воркера и шаблонный код в компоненте, для которого он создан.
таким образом из компонента можно будет отправлять сигналы на совершение определённого действия. при этом ответы веб-воркера будут в компоненте же отлавливаться при помощи onmessage и onerror

веб-воркеры бывают выделенные и разделяемые. первые работают только с одним компонентом, вторые - со многими.

================================
что такое сервис-воркеры?

СВ это система кеширования, которая была добавлена в ангуляр. все запросы проходят через СВ. после первого запроса весь ответ кешируется. при последующих запросах сравниваются контрольные суммы принятных файлов. если они не отличаются, то пользователю отдаются ране загруженные файлы.
контрольные суммы хранятся в manifest.json, который создаётся в момент сборки приложения.

================================
что такое jit и aot?

AOT или Ahead-of-Time – вариант компиляции приложения(альтернатива JIT или Just-in-time), которая выполняется один раз при сборке приложения. JIT выполняется каждый раз при запуске приложения в браузере.

================================
что такое HostListener?

это декоратор, который связывает события DOM и обработчик. например после наведения курсора должен вывестись console.log

    @HostListener("mouseenter") 
    onMouseEnter() {
        console.log('start');
    }

при этом возможно отлавливать события не только на элементе директивы, но и на window. здесь второй аргумент это то, что передаётся в обработчик когда событие произойдёт.

	@HostListener('window:keyup', ['$event'])
	KeyUp(event: KeyboardEvent) {
		console.log("KeyUp", event);
	}


================================
что такое HostBinding?

это декоратор, который связывает свойство компонента со свойством элемента

	private fontWeight = 'bold'

	@HostBinding('style.fontWeight') 
	get getFontWeight() {
		return this.fontWeight;
	}

================================
что такое модуль в angular?

модуль это контейнер, который содержит структурные компоннеты приложение: компоненты, директивы, пайпы, сервисы. модули могут быть вложенными. 
типы модулей:
CoreModule - содержит сервисы, общие для всего приложения.
SharedModule - содержит компоненты, директивы и фильтры для всего приложения.
RoutingModule - содержит описание роутов и соответствующих им компонентов.
корневой - он загружается в первую очередь и содержит второстепенные модули.

технически модуль представляет собой класс с декоратором ngModule. декоратор содержит следующие поля:
declarations - для описания использующихся компоннетов, директив, пайпов.
imports - для импорта других модулей
exports - для описания функци

================================
что такое change detection?

в ангуляре компоннеты вложены друг в друга. таким образом компонентная структура представлена в виде дерева, на вершине которой корневой компонент. с каждым компонентом связан шаблон, через который посредством квадратных скобок значения могут передаваться более глубоким компонентам. механизм CD следит за тем чтобы значение в компоненте соответствовало значению в шаблоне, тем самым обеспечиваю передачу значений вглубь.

CD запускается при: браузерном событии, http-запросе, timeout/interval

Сервис ChangeDetectorRef может управлять CD в том компоненте, в который он импортирован.

стратегия onPush тоже управляет CD. если она включена в компоненте, то в нём будет отслеживаться входящие Input-данные только в том случае, если будет изменяться ссылка на объект. при default стратегии отслеживаются входящие данные даже если меняются составные части объекта, это не экономно с точки зрения производительности.


================================
что такое сервис?

сервис это класс, которые хранит состояние или используется в качестве поставщика данных. он может быть определён на уровне:
приложения(синглтон),
модуля(синглтон),
компонента(НЕ синглтон)

все сервисы регистрируются инжектором, который делится на несколько уровней. если компоненту нужен сервис, то поиск начинается с нижнего уровня и идёт выше. но этот порядок может быть изменён при помощи декораторов @SkipSelf()

================================
что такое @viewChild?

при помощи viewChild можно получить доступ к вложенному компоненту. допустим в компонент импортирован вложенный компонент:

	import { ChildComponent } from './child.component';

в этом случае обратиться к нему можно так:

	@ViewChild(ChildComponent) 
	child: ChildComponent;
	ngAfterViewInit() {
		console.log(this.child.whoAmI());
	}	

то же самое будет, если вложенный компонент не импортирован, а указан в шаблоне:

	<input #someInput placeholder="Your favorite pizza toping">

	@ViewChild('someInput') someInput: ElementRef;
	ngAfterViewInit() {
		this.someInput.nativeElement.value = "qwerty";
	}	

================================
что такое шаблонная переменная?

это помеченный # элемент в шаблоне. на который можно ссылаться из шаблона же:

	<input type="text" [(ngModel)]="name" #username />
	<p>{{username.value}}</p>

и из компонента:

	<div #editor id="jsoneditor">

	@ViewChild('editor') 
	editor: ElementRef;
	this.editor.nativeElement.innerHTML  = 'qwerty';

================================
как отписаться от потока?

первый способ: 
1. создать переменную типа ISubscription
2. присвоить ей поток
3. в хуке ngOnDestroy или в блоке next прописать .unsubscribe()

второй способ:
1. создать s = Subject
2. .pipe(takeUntil(s))
3. в хуке ngOnDestroy использовать this.s.next();

третий способ:
1. в шаблоне использовать async pipe

================================
что такое ngrx?

это шаблон, позволяющий централизировать изменения состояния. когда проект становтся большим, то состояния могут быть изменены из разных мест программы. это приводит к ошибкам и трудностям юнит-тестирования.

ngrx предполагает наличие глобального стейта, при изменении которого каждый раз создаётся клон с добавленными изменениями. таким образом в приложении есть только один источник правды.

редюсер содержит условный оператор, который на основе входящего сигнала(экшена) изменяет стейт. и возвращает изменённую копию.

экшен это название действия в виде строки, которое отправляется в редюсер. возможно, с полезной нагрузкой.

для повышения производительности стейт можно запрашивать частями. например, если требуется на экране отобразить определённую часть стейта.

================================
какие подходы к мультиязычности существуют?

пакет ngx-translate (https://stackblitz.com/edit/ngx-translate-example):
в этом случае после подключения его в главный модуль приложения необходимо в assets создать в формате json описания констант и соответвтующие им переводы. для каждого языка отдельный файл. далее в компоненте нужно инжектировать сервис TranslateService и использовать его в шаблоне как pipe для описанной константы:

	<h2>{{ 'HOME.TITLE' | translate }}</h2>

язык можно менять динамически, используя метод 
	
	TranslateService.use('en-US')

================================
как можно проводить тестирование?

в angular можно использовать jest юнит-тесты. они могут быть изолированные и неизолированные.

в первом случае класс не имеет зависимостей и тестируется как изолированный функционал.

во втором случае необходимо перед каждым тестом создать сруду при помощи встроенного фреймворка testBed. создание среды предполагает эмуляцию компонента и установка зависимостей. в этом случае обычно сервисы, пайпы и прочие зависимости заменяют на моковые данные.

================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
