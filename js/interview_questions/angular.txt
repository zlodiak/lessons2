================================
какие виды связывания есть в angular?

================================
чем отличаются pure и impure пайпы?

если в пайп передан объект, то pure пайп не отслеживает любое изменение внутри объекта, а impure отслеживает изменения внутри объекта. по умолчанию  действуют Pure пайпы.

================================
чем в ангуляре отличаются компоненты и директивы?

директива не имеет шаблона потому что работает с существующим в DOM элементом. в остальном она является компонентом.

================================
какие виды директив бывают в ангуляре?

атрибутивные(изменяют поведение), структурные(создают и удаляют элементы в DOM)

================================
что такое жизненный цикл компонента в ангуляр? описать основные хуки

================================
что такое резолвер в ангуляр?

Резолверы в Angular используются для предварительной выборки данных: пока пользователь перенаправляется с одного маршрута на другой, новая доступная страница уже будет содержать те данные, которые требуется на ней отобразить.

================================
что такое route guards в ангуляр?

RG ограничивают навигацию по определённым маршрутам.

сначала создаётся отдельный файл гуарда, в котром есть класс, реализующий интерфейс, например, canActivate. метод canActivate возвращает булево значение. затем имя этого класса используется в роутере:

    { 
        path: 'about', 
        component: AboutComponent, 
        canActivate: [AboutGuard],
    }

при этом существуют другие типы гуардов:

	canActivate - для проверки доступа к роуту
	canDeactivate - для проверки ухода с роута
	resolve - выполняет действие перед переходом на роут

================================
что такое tree shaking? где для него прописываются настройки?

Tree shaking (Встряхивание дерева) — это метод оптимизации библиотек путем удаления любого кода из окончательного файла, который фактически не используется.

включается в webpack.config.js. а файлы-исключения указываются в package.json

================================
что такое веб-воркеры?

это механизм, который предоставляет возможность запускать скрипт в отдельном процессе. 
после создания веб-воркера через cli создастся файл веб воркера и шаблонный код в компоненте, для которого он создан.
таким образом из компонента можно будет отправлять сигналы на совершение определённого действия. при этом ответы веб-воркера будут в компоненте же отлавливаться при помощи onmessage и onerror

веб-воркеры бывают выделенные и разделяемые. первые работают только с одним компонентом, вторые - со многими.

  // webWorker-demo/src/app/webWorker.ts
  function fibonacci(num) {
      if (num == 1 || num == 2) {
          return 1
      }
      return fibonacci(num - 1) + fibonacci(num - 2)
  }
  self.addEventListener('message', (evt) => {
      const num = evt.data
      postMessage(fibonacci(num))
  })


  // webWorker-demo/arc/app/app.component.ts
  @Component({
      selector: 'app',
      template: `
          <div>
              <input type="number" [(ngmodel)]="number" placeholder="Enter any number">
              <button (click)="calcFib">Calc. Fib</button>
          </div>
          <div>{{output}}</div>
      `
  })
  export class App implements OnInit{
      private number
      private output
      private webworker: Worker
      ngOnInit() {
          if(typeof Worker !== 'undefined') {
              this.webWorker = new Worker('./webWorker')
              this.webWorker.onmessage = function(data) {при
                  this.output = data
              }
          }
      }
      calcFib() {
          this.webWorker.postMessage(this.number)
      }
  }

================================
что такое сервис-воркеры?

СВ это система кеширования, которая была добавлена в ангуляр. все запросы проходят через СВ. после первого запроса весь ответ кешируется. при последующих запросах сравниваются контрольные суммы принятных файлов. если они не отличаются, то пользователю отдаются ране загруженные файлы.
контрольные суммы хранятся в manifest.json, который создаётся в момент сборки приложения.

================================
что такое jit и aot?

AOT или Ahead-of-Time – вариант компиляции приложения, которая выполняется один раз при сборке приложения. JIT выполняется каждый раз при запуске приложения в браузере.

================================
что такое HostListener?

это декоратор, который связывает события DOM и обработчик. например после наведения курсора должен вывестись console.log

    @HostListener("mouseenter") 
    onMouseEnter() {
        console.log('start');
    }

при этом возможно отлавливать события не только на элементе директивы, но и на window. здесь второй аргумент это то, что передаётся в обработчик когда событие произойдёт.

	@HostListener('window:keyup', ['$event'])
	KeyUp(event: KeyboardEvent) {
		console.log("KeyUp", event);
	}


================================
что такое HostBinding?

это декоратор, который связывает свойство компонента со свойством элемента

	private fontWeight = 'bold'

	@HostBinding('style.fontWeight') 
	get getFontWeight() {
		return this.fontWeight;
	}

================================
что такое модуль в angular?

модуль это контейнер, который содержит структурные компоненты приложение: компоненты, директивы, пайпы, сервисы. модули могут быть вложенными. 
типы модулей:
CoreModule - содержит сервисы, общие для всего приложения.
SharedModule - содержит компоненты, директивы и фильтры для всего приложения.
RoutingModule - содержит описание роутов и соответствующих им компонентов.
корневой - он загружается в первую очередь и содержит второстепенные модули.

технически модуль представляет собой класс с декоратором ngModule. декоратор содержит следующие поля:
declarations - для описания использующихся компоннетов, директив, пайпов.
imports - для импорта других модулей
exports - для описания функци

================================
что такое change detection?

в ангуляре компоннеты вложены друг в друга. таким образом компонентная структура представлена в виде дерева, на вершине которой корневой компонент. с каждым компонентом связан шаблон, через который посредством связывания значения могут передаваться более глубоким компонентам. механизм CD следит за тем чтобы значение в компоненте соответствовало значению в шаблоне, тем самым обеспечиваю передачу значений вглубь.

CD запускается при: браузерном событии, http-запросе, timeout/interval

Сервис ChangeDetectorRef может управлять CD в том компоненте, в который он импортирован.

стратегия onPush тоже управляет CD. если она включена в компоненте, то в нём будет отслеживаться входящие Input-данные только в том случае, если будет изменяться ссылка на объект. при default стратегии отслеживаются входящие данные даже если меняются составные части объекта, это не экономно с точки зрения производительности.

================================
описать хуки жизненного цикла.

ngOnChange срабатывает только когда ссылка Input элемента меняется. но не срабатывает когда меняется внутренняя часть Input объекта. это не зависит от типа стратегии.

в том случае, если изменяется внутренняя часть Input объекта, то имеет значение стратегия. в частности OnPush разрешает отслеживать в шаблоне только изменение ссылки. а  Default разрешает отслеживать в шаблоне такжеи зменение внутренней части объекта.

ngDoCheck срабатывает при любой стратегии. и при любом изменении Input объекта (и по ссылке, и по внутренней части). кроме того этот хук срабатывает при любом 
событии компонента.

таким образом при помощи ngDoCheck можно обойти ограничение стратегии OnPush:
  ngDoCheck() {
      if (this.id !== this.o.id) {
        this.cd.markForCheck();
        this.id = this.o.id;
      }
    }

ngAfterViewInit, ngAfterViewChecked срабатывают когда отрисовался встроенный при помощи тега компонент. и когда он был изменён.

ngAfterContentInit, ngAfterContentChecked срабатывают когда отрисовался встроенный при помощи ng-content компонент. и когда он был изменён.


================================
что такое сервис?

сервис это класс, которые хранит состояние или используется в качестве поставщика данных. он может быть определён на уровне:
приложения(синглтон),
модуля(синглтон),
компонента(НЕ синглтон)

все сервисы регистрируются инжектором, который делится на несколько уровней. если компоненту нужен сервис, то поиск начинается с нижнего уровня и идёт выше. но этот порядок может быть изменён при помощи декораторов @SkipSelf()

================================
что такое @viewChild?

при помощи viewChild можно получить доступ к вложенному компоненту. допустим в компонент импортирован вложенный компонент:

	import { ChildComponent } from './child.component';

в этом случае обратиться к нему можно так:

	@ViewChild(ChildComponent) 
	child: ChildComponent;
	ngAfterViewInit() {
		console.log(this.child.whoAmI());
	}	

то же самое будет, если вложенный компонент не импортирован, а указан в шаблоне:

	<input #someInput placeholder="Your favorite pizza toping">

	@ViewChild('someInput') 
	someInput: ElementRef;
	ngAfterViewInit() {
		this.someInput.nativeElement.value = "qwerty";
	}	

================================
что такое шаблонная переменная?

это помеченный # элемент в шаблоне. на который можно ссылаться из шаблона же:

	<input type="text" [(ngModel)]="name" #username />
	<p>{{username.value}}</p>

и из компонента:

	<div #editor id="jsoneditor">

	@ViewChild('editor') 
	editor: ElementRef;
	this.editor.nativeElement.innerHTML  = 'qwerty';

================================
как отписаться от потока?

первый способ: 
1. создать переменную типа ISubscription
2. присвоить ей поток
3. в хуке ngOnDestroy или в блоке next прописать .unsubscribe()

второй способ:
1. создать s = Subject
2. .pipe(takeUntil(s))
3. в хуке ngOnDestroy использовать this.s.next();

третий способ:
1. в шаблоне использовать async pipe

четвёртый способ:
использовать стороннюю библиотеку с методом untilDestroy().

================================
что такое ngrx?

это шаблон, позволяющий централизировать изменения состояния. когда проект становтся большим, то состояния могут быть изменены из разных мест программы. это приводит к ошибкам и трудностям юнит-тестирования.

ngrx предполагает наличие глобального стейта, при изменении которого каждый раз создаётся клон с добавленными изменениями. таким образом в приложении есть только один источник правды.

редюсер содержит условный оператор, который на основе входящего сигнала(экшена) изменяет стейт. и возвращает изменённую копию.

экшен это название действия в виде строки, которое отправляется в редюсер. возможно, с полезной нагрузкой.

для повышения производительности стейт можно запрашивать частями. например, если требуется на экране отобразить определённую часть стейта.

================================
какие подходы к мультиязычности существуют?

пакет ngx-translate (https://stackblitz.com/edit/ngx-translate-example):
в этом случае после подключения его в главный модуль приложения необходимо в assets создать в формате json описания констант и соответвтующие им переводы. для каждого языка отдельный файл. далее в компоненте нужно инжектировать сервис TranslateService и использовать его в шаблоне как pipe для описанной константы:

	<h2>{{ 'HOME.TITLE' | translate }}</h2>

язык можно менять динамически, используя метод 
	
	TranslateService.use('en-US')

================================
как можно проводить тестирование?

в angular можно использовать jest юнит-тесты. они могут быть изолированные и неизолированные.

в первом случае класс не имеет зависимостей и тестируется как изолированный функционал.

во втором случае необходимо перед каждым тестом создать среду при помощи встроенного фреймворка testBed. создание среды предполагает эмуляцию компонента и установка зависимостей. в этом случае обычно сервисы, пайпы и прочие зависимости заменяют на моковые данные.

================================
что такое control value accessor?

CVA позволяет кастомный компонент связать с элементом реактивной формы и наладить двустороннюю связь между ними.

в элементы input, select и т.д. CVA встроен изначально. но можно сделать рейтинг из 5 звёзд и привязать количество звёзд к полю реактивной формы:

    this.galaxyForm = new FormGroup({
      galaxy: new FormControl({value: null, disabled: false}, [Validators.required]),
      rating: new FormControl({value: 2, disabled: true}, [Validators.required]),
      name: new FormControl({value: null, disabled: false}, [Validators.required])
    });

------------
в коде выше значение rating инициализируется двойкой. соответственно в кастомном компоненте сработает:

  writeValue(val) {
    console.log('writeValue', val)
    this._value = val;
  }

 таким образом срабатывает связь от формы к компоненту.

------------
в кастомном компоненте есть обработчик события (click). после того как пользователь кликнет на звезду, он сработает:

  setRating(star: any) {
  	this._value = star.stars;
  	this.ratingText = star.text
  	this.onChanged(star.stars);
  }

  public _value: number;
  onChanged: any = () => {}
  
  registerOnChange(fn: any){
    this.onChanged = fn
  }

в результате значение star.stars будет отправлено в реактивную форму(при этом также сработает writeValue).

================================
что такое динамический компонент?

ДК это компоненты, которые при помощи фабрики создаются во время исполнения программы на основе единственного шаблона. при этом получают различающиеся данные инициализации. ДК создаются уже в скомпилированном приложении в момент его работы.

шаблон представляет из себя обычный компоннет с опционально входящими переменными. он так же как и обычный компонент импортируется в модуль.

далее в компонент, который управляет ДК испортируется фабрика ComponentFactoryResolver. ей скармливается шаблон ДК, после чего сгенерированный ДК можно инициализировать и встраивать в шаблон родителя. фабрика может таким образом генерировать множество однотипных ДК.

  @ViewChild('container', { read: ViewContainerRef }) container: ViewContainerRef;
  private _counter = 1;
  constructor(private componentFactoryResolver: ComponentFactoryResolver) { }
  add(): void {
    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(DynamicComponent);
    const componentRef = this.container.createComponent(componentFactory);
    componentRef.instance.index = this._counter++;
  }

тут больше: 
https://stackblitz.com/edit/angular-dynamic-components-example-f2fbvx

================================
что нового?

1.  автоматическая подгрузка и встраивание шрифтов перед компиляцией.
2.  в тесты добавлена возможность управлять обнаружением изменений и запускать несколько синхронных взаимодействий одновременно.
3.  обновлён формат вывода логов и отчётов в CLI
4.  стало прще включать Hot Module Replacement: ng serve --hmr
      - страница не обновляется вся при добавлении новго модуля
      - при добавлении модуля сохраняется состояние переменных
      - действует только в режиме разработки
5.  увеличена скорость компиляции TS
6.  Экспериментальная поддержка webpack 5
7.  отказ от поддержки TSLint в пользу ESLint
8.  отказ от IE. поддерживается только IE11


================================
на каком шаблоне построен angular?

mvvm

model - сервисы. содержат данные

view - html,css. разметка и стили

modelView - контроллер, в котором есть данные из модели, которые подлежат связыванию. и методы, которые могут их менять.

================================
что такое ng-container и ng-template?

ng-container это элемент, который удаляется из разметки после компиляции. его удобно использовать для структурных директив типа *ngFor.

ng-template тоже удаляется из разметки после компиляции, но его содержимое можно вернуть в разметку, например, при помощи *ngIf или ngSwitch.

================================
знак ! это просто сигнал компилятору TS о том, что значение, которое находится перед этим знаком не будет равно undefined или null. 
знак можно использовать для входящих Input-параметров или для любого участка кода, например, для массива/объекта, у которого берётся значение по индексу.
так же возможно использование для asyncPipe. например для случая behaviorSubject, которое не может быть пустым с принципе.

================================
инжектор это иерархическая структура, которая хранит инстансы зависимостей, которые используются компонентами и модулями. зависимость может быть инжектирована в компонент или модуль через конструктор. при этом важно прописать название класса в providers или в одном из родительских providers.
 
таким образом если одна и та же зависимость используется несколькими сущностями, то инжектор инстанцирует её только один раз и отдаёт один и тот же экземпляр каждому потребителю(то есть используется паттерн синглтон). в этом суть инжектора.
 
поиск зависимости происходит сначала в дереве компонентов в зависимости от html-вложенности их. если ничего не нашлось, то поиск начинает производиться в модулях, к которым принадлежат эти компоненты. 
 
этот порядок можно изменить при помощи модификаторов Optional, Skip, SkipSelf, Host. причём последний из них актуален тольуо для директив, которые, как известно, не имеют host-элемента.
 
существует механизм, при помощи которого можно подменить зависимость на уровне инжектора при помощи:
useClass,
useExisting,
useValue ,
useFactory 

================================
компонент может отрисовывать другие компоненты. эти другие компоненты или прописываются в шаблоне в виде тега, или принимаются от родительского компонента через механизм ng-content.
 
соответственно в принимающем компоненте срабатывают хуки: ngAfterViewInit, ngAfterContentInit для случая инициализации и ngAfterViewChecked, ngAfterContentChecked для случая изменения.
 
ngAfterContentInit срабатывает раньше чем ngAfterViewInit.

================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
