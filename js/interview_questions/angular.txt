================================
какие виды связывания есть в angular?

================================
чем отличаются pure и impure пайпы?

если в пайп передан объект, то pure пайп отслеживает любое изменение внутри объекта, а impure отслеживает изменения только если ссылка на объект изменилась. по умолчанию  действуют Pure пайпы.

================================
чем в ангуляре отличаются компоненты и директивы?

директива не имеет шаблона потому что работает с существующим в DOM элементом. в остальном она является компонентом.

================================
какие виды директив бывают в ангуляре?

структурные(изменяют поведение), атрибутивные(создают и удаляют элементы в DOM)

================================
что такое жизненный цикл компонента в ангуляр? описать основные хуки

================================
что такое резолвер в ангуляр?

================================
что такое route guards в ангуляр?

RG ограничивают навигацию по определённым маршрутам.

сначала создаётся отдельный файл гуарда, в котром есть класс, реализующий интерфейс, например, canActivate. метод canActivate возвращает булево значение. затем имя этого класса используется в роутере:

    { 
        path: 'about', 
        component: AboutComponent, 
        canActivate: [AboutGuard],
    }

при этом существуют другие типы гуардов:

	canActivate - для проверки доступа к роуту
	canDeactivate - для проверки ухода с роута
	resolve - выполняет действие перед переходом на роут

================================
что такое tree shaking? где для него прописываются настройки?

включается в webpack.config.js. а файлы-исключения указываются в package.json

================================
что такое веб-воркеры?

это механизм, который предоставляет возможность запускать скрипт в отдельном процессе. 
после создания веб-воркера через cli создастся файл веб воркера и шаблонный код в компоненте, для которого он создан.
таким образом из компонента можно будет отправлять сигналы на совершение определённого действия. при этом ответы веб-воркера будут в компоненте же отлавливаться при помощи onmessage и onerror

веб-воркеры бывают выделенные и разделяемые. первые работают только с одним компонентом, вторые - со многими.

  // webWorker-demo/src/app/webWorker.ts
  function fibonacci(num) {
      if (num == 1 || num == 2) {
          return 1
      }
      return fibonacci(num - 1) + fibonacci(num - 2)
  }
  self.addEventListener('message', (evt) => {
      const num = evt.data
      postMessage(fibonacci(num))
  })


  // webWorker-demo/arc/app/app.component.ts
  @Component({
      selector: 'app',
      template: `
          <div>
              <input type="number" [(ngmodel)]="number" placeholder="Enter any number">
              <button (click)="calcFib">Calc. Fib</button>
          </div>
          <div>{{output}}</div>
      `
  })
  export class App implements OnInit{
      private number
      private output
      private webworker: Worker
      ngOnInit() {
          if(typeof Worker !== 'undefined') {
              this.webWorker = new Worker('./webWorker')
              this.webWorker.onmessage = function(data) {
                  this.output = data
              }
          }
      }
      calcFib() {
          this.webWorker.postMessage(this.number)
      }
  }

================================
что такое сервис-воркеры?

СВ это система кеширования, которая была добавлена в ангуляр. все запросы проходят через СВ. после первого запроса весь ответ кешируется. при последующих запросах сравниваются контрольные суммы принятных файлов. если они не отличаются, то пользователю отдаются ране загруженные файлы.
контрольные суммы хранятся в manifest.json, который создаётся в момент сборки приложения.

================================
что такое jit и aot?

AOT или Ahead-of-Time – вариант компиляции приложения, которая выполняется один раз при сборке приложения. JIT выполняется каждый раз при запуске приложения в браузере.

================================
что такое HostListener?

это декоратор, который связывает события DOM и обработчик. например после наведения курсора должен вывестись console.log

    @HostListener("mouseenter") 
    onMouseEnter() {
        console.log('start');
    }

при этом возможно отлавливать события не только на элементе директивы, но и на window. здесь второй аргумент это то, что передаётся в обработчик когда событие произойдёт.

	@HostListener('window:keyup', ['$event'])
	KeyUp(event: KeyboardEvent) {
		console.log("KeyUp", event);
	}


================================
что такое HostBinding?

это декоратор, который связывает свойство компонента со свойством элемента

	private fontWeight = 'bold'

	@HostBinding('style.fontWeight') 
	get getFontWeight() {
		return this.fontWeight;
	}

================================
что такое модуль в angular?

модуль это контейнер, который содержит структурные компоннеты приложение: компоненты, директивы, пайпы, сервисы. модули могут быть вложенными. 
типы модулей:
CoreModule - содержит сервисы, общие для всего приложения.
SharedModule - содержит компоненты, директивы и фильтры для всего приложения.
RoutingModule - содержит описание роутов и соответствующих им компонентов.
корневой - он загружается в первую очередь и содержит второстепенные модули.

технически модуль представляет собой класс с декоратором ngModule. декоратор содержит следующие поля:
declarations - для описания использующихся компоннетов, директив, пайпов.
imports - для импорта других модулей
exports - для описания функци

================================
что такое change detection?

в ангуляре компоннеты вложены друг в друга. таким образом компонентная структура представлена в виде дерева, на вершине которой корневой компонент. с каждым компонентом связан шаблон, через который посредством связывания значения могут передаваться более глубоким компонентам. механизм CD следит за тем чтобы значение в компоненте соответствовало значению в шаблоне, тем самым обеспечиваю передачу значений вглубь.

CD запускается при: браузерном событии, http-запросе, timeout/interval

Сервис ChangeDetectorRef может управлять CD в том компоненте, в который он импортирован.

стратегия onPush тоже управляет CD. если она включена в компоненте, то в нём будет отслеживаться входящие Input-данные только в том случае, если будет изменяться ссылка на объект. при default стратегии отслеживаются входящие данные даже если меняются составные части объекта, это не экономно с точки зрения производительности.


================================
что такое сервис?

сервис это класс, которые хранит состояние или используется в качестве поставщика данных. он может быть определён на уровне:
приложения(синглтон),
модуля(синглтон),
компонента(НЕ синглтон)

все сервисы регистрируются инжектором, который делится на несколько уровней. если компоненту нужен сервис, то поиск начинается с нижнего уровня и идёт выше. но этот порядок может быть изменён при помощи декораторов @SkipSelf()

================================
что такое @viewChild?

при помощи viewChild можно получить доступ к вложенному компоненту. допустим в компонент импортирован вложенный компонент:

	import { ChildComponent } from './child.component';

в этом случае обратиться к нему можно так:

	@ViewChild(ChildComponent) 
	child: ChildComponent;
	ngAfterViewInit() {
		console.log(this.child.whoAmI());
	}	

то же самое будет, если вложенный компонент не импортирован, а указан в шаблоне:

	<input #someInput placeholder="Your favorite pizza toping">

	@ViewChild('someInput') 
	someInput: ElementRef;
	ngAfterViewInit() {
		this.someInput.nativeElement.value = "qwerty";
	}	

================================
что такое шаблонная переменная?

это помеченный # элемент в шаблоне. на который можно ссылаться из шаблона же:

	<input type="text" [(ngModel)]="name" #username />
	<p>{{username.value}}</p>

и из компонента:

	<div #editor id="jsoneditor">

	@ViewChild('editor') 
	editor: ElementRef;
	this.editor.nativeElement.innerHTML  = 'qwerty';

================================
как отписаться от потока?

первый способ: 
1. создать переменную типа ISubscription
2. присвоить ей поток
3. в хуке ngOnDestroy или в блоке next прописать .unsubscribe()

второй способ:
1. создать s = Subject
2. .pipe(takeUntil(s))
3. в хуке ngOnDestroy использовать this.s.next();

третий способ:
1. в шаблоне использовать async pipe

================================
что такое ngrx?

это шаблон, позволяющий централизировать изменения состояния. когда проект становтся большим, то состояния могут быть изменены из разных мест программы. это приводит к ошибкам и трудностям юнит-тестирования.

ngrx предполагает наличие глобального стейта, при изменении которого каждый раз создаётся клон с добавленными изменениями. таким образом в приложении есть только один источник правды.

редюсер содержит условный оператор, который на основе входящего сигнала(экшена) изменяет стейт. и возвращает изменённую копию.

экшен это название действия в виде строки, которое отправляется в редюсер. возможно, с полезной нагрузкой.

для повышения производительности стейт можно запрашивать частями. например, если требуется на экране отобразить определённую часть стейта.

================================
какие подходы к мультиязычности существуют?

пакет ngx-translate (https://stackblitz.com/edit/ngx-translate-example):
в этом случае после подключения его в главный модуль приложения необходимо в assets создать в формате json описания констант и соответвтующие им переводы. для каждого языка отдельный файл. далее в компоненте нужно инжектировать сервис TranslateService и использовать его в шаблоне как pipe для описанной константы:

	<h2>{{ 'HOME.TITLE' | translate }}</h2>

язык можно менять динамически, используя метод 
	
	TranslateService.use('en-US')

================================
как можно проводить тестирование?

в angular можно использовать jest юнит-тесты. они могут быть изолированные и неизолированные.

в первом случае класс не имеет зависимостей и тестируется как изолированный функционал.

во втором случае необходимо перед каждым тестом создать сруду при помощи встроенного фреймворка testBed. создание среды предполагает эмуляцию компонента и установка зависимостей. в этом случае обычно сервисы, пайпы и прочие зависимости заменяют на моковые данные.

================================
что такое control value accessor?

CVA позволяет кастомный компонент связать с элементом реактивной формы и наладить двустороннюю связь между ними.

в элементы input, select и т.д. CVA встроен изначально. но можно сделать рейтинг из 5 звёзд и привязать количество звёзд к полю реактивной формы:

    this.galaxyForm = new FormGroup({
      galaxy: new FormControl({value: null, disabled: false}, [Validators.required]),
      rating: new FormControl({value: 2, disabled: true}, [Validators.required]),
      name: new FormControl({value: null, disabled: false}, [Validators.required])
    });

------------
в коде выше значение rating инициализируется двойкой. соответственно в кастомном компоненте сработает:

  writeValue(val) {
    console.log('writeValue', val)
    this._value = val;
  }

 таким образом срабатывает связь от формы к компоненту.

------------
в кастомном компоненте есть обработчик события (click). после того как пользователь кликнет на звезду, он сработает:

  setRating(star: any) {
  	this._value = star.stars;
  	this.ratingText = star.text
  	this.onChanged(star.stars);
  }

  public _value: number;
  onChanged: any = () => {}
  
  registerOnChange(fn: any){
    this.onChanged = fn
  }

в результате значение star.stars будет отправлено в реактивную форму(при этом также сработает writeValue).

================================
что такое динамический компонент?

ДК это компоненты, которые при помощи фабрики создаются во время исполнения программы на основе единственного шаблона. при этом получают различающиеся данные инициализации. ДК создаются уже в скомпилированном приложении в момент его работы.

шаблон представляет из себя обычный компоннет с опционально входящими переменными. он так же как и обычный компонент импортируется в модуль.

далее в компонент, который управляет ДК испортируется фабрика ComponentFactoryResolver. ей скармливается шаблон ДК, после чего сгенерированный ДК можно инициализировать и встраивать в шаблон родителя. фабрика может таким образом генерировать множество однотипных ДК.

  @ViewChild('container', { read: ViewContainerRef }) container: ViewContainerRef;
  private _counter = 1;
  constructor(private componentFactoryResolver: ComponentFactoryResolver) { }
  add(): void {
    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(DynamicComponent);
    const componentRef = this.container.createComponent(componentFactory);
    componentRef.instance.index = this._counter++;
  }

тут больше: 
https://stackblitz.com/edit/angular-dynamic-components-example-f2fbvx

================================
что нового?

1.  автоматическая подгрузка и встраивание шрифтов перед компиляцией.
2.  в тесты добавлена возможность управлять обнаружением изменений и запускать несколько саинхронных взаимодействий одновременно.
3.  обновлён формат вывода логов и отчётов в CLI
4.  стало прще включать Hot Module Replacement: ng serve --hmr
      - страница не обновляется вся при добавлении новго модуля
      - при добавлении модуля сохраняется состояние переменных
      - действует только в режиме разработки
5.  увеличена скорость компиляции TS
6.  Экспериментальная поддержка webpack 5
7.  отказ от поддержки TSLint
8.  отказ от IE. поддерживается только IE11


================================
на каком шаблоне построен angular?

mvvm

model - сервисы. содержат данные

view - html,css. разметка и стили

modelView - контроллер, в котором есть данные из модели, которые подлежат связыванию. и методы, которые могут их менять.

================================
что такое ng-container и ng-template?

ng-container это элемент, который удаляется из разметки после компиляции. его удобно использовать для структурных директив типа *ngFor.

ng-template тоже удаляется из разметки после компиляции, но его содержимое можно вернуть в разметку, например, при помощи *ngIf или ngSwitch.

================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
