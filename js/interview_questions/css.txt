какие бывают виды display?

block:
занимает всё доступное пространство по ширине. можно установить высоту/ширину

inline:
не занимает всё доступное пространство по ширине. нельзя установить высоту/ширину

inline-block:
не занимает всё доступное пространство по ширине. можно установить высоту/ширину

flex:
занимает всё доступное пространство по ширине. внутреннее содержимое выкладывает согласно флекс-модели

inline flex:
не занимает всё доступное пространство по ширине. внутреннее содержимое выкладывает согласно флекс-модели

none:
убирает элемент из документа

===================================
какой приоритет у селекторов?

	style=“”
	#id
	.class
	[attr=value]
	LI
	*

===================================
какие значения бывают у position?

static
блок ведёт себя как обычный блок. left/top/right/bottom не действуют

relative 
блок ведёт себя как обычный блок. left/top/right/bottom действуют относительно первоначального положения

absolute
схлопывается высота/ширина. left/top/right/bottom действуют относительно родителя с position: relative

fixed
схлопывается высота/ширина. left/top/right/bottom действуют относительно окна браузера

sticky
блок ведёт себя как обычный блок. но при прокрутке скролла прилипает к верхней части экрана

===================================
что такое box-sizing?

content-box:
width/height не учитывают padding/margin/border

border-box:
width/height учитывают padding/border, но не margin

===================================
какие значения есть у background-size?

auto:
картинка фона не меняет своего размера

cover:
картинка фона занимает всю ширину блока

contain:
картинка фона занимает всю высоту блока

===================================
что такое БЭМ?

это методика работы со стилями, позволяющая отказаться от копипаста.

блок это независимый кусок разметки, который может быть повторно использован. его название описывает блок, а не внешний вид.

элемент это составная часть блока, которая не может использоваться вне его. название отделяется от имени блока подчеркиваниями.

модификатор определяет внешний вид блока или модификатора. отделяется подчёркиванием.

===================================
что такое flex-shrink и flex-grow?

flex-shrink это количество размеров, на которое сократится ширина блока когда в родительсквом блоке не станет свободного места.
flex-grow это количество размеров, на котрое увеличится ширина блока когда в родительском блоке появится свободное место.







===================================
===================================
===================================
================
какие есть селекторы

	селектор по:

		1. тегу
		2. классу
		3. по идентификатору
		4. по атрибуту
		5. Селектор потомка
		6. универсальный селектор *
		7. комбинированные (через запятую)

================
приоритет (специфичность) селекторов

	* не имеет специфичности

	самый специфичный селектор по id. 
	затем по классу/атрибуту.
	затем по тегу

	но любой селектор, прописанный в style преебивает их.

	а !important имеет наивысший приоритет

	способ формализации можно реализовать через составное число типа:

		id.class-attr.tag

	в результате получится такое:

		1.0.2

	после удаления точек число можно сравнивать.

================
комбинаторы селекторов

	селекторые можно записывать последовательно через определённые символы. 

		через запятую значит, что несколько селекторов будут использовать одно правило.

		через пробел значит, что перечисленные селекторы вложены в html.

		слитно без пробела означает, что все перечисленные селекторы должны быть одновременно у элемента.

		череЗ знак > означает, что правило будет применяться к подходящему потомку.

		череЗ знак + означает, что правило будет применяться к первому соседу (прилипающему).

		череЗ знак ~ означает, что правило будет применяться к указанным соседям (не прилипающим).

================
псевдоэлементы

	это элементы, которых нет в разметке, но которые созданы средствами css.

	::before, ::after

		добавляют контент до или после элемента

	::first-letter

		применяет стили к первой букве текста элемента

	::first-line

		применяет стили к первой строке блочного элемента

	::selection 

		применяет стили к выделенному мушкой тексту

	::placeholder

		стилизация подсказки в инпуте

Псевдоклассы 
	
	это селекторы, которые определяют состояние уже существующих элементов

	:hover

		применяет стили когда пользователь наводит курсор на элемент

	:focus

		применяет стили когда элемент получает фокус

	:link 

		используется для оформления ссылок, которые пользователь ещё никогда не открывал

	:visited 

		используется для оформления ссылок, по которым пользователь прошёл

	:first-child

		применяет стили к первому дочернему элементу внутри блока ul

			li:first-child {
			    border: 2px solid orange;
			}		



	Если не указать тег, класс или id, к которому применяется псевдокласс, то свойство будет применено к любому возможному элементу, который способен иметь этот псевдокласс:			

================
Псевдоклассы группы :nth-child

	При помощи этих псевдоклассов можно удобно выбирать элементы по их порядковому номеру внутри родительского элемента.

	аргументом может быть число, представляющее из себя порядковый номер. нумерация ведётся с 1

	аргументом может быть odd/even, тогда будут выбираться нечётные/чётные элементы

	аргументом может быть выражение и тогда можно, например, выбрать каждый третий элемент:

		:nth-child(3n)

		Вместо n будет подставляться 0, затем 1, 2 и так далее.

================
как браузер читает селекторы

	справа налево. потому что браузер после построения DOM и подгрузки стилей пытается пройтись по каждому элементу и применить к нему стиль.

	а пользователь когда пишется css имеет противоположную задачу. то есть ему нужно написать селектор и для него найти элемент. поэтому пользователь пишет селектор слева направо.

================
display

	block - элемент занимает 100% ширины и располагается под предыдущим элементом.

	inline - элемент не занимает 100% ширины и есть возможность выстроить его горизонтально с соседними inline-элементами. если он не умещается полностью в ширину родителя, то часть переносится на новую строку

	inline-block - в потоке ведёт себя как inline, но есть возможность устанавливать высоту и ширину. то есть не только его содержимое определяет его форму.

	table - дочерние элементы располагаются как ячейки таблицы, но для этого их нужно пометить display: table-row, display: table-cell: 

	flex - на потомков распространяются flex-правила

	grid - на потомков распространяются grid-правила

================
единицы измерения

	абсолютные и относительные.

	px - пиксель
	% - процент от родителя (иногда от разных величин родителя, margin-right процент берёт от ширины родителя)
	em - это 100% от родителя
	rem - это 100% от размера шрифта в корневом элементе (html)
	vh/vw - выорта/ширина вьюпорта (видимой части документа). 1vh = 1%
	vmin/vmax - меньшая/большая сторона вьюпорта. 1vmin = 1%
	deg - угол(для градиентов). 1deg = 1 градус
	ms/s - ед. измерения времени. лдя animation/transition

================
display: none

	не занимает место в разметке

visibility: hidden

	занимает место, но не виден

================
position

	static 

		задано по умолчанию, элемент занимает своё обычное место в потоке

	relative

		положение элемента может быть смещено при помощи: left/right/top/bottom. при этом место, которое освододилось остаётся занятым.

	absolute

		элемен убирается из основного потока. после этого его положение задаётся при помощи: left/right/top/bottom относительно ближайшего позиционированного родителя.

	fixed

		то же самое, что и absolute, но позиционированным родителем является окно браузера.

	sticky

		существует липкий элемент и липкий родитель. для липого блока указывается left/right/top/bottom. как только он достигает крайнего положения, то извлекается из потока и получает значение из прилипает, но он никогда не покинет пределы липкого родителя.

================
transform

	перемещает (translate), 
	поворачивает (rotate), 
	масштабирует (scale),
	деформирует (skew),
	элемент. при этом соседние элементы в потоке не затрагиваются потому что перед началом преобразования элемент выносится в отдельный слой.

	кроме того существует опция matrix, которая объединяет несколько трансформаций.

	 если данный блок заденет другой, то он не повлияет на его позицию, а просто будет отображаться поверх или под ним.

	transform-origin позволяет сместить центр поворота, относительно которого происходит изменение положения/размера/формы элемента.

	Все преобразования, определяемые свойством transform и transform-origin, относятся к положению и размерам опорного блока элемента. Опорный блок элемента это виртуальный прямоугольник вокруг элемента, который формирует систему координат для отрисовки.

	есть возможность записать несколько трансформаций в одну строку: 

		transform: scale(1.2) translate(30px, 30px) rotate(20deg);

================
z-index

	позиционирует элементы по оси Z. он действует только если у элемента position отличается от static.

	Любые позиционированные элементы на веб-странице могут накладываться друг на друга, имитируя третье измерение.

	если элементы вложены, то z-index не действует.

	значением может быть как положительное таки отрицательное число или auto(порядок элементов в этом случае строится автоматически, исходя из их положения в коде HTML ).

	если числа равны у двух элементов или z-index не задан, то наложится тот элемент, который в html описан последним.

================
схлопывание margins

	действует только для вертикальных margins. для inline-блоков не действует.

	суть в том, что если у соседних блоков уустановлены margins, то расстояние между ними будет равно не сумме margins, а наибольшему из margins. это правиль касается вложенных элементов тоже. 

================
препроцессор

	это надстройка над css, которая по команде переводит синтаксис препроцессора в синтаксис css. при этом позволяет использовать кложенность, наследование, миксины и прочие вспомогательные возможности.

	кроме того препроцессоры позволяют разбивать код на файлы и потом сливать их в один файл.

	существуют 3 наиболее популярных пропроцессора:

		less
		sass (sass + scss)
		stylus

================
постпроцессор

	это скрипт, который получает на вход чистый css улучшает его и возвращает чистый css.

	улучшается css при помощи подключенных плагинов, которые выполняются последовательно. например есть плагины для:

		добавления префиксов специфичных для браузеров (moz, ms, webkit),
		сокращение селекторов (background-color -> background),
		автосброса встроенных стилей,
		изменения названий в тиле БЭМ

================
что такое & в scss

	когда элемент имеет два класса и необходимо к нему применить правило, учитывающее обязательное наличие обоих классов, то пишется вложенная конструкция, в котрой используется знак &

		.class1 {
			&.class2 {
				color: red;
			}
		}

	также можно использовать & для добавления псевдокласса

		.block {
		    &:hover {
		        background-color: magenta;
		    }
		}	

	вообще символ & пзначаетссылку на родительский элемент.

================
миксины

	это конструкции которые позволяют избавиться от дублирования css-кода. сначала пишется кусок кода, который будет переиспользоваться:

		@mixin reset {
		  margin: 0;
		  padding: 0;
		}	

	затем ссылка на него вставляется многокрано в целевые места при помощи include:

		ul {
		  @include reset;
		}	

	важно, что миксины можно вкладывать друг в друга:

		@mixin horizontal-menu {
		  @include reset;
		  @include flex-between;
		}	

		.horizontal-menu {
		    @include horizontal-menu;
		}		

	часто миксины используются для добавления вендорных префиксов:

		@mixin box-shadow-prefix {
		  -webkit-box-shadow: 10px 10px 5px 0px rgba(0,0,0,0.75);
		  -moz-box-shadow: 10px 10px 5px 0px rgba(0,0,0,0.75);
		  box-shadow: 10px 10px 5px 0px rgba(0,0,0,0.75);
		}	

================
как бороться с переполнением контентом?

	использовать свойство overflow для НЕ-inline-блоков:

		hidden - лишнее обрезается
		auto - когда нужно добавляется скролл(вертикальный или горизонтальный)
		scroll - скролл будет всегда (даже если блок не переполнен)
		clip - определяет насколько далеко за пределами контейнера контент будет обрезан:

		  overflow: clip;	// required
		  overflow-clip-margin: 70px;		

	если контент представляет собой текст, то можно использовать text-overflow:

		ellipsis - обрезает единственную строку, добавляя многоточие в конец:
			#app {
				width: 100vw;
				height: 100px;
				text-overflow: ellipsis;
				white-space: nowrap;	// required
				overflow: hidden;		// required
			}	

		clip - просто обрезает строку.

	принудительно переносить слова: 

		word-wrap: break-word 		

	использовать пагинацию,
	использовать бесконечный подвал

================
css-правило

	это инструкция, которая применяется к соответствующему селектору. правиль может быть несколько, внутри блока не соблюдается порядок этих правил.

================
css-спрайт

	это несколько картинок, объединённые в одну. выводится часть картинки через background. какую именно часть показывать указывается при помощи:

		background-position: 0 -32px;

	Спрайты позволяют:

		Сократить количество обращений к серверу.
		Загрузить несколько изображений сразу, включая те, которые понадобятся в будущем.		

================
box-sizing 
	
	позволяет менять способ расчёта размеров блока. в блочной модели ширина не включает величины paddings, borders, margins.

	box-sizing: content-box

		свойство действует по умолчанию. в этом случае ширина не включает ни paddings, ни borders, ни margins

	box-sizing: border-box

		ширина включает paddings и borders. от есть если в коде указана width: 300px, то инспектор покажет width: <300px

================
вендорные префиксы

	это приставки перед правилами, которые позволяют использовать фичи, которые реализованы ещё не во всех браузерах:

	moz,
	webkit,
	o,
	ms.

	важно располагать их так чтобы последним было правило без префикса потому что последняя запись имеет приоритет.

	обычно префиксы добавляются при помощи плагина Автопрефиксер.

	рабочая группа csswg разрабатывает черновики фич на основе потребностей пользователей. затем разработчики браузеров оринтируются на эти черновики, каждый браузер может немного по-другому реализовывать фичу. префиксы позволяют учитывать эти различия. со временем W3C прееводит эти чернокики в стандарт и потребность в префиксах отпадает.

================
адаптивная вёрстка

	это набор макетов, которые выбираются в зависимости от размера экрана устройства пользователя. каждый макет оптимизирован то есть максимально быстро отрисовывается и может скрывать часть функционала. 

	до адаптивной вёрстки существовала респонсив вёрстка, которая тоже подстраивалась под размеры экрана и перестраивала блоки, но использовала только один тяжёлый макет. в современном мире больше половины устройств - мобильные поэтому тяжёлые макеты будут отрисовываться медленнее. используются медаи-запросы.

	посмотреть как страница выглядит на различных устройствах можно через инструменты разработчика chrome. 

	для уменьшения резкости перехода между макетами можно использовать css-анимацию.

	использовать относительные единицы измерения: vh, %, em и т.д.

================
резиновая вёрстка

	это макет, которые использует относительные единицы измерения и поэтому ширина и размеры элементов подстраиваются под ширину экрана.

================
flex

	один из способов располагать элементы для разных размеров экранов. существует:

		флекс-контейнер,
		флекс-элементы.

	флекс-контейнер создаёт новый контекст. элементы в нём могут располагаться по двум осям. по умолчанию действует горизонтальная ось. ось можно развернуть.

	по умолчанию флекс-контейнер ведёт себя как блочный элемент по отношению к соседним блокам в потоке.

		display: flex;

	но можно сделать так чтобы он вёл себя как строчный элемент:

		display: inline-flex;

	по умолчанию флекс-элементы не переносятся на новую строку:

		flex-wrap: nowrap;

	но это можно исправить:

		flex-wrap: wrap;

	justify-content - выравнивает флекс-элементы по основной оси.

	align-items - выравнивает флекс-элементы по поперечной оси.

	flex-grow - 

		свойство указывает, может ли вырастать флекс-элемент при наличии возможность ужать соседей.

		с другой стороны это коэффициент растяжения в зависимости от оставшегося свободного пространства.

	flex-shrink - 

		указывает насколько может сжаться флекс-элемент, если соседи будут давить.

	flex-basis - 

		это ширина флекс-элемента вдоль гавной оси. уменьшаться она может, но увеличиваться не может.

		аналог свойства width. ширина блока определяется его содержимым, этому соответствует flex-basis: auto. но есть возможность ширину сделать не зависящей от содержимого, для этого нужно использовать конкретное значение, например, 200px.

	flex-direction - 

		задаёт основную ось, по которой будут располагаться элементы. по умолчанию это горизонтальная ось. её можно развернуть.

	трёхколоночный макет, в котром крайние сайдобары имеют фиксированную зирину:

		.left {
			flex-basis: 200px;
			flex-shrink: 0;
		}

		.center {
			flex-grow: 1;
			flex-shrink: 1;
			flex-basis: 0;
		}

		.right {
			flex-basis: 200px;
			flex-shrink: 0;
		}	

================
что такое grid?

	это подход, позволяющий создавать новый контекст размещения элементов, который похож на табличную вёрстку. при этом каждая ячейка имеет имя:

		grid-template-areas:
			"header header header"
			"content content 👾"
			"content content ."
			"footer footer footer";	

	направляющие задаются при помощи комбинации абсолютных и относительных значений:

		grid-template-columns: 1fr 200px 1fr;
		grid-template-rows: repeat(4, 150px);

	как и в случае в флексами для гридов существуют понятия: грид-контейнер и грид-элементы. выравнивание элементов в пределах ячеек задаётся в контейнере, но если нужно конкретные элементы выравнивать по-другому, то нужно задать выравнивание в этом конкретном элементе.

	есть возможность размещать элемент так чтобы он занимал несколько ячеек.

		grid-column: span 2;
		или
		grid-row: span 2;

	величину отступов между колонками и рядами тоже можно зададть:

		column-gap: 10px;
		row-gap: 50px;	

================
grid fr 
	
	это новая относительная единица измерения, дословно она называется "дробная часть". в контексте grid-контейнера она размечает свободное пространство. например, следующий код создаёт 3 колонки равной ширины:

		grid-template-columns: 1fr 1fr 1fr 1fr;

	если сюда добавить отступы при помощи gap, то скролл не появится.

		grid-template-columns: 25% 25% 25% 25%;

	а если сюда добавить те же самые отступы, то скролл появится.

grid-template-columns, 
grid-template-rows

	это свойства, которые задают количество колонок и количество столбцов. характеристики можно просто перечислять, использую относительные и абсолютные единицы:

		grid-template-columns: 40px auto 40%;

	также есть возможность давать алиасы:

		grid-template-columns: [start] 140px [line2] 250px [line3] 40px [end];

	есть возможность использовать функцию repeat:

		grid-template-columns: repeat(3, 1fr);

================
CSS framework 

	это коллекция стилей CSS, подготовленных и готовых к использованию.

	они: 

		обеспецивают кроссбраузерность,
		ускоряют написание кода,

	самый популярный фреймворк это bootstrap. он предлагает:

		отзывчивые макеты,
		наборы компонентов типа цветных панелей, таблиц, красивых кнопочек.
		динамические компоненты типа модальных окон, выпадающих меню.
		позволяет нсобирать бандл из выборочных компонентов.

	некоторые из них реализованы как модели к jsфреймворкам: primeNG, angular-material.

	Materialize CSS тоже популярен.

================
bootstrap

	способы подключения:

		cdn,
		npm,
		скачать бандлы js и css

================
методологии

	это способ поддерживать единообразие в css-коде большого проекта, в котором работает не один разработчик. если каждый начнёт бессистемно менять код, то скоро наступит хаос.

	Блок-Элемент-Модификатор

		позволяет создавать переиспользуемые стили при помощи системы наименования. Стиль именования модификаторов в БЭМ: block__element_modifier.

			<div class="block">
			    <div class="block__elem1"></div>
			</div>			

		Б:

			Функционально независимый компонент страницы, который может быть повторно использован. например, футер, хэдер.

			Блоки можно использовать в любом месте на странице, поэтому в CSS-коде для блоков не должно быть никаких внешних отступов и правил позиционирования.

		Э:

			Составная часть блока, которая не может использоваться в отрыве от него.

		М:

			Cущность, определяющая внешний вид, состояние или поведение блока либо элемента


	Atomic CSS

		суть его в том чтобы любое повторно использующееся правило(например, margin-left: 1px) нужно выносить в отдельные класс.

		проблема в том, что имена классов не несут семантической нагрузки.

	
	SMACSS

		в основе этой методолгогии лежить правило разбиения стилей по категориями:

			base,
			layout,
			module,
			state,
			theme

		соответственно создаётся дерево папок и файлов.

			base,

				хранятся наиболее общие стили, не используются класса и id, а используются только имена тегов. например 

					button {
						background: blue;
						padding: 10px;
					}

			layout,

				хранятся стили, которые относятся к макету: футер, хэдер, навигация и т.д.
				они уникальны поэтому допустимо использовать id. также можно исполь-овать префикс l.

			module,

				хранятся стили для автономных кусков разметки, котрые могут использоваться многократно и не зависят от контекста. классы пишутся через двойную черту: 

					.card--label

			state,

				стили, описывающие состояние блока, например, раскрыт-закрыт. используется префикс is-opened

			theme		

				стили, которые дополняют base-стили. стили темы можно быстро заменить на стили другой темы, в то время как base-стили остаются всегда постоянными.

================
способы анимации в CSS

	transitions

		добавление в набор правил селектора свойства transition, котое имеет значением, например, background и набор параметров типа длительности и плавности

			transition-property — указывает список свойств, которые будут анимироваться; свойства

			transition-duration — задаёт значение продолжительности анимации

			transition-timing-function — мы можем ускорить анимацию в начале и замедлить в конце, либо наоборот.

			transition-delay — задаёт задержку времени до начала анимации

			transition — это общее свойство, которое позволяет перечислить первые четыре свойства в порядке: property, duration, timing-function, delay.

	keyframes

		в отдельном участке кода прописываются шаги анимации и этому участку задаётся уникальное имя:

			@keyframes circle-to-square {
			  from {
			    background-color: #F498AD;
			  }
			  50% {
			    background-color: #7F6EDB;
			  }
			  to {
			    background-color: #2E9AFF;
			  }
			}	

		затем это имя используется для определённого селектора:	

			.child-one {
				animation-name: circle-to-square;
			}			

		кроме имени существуют дополнительные параметры:

			длительность,
			задержка,
			кол-во повторений,
			признак обратного порядка,
			различные варианты плавности

	js-анимация

		просто средствами js получить доступ к элементам и добавлять свойства или стили.

	svg-анимация

		css

			добавить svg-тегам класс и использовать transitions, например, при :hover. 

			В целом логика работы CSS-анимаций в контексте SVG принципиально не отличается от HTML

		smil

			предполанает использование специфических тегов:

		        <animate
		                 attributeType='XML'
		                 attributeName='stroke-dasharray'
		                 from='0 1698'
		                 to='1698 0'
		                 dur='3s'
		                 repeatCount='indefinite'
		                 />

================
как реализовать анимацию без перерисовки?

	использовать transform, он фиксирует область за элементом, и для него перестаёт просчитываться взаимодействие с другими элементами. 

	transform, «выносит» элемент на отдельный композитный слой, где положение элемента не зависит от других и не влияет на них.

	Композитинг — это разделение содержимого страницы на «слои», которые браузер будет перерисовывать. Эти слои друг от друга не зависят, из-за чего изменение элемента в одном слое не затрагивает элементы из других слоёв, и перерисовывать их становится не нужно.

================
CSSOM 
	
	это представление селекторов и их значений в виде дерева. это дерево подобно DOM-дереву, в котором для каждого узла прописаны стили.

	построение CSSOM это блокирующий процесс потому что более поздние селекторы могут переопределять более ранние.

	DOM и CSSOM являются основой для потроение render-tree.

================
css переменные

	это переиспользуемые значения, которые можно использовать в правилах селектора.

	сначала объявляем:

		--card-color: lightblue;

	потом используем:

		.card {
			background-color: var(--card-color);
		}

	есть возможность использовать значения по умолчанию как второй аргумент:

		.card {
			background-color: var(--card-color, red);
		}		

	роцесс поиска переменной это постоянное всплытие сначала в пределах текущей области видимости, а затем в областях видимости родителей.

================
:root {}

	необходим чтобы обращаться к наивысшему родительского элементу, то есть для html-стрнаиц им всегда будет <html>.

	для ml - <xml>

	для svg - <svg>

================
Houdini 

	это коллекция API браузера, которая позволяет расширять css средствами js. эти API позволяют расширять css на фазе отрисовки или на фазе вычисления размеров и расположения элементов.

================
================
================
================
================
================
================
================
================
================
================
================
================
================