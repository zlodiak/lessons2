================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
тип bigint

	создать можно двумя способами:

		1. через конструктор BigInt
		2. добавить в кноце цифры символ n

	не разрешается в операциях смешивать обычные числа и bigint-числа. но операции сравнения работают корректно.

	не разрешается использовать унарный оператор + для преобразования строки в число

================================
эмуляция клика по html с использованием координат

	let clickEvent = new MouseEvent("click", {
	    bubbles: true,
	    cancelable: true,
	    clientX: track.width.baseVal.value - thumb.width.baseVal.value,
	    clientY: 0
	});
	track.dispatchEvent(clickEvent)

	тут больше: https://www.javascripttutorial.net/javascript-dom/javascript-dispatchevent/

эмуляция клика по элементу:

	let btn = document.querySelector('.btn');

	 btn.addEventListener('click', function () {
	        alert('Mouse Clicked');
	 });

	let clickEvent = new Event('click');
	btn.dispatchEvent(clickEvent);

================================
чтобы приложение было интерактивным необходимо чтобы браузер посылал события, а разработчик своим кодом улавливал их. 

например, если на элемент DOM пользователь кликнул, то программист может подписаться на событие клика и обработать его при помощи коллбека.

подписаться можно двумя способами:

	1. on-свойства элементов 

		onclick,
		onmouseenter,
		onscroll

		buttonElement.onclick = function() {
		  squareDiv.style = `background-color: ${getColor()};`
		}		

	2. addEventListener()

		buttonElement.addEventListener('click', function() {
		  squareDiv.style = `background-color: ${getColor()};`
		})	

================================
перечислить типы данных в js

null 
undefined
symbol	// let id = Symbol("id");
bigint	// const bigInt = 1234567890123456789012345678901234567890n;
number
string
boolean
object
+
function (унаследованы от object)

================================
что такое вычисляемое свойство?

это свойство объекта, заданное в квадратных скобках. в качестве имени можно использовать выражение. в частности символьный тип.

================================
что такое свойство-значение и свойство-акцессор?

	свойство-акцессор это функция, которая имеет доступ к свойствам-значениям через this. в остальном оно ведёт себя как функция(геттер/сеттер).
	существует возможность задавать их через defineProperty

	let user = {
		name: "Steve",
		surname: "Rogers",
		get fullName() {
		    return `${this.name} ${this.surname}`;
		  },
		set fullName(value) {
		    [this.name, this.surname] = value.split(" ");
		  }
	};
	// set fullName is executed with the given value.
	user.fullName = "Bruce Wayne";
	alert(user.name); // Bruce
	alert(user.surname); // Wayne

	--------

	let user = {
	  name: "Steve",
	  surname: "Rogers"
	};
	Object.defineProperty(user, 'fullName', {
	  set fullName(value) {
	    [this.name, this.surname] = value.split(" ");
	  }  
	});
	// set fullName is executed with the given value.
	user.fullName = "Bruce Wayne";
	alert(user.name); // Bruce
	alert(user.surname); // Wayne

================================
в чём разница между == и ===?

	оператор === сранвивает типы и значения.

	оператор == сначала приводит операнды к одому типу и только после этого сравнивает значения.

	Если оба операнда являются объектами, то JavaScript сравнивает внутренние ссылки, которые равны в том случае, если они ссылаются на один и тот же объект в памяти.
	если же один из операндов является примитивом, а другой объектом, то: 
	1. объект преобразуется в примитив, 
	2. затем они приводятся к одному типу,
	3. затем они сравниваются


================================
есть ли в js возможность сделать свойство объекта приватным?

	приватные свойства по соглашению начинаются со знака _. но это не синтаксис, а просто соглашение. оно может быть нарушено.

	Приватные свойства и методы должны начинаться с #. Они доступны только внутри класса. 

		class CoffeeMachine {
		  #waterLimit = 200;
		  #checkWater(value) {
		    if (value < 0) throw new Error("Отрицательный уровень воды");
		    if (value > this.#waterLimit) throw new Error("Слишком много воды");
		  }
		}

		let coffeeMachine = new CoffeeMachine();

		coffeeMachine.#checkWater(); // Error
		coffeeMachine.#waterLimit = 1000; // Error

	this['#name'] не работает. 

================================
Можно ли в js вызвать функцию до ее объявления? Как это работает? 

================================
что делает Object.create()?

	создаёт объект с определённым в аргументе прототипом

	// Объект, создаваемый при помощи Object.create(null) не имеет прототипа,
		var data = Object.create(null);
		data.text = "Привет";

================================
как добавить или изменить свойство объекта, не использую точечную нотацию или квадратные скобки?

	const o = {}; // Создаём новый объект
	Object.defineProperty(o, 'a', {
	  value: 37,
	  writable: true,
	  enumerable: true,
	  configurable: true
	});
	// Свойство 'a' существует в que o и имеет значение, равное 37

свойство-акцессор можно менять так:

	Object.defineProperty(user, 'fullName', {
	  set fullName(value) {
	    [this.name, this.surname] = value.split(" ");
	  }  
	});

================================
что такое IIFE? приведите пример

================================
как можно запретить добавление и удаление свойств объекту?

	Object.seal(obj);

================================
как сделать так чтобы свойства объекта стали неизменяемыми и при этом невозможно было ни добавить, ни удалить свойства?

	Object.freeze(obj)

================================
что такое Named Function Expression? 

	var f = function sayHi(...) { /* тело функции */ };
	фцнкция sayHi может вызвать себя изнутри. это может понадобиться при рекурсии.

================================
чем отличаются _proto_ и .prototype?

	Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__.

		var animal = {
		  eats: true
		};
		var rabbit = {
		  jumps: true
		};
		rabbit.__proto__ = animal;
		console.log(rabbit.eats)	// true

	или 

		var animal = {
		  eats: true
		};
		function Rabbit(name) {
		  this.name = name;
		  this.__proto__ = animal;
		}
		var rabbit = new Rabbit("Кроль");
		console.log( rabbit.eats ); // true

	Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.
	При создании объекта через new, в его прототип __proto__ записывается ссылка на конструктор

		var animal = {
		  eats: true
		};
		function Rabbit(name) {
		  this.name = name;
		}
		Rabbit.prototype = animal;
		var rabbit = new Rabbit("Кроль"); //  rabbit.__proto__ == animal
		console.log(rabbit.eats)	// true

================================
что такое коллбек? что такое ад коллбеков?

	коллбек это функция, которая передаётся аргументом в асинхронную функцию и выполняется когда асинхронная функция получит результат.

	с учётом вышесказанного сам коллбек тоже может быть асинхронным и получать синхронную функцию в виде аргумента. и так до бесконечности. это ад коллбеков. проблема не столько во вложенностях сколько в невозможности точно сказать на какой ступени ада произойдёт  первое выполнение.

	чтобы избежать неоднозначности принято использовать промисы. промисы позволяют выполнять последующий колбек только  после того как отработает предыдущий. при этом визуально вместо лесенки код выстраивается в цепочки(chaining).
	промис может быть в трёх состояниях: успех, провал, ожидание.

	Promise.all принимает набор промисов, ждёт пока все они выполнятся и возвращает их результат в виде массива.

	вместо промисов можно использовать конструкицию async/await

================================
что такое async/await?

	если перед функцией стоит async, то она вернёт промис.

		async function f() {
		  return 1;
		}
		f().then(alert); // 1

	внутри такой функции можно использовать await, который остановит ход выполнения ВНУТРИ async функции и будет ждать выполнения асинхронной операции.
	при этом ход выполнения ВНЕ async функции будет идти без задержки.

		async function f() {
		  let promise = new Promise((resolve, reject) => {
		    setTimeout(() => resolve("готово!"), 1000)
		  });

		  let result = await promise; // будет ждать, пока промис не выполнится (*)
		  alert(result); // "готово!"
		}
		f();

	для отлова ошибко используется блок try/catch

================================
упорядочены ли ключи в объекте?

	если ключи могут быть преобразованы к числу, то упорядочены. в ином случае - нет

================================
чем отличается постфиксный инкремент от префиксного?

	постфиксный выполняется после приравнивания:

		let i = 0;
		let s = i++		// s = 0

		let i = 0;
		let s = ++i		// s = 1	

	------------

	также будут различаться операции добавления элементав массив:

	arr.push(i++)

	и

	arr.push(++i)

================================
как js-классу назначить свойства без использования конструктора?

	class MyClass {
	  a = 1;
	  b = 2;
	  c = 3;
	}

	const m = new MyClass();
	console.log(m.b);

================================
в чём разница между Object.assign() и spread-оператором?

spread-оператор всегда создаёт новый объект, а Object.assign лишь мутирует существующий. поэтому в случае со spread-оператором происходит перезапись объекта по ссылке.

	const a = { name: 'Joe Bloggs' }
	const b = { ...a, age: 27 };
	console.log(a === b) //=> false

	const a = { name: 'Joe Bloggs' }
	const b = Object.assign(a, { age: 27 });
	console.log(a === b) //=> true

	но

	const a = { name: 'Joe Bloggs' };
	const b = Object.assign({}, a, { age: 27 });
	console.log(a === b); //=> flase

================================
что такое модуль?

	если подключить скрипт в страницу, то может произойти так, что переменные скрипта заместят переменные страницы(если у них одинаковые названия). чтобы этого не произошло код скрипта помещется в отдельную область видимости. переменные из этой области видимости экспортируеются при помощи return

		var lodash = (function() {

		  var version;
		  function assignDefaults() { ... }

		  return {
		    defaults: function() {  }
		  }

		})();

	с момента появления es6 стало возможным использовать модули при помощи import/export

	в ES6 модуль это отдельеый файл. но также возможно использовать специальную конструкцию:

	    module {  // анонимный внутренний модуль
	        let tmp = …;  // не станет глобальной
	    }

================================
что такое строгий режим?

	СР вклюучается в скрипте или функции. перед его объявлением не должно быть кода.

	СР делает не прощает некоторые неоднозначности в js. например, не разрешает присвоить значение необъявленной переменной(будет ошибка). не разрешает перечилять в объекте свойства с одинаковыми именами. не разрешает использовать некоторые служебные слова, которые зарезервированы для будущего стандарта ES: private, yield, interface etc.

================================
что такое webassembly?

	это бинарный формат, который позволяет браузеру выполнять js быстрее. это не язык программирования, а просто виртуальная машина.

	перед разработчиками wasm стоит ряд задач, связанных с безопасностью, кроссплатформенностью и отсустствием потребности использовать что-то кроме браузера. поэтому разработка wasm затянулась.

================================
что такое try/catch/finally?

	это блоки для обработки исключений. каждое исключение должно быть  однозначно идентифицировано. если этого не произошло, то происходит проброс исключения. это техника, при которой неопознанное исключение из блока catch при помощи throw отправляется во внешний блок try/catch/finally

		try {
			// some code
		} catch (e) {
		  if (e.name == "SyntaxError") { // exception identification
		    alert( "Извините, в данных ошибка" );
		  } else {
		    throw e;
		  }
		}	

================================
что такое всплыте/погружение событий в DOM?

	в DOM элементы имеют вложенную структуру. при клике на один из внутренних элементов происходит погружение события, а потом всплытие. обработчики работают только со стадией всплытия, 

		addEventListener("click", highlightThis); // по умолчанию третий аргумент = false

	но это можно изменить припомощи третьего аргумента addEventListener():

		addEventListener("click", highlightThis, true);

	всплытие события можно пректатить на любом уровне при помощи e.stopPropagation():

		<style>
		  div {
		    padding: 50px;
		    background-color: rgba(255, 0, 0, 0.2);
		  }
		</style>

		<div id="d3">
		  DIV3
		  <div id="d2">
		    DIV 2
		    <div id="d1">DIV 1</div>
		  </div>
		</div>

		<script>
		  const el1 = document.getElementById('d1');
		  const el2 = document.getElementById('d2');
		  const el3 = document.getElementById('d3');

		  el1.addEventListener('click', (e) => {
		    console.log('div1 was clicked'); // display
		  });

		  el2.addEventListener('click', (e) => {
		    e.stopPropagation();
		    console.log('div2 was clicked'); // display
		  });

		  el3.addEventListener('click', (e) => {
		    console.log('div3 was clicked'); // NOT display
		  });
		</script>

	если меню состоит из 10 пунктов, то не обязательно отлавливать клик на каждом из них. достаточно назначить обработчик внешнему блоку. это называется делегирование событий.
	
	event.target указывает на элемент, на котром первоначально произошло событие.

================================
что такое spread и rest операторы?

	spread позволяет разобрать перечислимый объект. например можно клонировать массив. или в вызове функции использовать один аргумент, в теле функции он будет разбит на несколько:

		var log = function(a, b, c) {
		  console.log(a, b, c);
		};
		log(...['Spread', 'Rest', 'Operator']);

	rest делает обратное. например при помощи него функция может принять один rest-аргумет, но внутри функци разбить его на несколько. при этом отпадает надобность в arguments

		var log = function(a, b, ...rest) {
		  console.log(a, b, rest);
		};

		log('Basic', 'rest', 'operator', 'usage'); // Basic rest ['operator', 'usage']

================================
что такое Деструктурирующее присваивание?

	это способ присвоить отдельным переменным каждое значение из итерируемого объекта.

		let myArray = [1,2,3];
		let [a, b, c] = myArray;
		console.log(a); // 1
		console.log(b); // 2
		console.log(c); // 3

	для объекта:

		let myObject = { a: 1, b: 2, c: 3, d: 4};
		let {b, d} = myObject;
		console.log(b); // 2
		console.log(d); // 4

================================
что такое каррирование?

	это преобразование функции, которая принимает несколько аргументов к набору функций, каждая из которых принимает по одному аргументу

		function curry(func) {
		  return function curried(...args) {
		    if (args.length >= func.length) {
		    	console.log('first', this)
		      return func.apply(this, args);
		    } else {
		    	console.log('second')
		      return function(...args2) {
		        return curried.apply(this, args.concat(args2));
		      }
		    }
		  };
		}

		function sum(a, b, c) {
		  return a + b + c;
		}
		let curriedSum = curry(sum);
		console.log( curriedSum(1)(2)(3) );

================================
что такое утиная типизация?

	это проверка того, что объект реализует определённый интерфейс. при этом он может дополнительно иметь другие методы и свойства.

		def method(obj):
		   obj.start()
		   
	При утиной типизации мы не заботимся о типе объекта obj, нам лишь важно, что у него есть метод start. Если же такого метода нет, то выбрасывается исключение.

================================
что такое defer и async?

	в процессе загрузки страницы может получиться так, что подключенный скрипт блокирует отрисовку html. чтобы решить эту проблему в элемент скрипта можно добавить атрибут defer. в этом случае скрипты начнут загружаться в фоновом режиме, а запустятся только после того как html будет сформирован, НО до события DOMContentLoaded. при этом запускаться они будут в последовательности подключения.

	также можно пометить скрипт атрибутом async. в этом случае скрипты загружаются в фоновом режиме. порядок не сохраняется. запускаться они будут по мере загрузки.

	На практике defer используется для скриптов, которым требуется доступ ко всему DOM-дереву или если важен их порядок выполнения.

	А async хорош для независимых скриптов, например счётчиков и рекламы, порядок выполнения которых не играет роли.

================================
что такое fetch?

	это часть веб апи браузера.
	fetch это ещё один способ сделать асинхронный запрос. в ответ приходит промис. таким образом запрос выглядит так:

		fetch('https://api...')
		  .then(response => response.json())

	есть возможность отправлять и получать заголовки:

		fetch('https://api...', {
		  headers: {
		    Authentication: 'secret'
		  }
		})
		.then(response => response.headers.get('Content-Type'))

	пример post-запроса:

		fetch('https://api...', {
		  method: 'POST',
		  headers: {
		    'Content-Type': 'application/json;charset=utf-8'
		  },
		  body: JSON.stringify(user)
		});

================================
что такое класс?

	класс это новая языковая конструкция, которая появилась в ES6. внутри класс представляет из себя функцию, тело которой состоит из конструктора класса. методы класса хранятся в prototype. оператор new создаёт объект из конструктора класса с методами из прототипа.

		class User {
		  constructor(name) { this.name = name; }
		  sayHi() { alert(this.name); }
		}

		let user = new User("Иван");
		user.sayHi();	

	это то же самое, что и:

		function User(name) {
		  this.name = name;
		}

		User.prototype.sayHi = function() {
		  alert(this.name);
		};

		let user = new User("Иван");
		user.sayHi();

================================
что такое функция? рассказать о this в функции.

	функция это конструкция языка. с помощью неё можно создавать переиспользуемые куски кода. функцию можно использовать как конструктор для создания объекта. функцию можно запускать в определённом контексте.

		function User(name) {
		  this.name = name;
		}

		User.prototype.Say = function() {
		  console.log('sss', this.name)
		}

		const f1 = new User('sergey');

		console.log(f1, typeof f1, User.prototype)
		f1.Say()

	в примере выше будет создан объект со свойством name и методом Say()

	можно функцию f1 запустить в другом контексте:

		const f2 = f1.Say;
		f2.call({name: 'misha'})	

	this функции всегда будет браться из контекста.

	-------------

	функция это объект поэтому она тоже может быть контекстом:

		const a = {
		  z: 1,
		  x: 2,
		};

		const b = function () {};
		b.z = 100;
		b.x = 200;

		function f() {
		  console.log(this.z);
		}

		f.call(a); // 1
		f.call(b); // 100

================================
что такое NaN?

	NaN или Not A Number (не число) — это значение, получаемое в результате выполнения числовой операции над нечисловым значением

================================
Как определить наличие свойства в объекте?

	console.log('prop' in o) 

	o.hasOwnProperty('prop2')	// этот метод не проверяет существование свойств в цепочке прототипов объекта.

	console.log(o['prop'])

================================
Как в JS создать объект?

	Объектный литерал {}

	Функция-конструктор

	Object.create(null)	// {}

	new Object() 	// {}

================================
В чем разница между оператором «in» и методом hasOwnProperty?

	оператор «in» проверяет наличие свойства не только в самом объекте, но и в его прототипах, а метод hasOwnProperty — только в объекте.

================================
Почему 0.1 + 0.2 === 0.3 — это false?

	все числа в языке (даже целые) представлены в формате с плавающей запятой (float). эти числа — бесконечные дроби. Для их хранения выделяется ограниченный объем памяти, поэтому возникают подобные неточности.

================================
что такое транспилер и полифилл?

	Транспайлер - переписывает новый синтаксис языка в старый.

		// объявление переменных в новом стиле
		const a = `константа`;
		let b = `изменяемая переменная`;

		// приводит к объявлению в старом стиле
		var a = `константа`;
		var b = `изменяемая переменная`;

	Полифилл - реализовывает функции из новой версии языка, которых нет в старой

		// проверка является ли arr массивом в новом варианте
		if (Array.isArray(arr) === true) alert('массив!');

		// проверка является ли arr массивом в старом варианте

		// Полифилл функции из "новой" версии для старой "версии" языка
		// (для примера здесь, пропишем прямо в прототип Array)
		Array.__proto__.isArray = function(value) {
		return value instanceof Array;
		};

		if (Array.isArray(arr) === true) alert('массив!');

================================
внедрение зависимостей — это способ, с помощью которого объект получает другие объекты, от которых он зависит, называемые зависимостями, а не создает их сам.

	то есть вместо композиции используется более абстрактный подход:

		import { Engine } from './Engine';

		class Car {
		    private engine: Engine;

		    public constructor (engine: Engine) {
		        this.engine = engine;
		    }
		    
		    public startEngine(): void {
		        this.engine.fireCylinders();
		    }
		}



	dependency injection делится на 3 вида:

	1. constructor injection. в этом случае зависимость передаётся через конструктор класса и далее присваивается свойству класса

	class A:
		def __init__(self, logger):
			self.logger = logger

	2. method injection. в этом случае зависимость передаётся через метод класса и в большинстве случаев на присваивается свойству класса, но присваивается локальной переменной метода

	class A:
		def set_logger(self, logger):
			logger_obj = logger
			logger_obj.write('blabla')

	3. property injection. в этом случае зависимость приравнивается свойству объекта

		a = A()
		a.prop = B()

================================
new Map()

	это аналог объекта, но ключами могут быть любые типы. при итерации порядок ключей сохраняется
	в new WeakMap() ключами могут быть только объекты и сборщик мусора удаляет WeakMap даже если в нём есть элемент


new Set()

	это аналог массива, но все значения уникальны.
	в new WeakSet элементами коллекции могут быть только объекты и сборщик мусора удаляет WeakSet даже если в нём есть элемент



================================
localStorage 

	одно хранилище для всех вкладок. не очищается после закрытия вкладок или браузера. Максимальный объем данных ограничен размером 5MB.

sessionStorage 

	хранилище для отдельной вкладки. не очищается после рефреша. очищается после закрытия вкладки или браузера. Максимальный объем данных ограничен размером 5MB.
	sessionStorage принадлежит объекту window

================================
пример потери контекста функции:

	this.x = 9;
	var module = {
	  x: 81,
	  getX: function() { return this.x; }
	};

	module.getX(); // 81

	var getX = module.getX;
	getX(); // 9, поскольку в этом случае this ссылается на глобальный объект

	// создаём новую функцию с this, привязанным к module
	var boundGetX = getX.bind(module);
	boundGetX(); // 81


================
коллбек

  это функция, которая передаётся другой асинхронной функции и запускается на выполнение когда в асинхронной функции будет получен результат. то есть стек вызовов передаёт контекст выполнения очереди, а очередь ОБРАТНО возвращает контекст выполнения стеку.

  для коллбеков существую 2 проблемы:

    1. невозможно точно выстроить их в очередь
    2. если коллбек передаётся в сторонний код, то этот код может выполнить коллбек несколько раз. то есть происходит временная передача управление скриптом сторонней программе(инверсия управления).

  промис возвращает только единожды сигнал о завершении асинхронной операции, его коллбеки запускаются со стороны исходного срипта.		

=================
что такое async-await?

	это синтаксический сахар для промисов. конструкция async-await работает как генератор, то есть останавливает свою работу, передаёт выполнение далее по потоку и затем снова получает возможность продолжить.

		const f = async function () {
		  console.log(2);
		  const value = await Promise.resolve('value');
		  console.log(value);
		  console.log(4);
		};

		console.log(1);
		f();
		console.log(3);

		// вывод в консоль: 1 2 3 value 4 

	отлов ошибок делается при помощи try/catch

		const f = async function () {
		  console.log(2);
		  try {
		    const value = await Promise.resolve('value');
		    console.log(value);
		    console.log(4);
		  } catch (error) {
		    console.log('error', error);
		  }
		};

		console.log(1);
		f();
		console.log(3);

		// вывод в консоль: 1 2 3 value 4 

	на async-функцию можно подписаться при помощи then:

		const f = async function () {
		  console.log(2);
		  return await Promise.resolve('value');
		  console.log(4);
		};

		console.log(1);
		f().then(
		  (s) => console.log('s', s),
		  (e) => console.log('e', e)
		);
		console.log(3);	

		// вывод в консоль 1 2 3 s value

=================
пример потери контекста

	this определяется в момент вызова функции. Если записать метод объекта в переменную и вызвать её, значение this изменится.

		const user = {
		  name: 'Alex',
		  greet() {
		    console.log(`Hello, my name is ${this.name}`)
		  },
		}

		const greet = user.greet
		greet()

		// Hello, my name is

	тот же код в строгом режиме выдаст ошибку потому что у undefined нет свойства name
  
================================
================================
================================
================================
популярные вопросы
===============================
примитивные и ссылочные типы данных

	объект это ссылочный тип данных. он хранится и сравнивается по ссылке, которая ведёт на место в памяти.

	остальные типы это примитивные типы. они хранятся и копируются по значению.

----
в чём разница между приммитивным и ссылочным типом?

	есть разница при копировании. примитивные типы копируют значения, а ссылочные - ссылки.

	let message = "Привет!";
	let phrase = message;
	message = 'qwerty';
	console.log(message, phrase);

	let user = { name: "Иван" };
	let admin = user; 
	user.name = 'sergey';
	console.log(user.name, admin.name)

===============================
мутабельные и иммутабельные типы.

	объект это мутабельный тип потому что можно изменить один из его элементов при этом ссылка на объект останется прежней. то есть при изменении объекта он возвращает старое значение, частично изменённое.

	примитивные типы все иммутабельны потому что при переназначении возвращают новое значение.

===============================
приведение каких значений при помощи boolean даст false?

	Boolean(false);         // false
	Boolean(undefined);     // false
	Boolean(null);          // false
	Boolean('');            // false
	Boolean(NaN);           // false
	Boolean(0);             // false
	Boolean(-0);            // false
	Boolean(0n);            // false	

	Boolean(true);          // true
	Boolean('hi');          // true
	Boolean(1);             // true
	Boolean([]);            // true
	Boolean([0]);           // true
	Boolean([1]);           // true
	Boolean({});            // true
	Boolean({ a: 1 });      // true	

	оператор !! действует следующим образом: первый знак ! приводит значение к логическому и инвертирует его. Второй оператор ! снова инвертирует полученное значение. 

===============================
что такое NaN?

	это значение, получаемое в результате выполнения числовой операции над нечисловым значением:

		'string' / 4
		'string' * 3

	это значение можно получить, если пытаться привести к числу нечисловое значение:

		Number('123,4') // NaN
		Number(undefined) // NaN

	Number.isNaN() проверяет переданное аргументом значение и возвращает true, если это значение NaN.

===============================
что будет если сложить число и строку, в которой записано число?

	3 + '55' = '355'

===============================
как проверить тип переменной null?

	так как typeof null = Object , то тип проверяется на null:

		1:

			let s = null;
			console.log(s === null);

		2:

			let s = null;
			console.log(Object.is(s, null));

===============================
что такое Symbol?

	примитивный тип данных, значение которого не видно разработчику. к значению можно только обратиться через id. каждое значение уникально (даже если имеют одинаковый id). Символы могут использоваться в качестве имён вычисляемых свойств в объектах. Символы игнорируются циклом for…in

		const sym = Symbol('name')	// аргумент-имя не обязателен, это просто описание
		const symTwo = Symbol('name')
		console.log(sym === symTwo) // false

	пример символьного свойства объекта:

		const secondaryId = Symbol()
		const user = {
		  'id': 193,
		  'name': 'Ольга',
		  [secondaryId]: 'olga-1'
		}
		console.log(user[secondaryId])

	существует глобальный реестр символов:

		const sym = Symbol.for('name'); // аргумент-имя может отсутствовать
		const symTwo = Symbol.for('name');
		console.log(sym === symTwo); // true

		то есть многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.

	можно получить название ключа по названию переменной хранения:

		let id = Symbol.for('key');
		let arg = Symbol.keyFor(id);
		console.log(id, arg); // SymbolObject key		

===============================
особенности JS

	1. однопоточный язык.
	2. работает в различных средах (браузер, нода)
	3. в зависимости от среды имее дополнительное апи. например, в браузере есть setTimeout, fetch
	4. в 2015 году вышло большое обновление
	5. использует ООП и возможности функционального программирования
	6. язык с динамической, слабой, неявной типизацией
	7. объекты связаны прототипным наследованием. 
	8. классы это синтаксический сахар для обычных функций

===============================
function declaration vs function expression

	FD это объявление типа function Name() {}. оно моментально высплывает на уровне блока, то есть  может быть вызвана раньше, чем она объявлена.

	FE это функция без имени, которая присвоена переменной:

		let f = function() {}

===============================
IIFE

	это функция, которая запускается сразу после объявления:

		(function() {
		    alert("I am an IIFE!");
		}());

	такая функция используется чтобы создать модуль:

		var module = (function () {
		  var name = 'Barry';
		  return { name };
		})();
		console.log(module.name);	

	работает так:

		1. переменной присваиваем результат функции
		2. () это просто знаки группировки, можно обойтись и без них
		3. переменная name не видна за пределами блока. это её область видимости
		4. финальные скобки сразу запускают функцию на исполнение
		5. return предоставляет публичный интерфейс

===============================
что такое коллбеки?

	функции в JS могут принимать и возвращать другие функции. когда функция получает другие функции в качестве аргументов, то она в своём теле может выполнить один из аргументов-функций. в этом случае управление вернётся во внешний код.

===============================
чистая функция

	1. не имеет сайд-эффектов
	2. при получении одинаковых аргументов возвращает одинаковый ответ

	Примеры побочных эффектов:

		Видоизменение входных параметров
		console.log
		HTTP вызовы (AJAX/fetch)
		Изменение в файловой системе
		Запросы DOM

===============================
мемоизация

	это сохранение функцией результатов в кеше. каждый результат помечен индексом. если входящий аргумент совпадает с индексом, то значение отдаётся из кеша.

		function memoizedAddTo80() {
		  let cache = {};
		  return function (n) {
		    if (n in cache) {
		      console.log('cache');
		      return cache[n];
		    } else {
		      console.log('calc');
		      cache[n] = n + 80;
		      return cache[n];
		    }
		  };
		}
		const memoized = memoizedAddTo80();

		console.log(memoized(5));
		console.log(memoized(5));
		console.log(memoized(5));
		console.log(memoized(10));

		// calc cache cache calc

===============================
как сохранить родительский контекст при вызове IIFE?

	IIFE вызывается после объявления в контексте window:

		property1 = 'ffff';
		(function (par1, par2, par3) {
		  console.log(par1, par2, par3);
		  console.log(this.property1);
		})(1, 2, 3);
		// вывод в консоль: ffff

	сохранить контекст можно, используя bind():

		property1 = 'ssss';
		var a = {
		  property1: 'ffff',
		  method1: function () {
		    (function (par1, par2, par3) {
		      console.log(this.property1);
		    }.bind(this)(1, 2, 3));
		  },
		};
		a.method1();	
		// вывод в консоль ffff

	или использовать стрелочную функцию

		var a = {
		  property1: "test",
		  method1: function() {
		    ((par1, par2, par3) => {
		      console.log(this.property1);
		    })(1, 2, 3);
		  }
		};

		a.method1();

===============================
Object.seal()

	запрещает добавление и удаление свойств. при этом менять значение существующих свойств можно.

	const obj = {
	  a: 11,
	  b: 22,
	};
	Object.seal(obj);

	obj.a = 333;
	obj.c = 444;
	console.log(obj);

	// { a: 333, b: 22 }


Object.freeze()

	делает то же что и seal, но при этом невозможно изменить значение существующих свойств.

	const obj = {
	  a: 11,
	  b: 22,
	};
	Object.freeze(obj);

	obj.a = 333;
	obj.c = 444;
	console.log(obj);	

	// { a: 11, b: 22 }

===============================
дескрипторы объекта

	у объекта есть не только ключ-значение, но и дескриптор, с помощью которого можно:

		1. установить значение
		2. сделать его неперечислимым в цике
		3. запретить его изменение
		4. запретить изменять сам дескриптор

	устанавливается дескриптор так:

		Object.defineProperty(obj, 'a', {
		  enumerable: false,
		});	

	получить значение дескриптора для свойства 'a' можно так:

		Object.getOwnPropertyDescriptor(obj, 'a')	

	вот пример работы этих свойств:

		let obj = {
		  a: 1,
		  b: 2,
		};

		Object.defineProperty(obj, 'a', {
		  enumerable: false,
		});

		let descriptor = Object.getOwnPropertyDescriptor(obj, 'a');

		console.log(descriptor);
		// вывод в консоль: {value: 1, writable: true, enumerable: false, configurable: true}

		for (let k in obj) {
		  console.log(k, obj[k]);
		}

		// вывод в консоль: b 2

===============================
hasOwnProperty()

	проверяет существует ли ключ в объекте и возвращает true/false. в отличие от in не проверяет наличие свойства в цепочке прототипа.

		let obj1 = {
		  a: 1,
		  b: 2,
		};

		let obj2 = {
		  c: 3,
		  d: 4,
		};

		obj2.__proto__ = obj1;

		console.log(obj2.hasOwnProperty('a'), obj2['a']);
		// false 1

		for (let x in obj2) {
		  console.log(x);
		}
		// c d a b

===============================
откуда свойства у всех сущностей?

	в JS все сущности являются объектами. эти объекты имеют иерархию предков. все эти объекты наследуются от Object. 

	срока получает в наследство метод length массив получает в наследство методы push() и т. д.

	когда происходит обращение к свойству/методу примитива, то он оборачивается в обёртку, которая является конструктором, создающим примитив. например для строкового примитива это String(). этот конструктор унаследованные имеет методы и свойства.

===============================
собственные объекты vs объекты хоста

	js имеет чётко определённый набор собственных объектов, которые доступны всегда: Math, Date, parseInt, Error и т. д.

	но JS используется в различных окружениях(браузер, node), у каждого из которых определён различный набор объектов хоста: window, document, setTimeout, getElementById  т.д.

===============================
методы массивов

	arr.push(...items) – добавляет элементы в конец,
	arr.pop() – извлекает элемент из конца,
	arr.shift() – извлекает элемент из начала,
	arr.unshift(...items) – добавляет элементы в начало.

	arr.splice(1, 1); // начиная с индекса 1, получить 1 элемент

		const arr = [1, 2, 3];
		console.log(arr.splice(1, 2));	// [2, 3]


	arr.slice([start], [end]) возвращает новый массив, в который копирует все элементы с индекса start до end 

		const arr = [1, 2, 3];
		console.log(arr.slice(0, 2));	// [1, 2]


	arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.

		const arr = [1, 2];
		console.log(arr.concat([8, 9]));	// [1, 2, 8, 9]


	includes()
	forEach()
	map()
	filter()
	reduce()
	find()

	sort получает кастомную функцию сравнения, получающую тоже 2 значения, которая будет возвращать 1, 0, -1

	reverse
	split
	join

===============================
push 

	добавляет элементы в конец массива

unshift

	добавляет элементы в начало массива. этот метод более затратен так какв памяти весь массив придётся сдвинуть по ячейкам, на это требуется больше ресурсов. 

===============================
как работает метод sort()

	если он отрабатывает без аргументов, то все элементы сортируеются на основе кодов символов в строке. 

	если аргументом передаётся функция, то она должна принимать 2 аргумента(a, b), которые будет сравнивать и возвращать:  1 0 -1. для учёт особенностей местного алфавита можно использовать для сравнения:

		'a'.localeCompare('b');

	Для числового сравнения, вместо строкового, функция сравнения может просто вычитать b из a

	пример поиска наименьшего числа в массиве числе: args.sort((a, b) => a - b)[0]

===============================
метод some()

	 проверяет наличие определённого элемента в массиве и возварщает true/false

		const arr = [1, 2, 3, 4, 5];
		const has = arr.some((x) => x === 2);
		console.log(has);	// true

метод every()

	позволяет узнать удовлетворяют ли все элементы массива условию и возвращает true/false

		const arr = [1, 2, -3, 4, 5];
		const con = arr.every((x) => x > 0);
		console.log(con);	// false

===============================
деструктуризация 

	это присваивание элементов массива или объекта переменным.

	для массива:

		const [a, b] = [1, 2];
		console.log(a, b);  // 1 2

		var тоже допускается

	для объекта:

		const { a, b } = { a: 1, b: 2 };
		console.log(a, b); // 1 2	

		есть возможность переопределить имена переменных: const { a: x, b: y }.

	для строк:

		const [a, b] = 'qwe';
		console.log(a, b); // q w	

===============================
spread vs rest

	spread позволяет передавать итерируемые коллекции как аргументы или добавлять их в новый массив/объект. то есть этот оператор преобразует массив в набор значений.

		function f(a, b) {
		  console.log(a); // 1
		  console.log(b); // 2
		}
		const nums = [1, 2];
		f(...nums);

	или

		const coll = [1, 2];
		const arr = [...coll, 3, 4];
		console.log(arr);

	или 

		const obj1 = { a: 1, b: 2 };
		const obj2 = { c: 3 };
		const obj3 = { ...obj1, ...obj2, d: 4 };
		console.log(obj3);

	rest оператор применяется для того чтобы пометить остаточные параметры функции. например функция вызвана с 4 аргументами, но принимает только 2 именованных:

		function f(a, b, ...c) {
		  console.log(a, b, c);		// 1 2 [3,4]
		}
		f(1, 2, 3, 4);

===============================
ООП

	это подход в написании программ, в котором все сущности представляют из себя объекты со свойствами и методами.

	принципы:

		абстракция - способ выделить главное в объекте и забыть о не имеющем значения для понимания. например, есть объект Чайник, программисту важно знать что его можно включать и выключать, а каким именно способом он нагревает воду, точный вес, прочность и т.д. знать не нужно чтобы пользоваться чайником.

		инкапсуляция - способ ограничить доступ к составляющим объекта. например у чайника публичные методы это включение и выключение, остальные методы скрыты модификаторами доступа private или protected чтобы вредители не смогли попользоваться чайником и, уходя, изменить температуру нагрева до 50 градусов.

		наследование - способ организовывать классы в иерерхию таким образом, что наследник имеет доступ к методам и свойствам родителей. это позволяет избежать дублирования кода. наследование это принцип проектирования "от общего к частному", а композиция это принцип проектирования "от частного к общему". надо наследованию предпочитать композицию потому что не всегда понятно от какого именно родителя логично унаследоваться. например, чайник с таймеров наследовать нужно от чайника или от таймера?

		полиморфизм - это способность метода/класса/функции выполнять различные операции в зависимости от получаемых данных. например объект истории хранит множество объектов типа Расход. но появилась необходимость кроме расходов хранить доходы. в этом случае создаётся класс Record, который принимает аргумент: type, amount. таким образом Record будет полиморфен, то есть в зависимости от аргумента type имеет различное значение и функционал.	это называется мнимы полиморфизм.

		другой пример: есть класс Person, у которого есть метод приветствия greet(). класс Coder наследуется от Person. у Coder тоже есть свой метод greet(), который переопределяет метод greet класса Person.
		далее в цикле переберём массив, состоящий из инстансов person и coder. в этом цикле будем запускать класс greet(). в результате один и тот же меод выводит различные приветствия. это называется параметрический полиморфизм.

		также примером полиморфизма является:

			'ssssss'.length
			['a', 's', 'd'].length

		length унаследован от Object и обрабатывает строку и массив разными алгоритмами.

		-------------

		ассоциация:

			композиция:

				это когда включаемый в класс объект создаётся внутри класса.

					class Engine{}

					class Car {
					    public Car() {
					        this.engine = new Engine(360);
					 	}				
					 }

			агрегация:

				это когда включаемый в класс объект создаётся вне класса (DI).

					class Engine{}      

					class Car {
					    public Car(Engine someEngine) {
					         this.engine = someEngine;
					    }
					}

					Engine goodEngine = new Engine(360);
					Car porshe = new Car(goodEngine);				


===============================
в JS наследование одиночное поэтому каждый объект может иметь только один прототип.

===============================
что такое функциональное программирование?

	в ФП все сущности представляются в виде чистых функций, которые принимают стейт и возвращают копию изменённого стейта. эти функции объединяются в композицию потому что являются функциями высшего порядка.

	То есть функция — это отображение входных данных на выходные.

	Чистые функции, которые лежат в основе ФП, надёжны, потому что всегда выдают одинаковый результат при одинаковых входных данных.

	ссылочная прозрачность это возможность заменить вызов чистой функции на конкретный результат.

	При компиляции кода, который обладает ссылочной прозрачностью, некоторые его куски можно «выполнить» заранее и получить готовое значение.

	но создание полных копий стейта требует ресурсов.

	полезные программы не могут существовать без сайд-эффектов поэтому такие эффекты нужно грамотно встраивать в функциональные программы.

===============================
парадигмы программирования:

	1. функциональное программирование (конвейер чистых функций)
	2. ООП (классы аналоги объектов реального мира)
	3. процедурное (много подпрограмм, связанных беспорядочно. подпрограммы могут принимать аргументы. есть оператор goto

===============================
встроенные прототипы

	все объекты-конструкторы объединены в иерархию. все подклассы наследуют методы суперклассов потому что их прототипы указывают на прототипы родителей. самый верхний суперкласс это Object.

		любой объект имеет метод toString(), который представляет объект в виде строки.
		любой массив имеет свойство length и метод push(). он перезаписывает метод toString() на свой собственный, который просто выводит элементы массива через папятую.

	при обращении к свойствам примитивов временно создаётся объект-обёртка, которая предоставляет методы и затем исчезает.

	Встроенные прототипы можно изменять. Например, если добавить метод к String.prototype, метод становится доступен для всех строк:

===============================
что такое ES классы

	это синтаксический сахар, на самом деле классы это функции. конструктор класса это тело функции, а методы класса добавляются через прототип функции.

		function User(name) {
		  this.name = name;
		}

		User.prototype.sayHi = function() {
		  alert(this.name);
		};

		let user = new User("Иван");
		user.sayHi();	

	Классы всегда используют use strict.

===============================
герреты/сеттеры
	
	в объекте есть свойства-данные, а есть свойства-аксессоры, которые являются методами, но вне объекта выглядят как свойства данные.

	при присваивании срабатывает метод set с аргументом. при считывании срабатывает меод get без аргумента.

	свойства-аксессоры применяют для оборачивания свойств-данных. например можно использовать предварительную проверку возраста.

===============================
способы расширения класса

	через наследование. наследовать можно от встроенных классов:

		class PowerArray extends Array {
		  isEmpty() {
		    return this.length === 0;
		  }
		}
		let arr = new PowerArray(1, 2, 5, 10, 50);
		alert(arr.isEmpty()); // false	

	то же самое через прототип:

		Array.prototype.isEmpty = function () {
		  return this.length === 0;
		};
		let arr = new Array();
		console.log(arr.isEmpty());	

	также класс можно расширять через композицию (включение другого класса чере зсвойство):

		class PowerArray {
		  isEmpty(n) {
		    return n.length === 0;
		  }
		}

		class Example {
		  constructor(x) {
		    this.a = new PowerArray();
		  }

		  start(n) {
		    const s = this.a.isEmpty(n);
		    console.log(s);
		  }
		}

		const example = new Example();
		example.start([1, 2]);
			
===============================
статические свойства и методы

	они принадлежат не экземпляру, а именно классу. this там равно конструктору класса. они наследуются через ссылку [[prototype]].

	статические методы используются для того чтобы хранить общий функционал. например, их можно использовать как фабрику экземпляров, которые немного отличаются от обычных экземпляров:

		class Article {
		  constructor(title, date) {
		    this.title = title;
		    this.date = date;
		  }

		  static createTodays() {
		    // помним, что this = Article
		    return new this("Сегодняшний дайджест", new Date());
		  }
		}	

	статические свойства используются для хранения общих констант и могут использоваться статическими методами. статический метод обращается к статическому свойству через this.

		class Money {
		  static rates = {
		    usd: {
		      eur: 0.7,
		    }
		  };

		  static setRate(from, to, value) {
		    this.rates[from][to] = value;
		  }
		}	

===============================
ключевоe слово new

	используется для создания объекта из конструктора. конструктором может выступать функция или класс.

	при использовании new происходит следующее:

		1. Создаётся новый пустой объект, и он присваивается this. (this = {})
		2. в пустой объект добавляются свойства через this.
		3. Возвращается объект со свойствами.	

	цель конструкторов - предоставить возможность создания однотипных объектов.

===============================
super используется:

	1. в конструкторе дочернего класса для запуска конструктора родительского класса. super должно использоваться до первого this потому что не смысла объявлять переменную и сразу после этого её заменять на переменную из родителя:

		class Fish {
		  constructor(habitat, length) {
		    this.habitat = habitat
		    this.length = length
		  }
		  
		  renderProperties(element) {
		    element.innerHTML = JSON.stringify(this)
		  }
		}
		class Trout extends Fish {
		  constructor(habitat, length, variety) {
		    super(habitat, length)
		    this.variety = variety
		  }
		  
		   renderPropertiesWithSuper(element) {
		    element.className="green" 
		    super.renderProperties(element);
		  }
		}

	2. для вызова методов родительского класса

		см. пример выше

	3. для связывания объектных литералов (дочерний может вызвать метод родительского)

		var obj1 = {
		  method1() {
		    console.log('method 1');
		  }
		}

		var obj2 = {
		  method2() {
		    super.method1();
		  }
		}

		Object.setPrototypeOf(obj2, obj1);

	4. для вызова статических методов родительского класса

		class Rectangle {
		  static logNbSides() {
		    return 'У меня 4 стороны';
		  }
		}

		class Square extends Rectangle {
		  static logDescription() {
		    return super.logNbSides() + ', равные между собой';
		  }
		}	

===============================
класс это синтаксический сахар над обычной функцикй:

	class Hero {
		constructor(name, level) {
			this.name = name;
			this.level = level;
		}

		// Adding a method to the constructor
		greet() {
			return `${this.name} says hello.`;
	    }
	}	

	то же самое:

	function Hero(name, level) {
		this.name = name;
		this.level = level;
	}

	// Adding a method to the constructor
	Hero.prototype.greet = function() {
		return `${this.name} says hello.`;
	}	

===============================
promise vs async/await

	1. в промисах ошибки отлавливаются при помощи коллбеков, а в async\await при помощи try/catch
	2. запись async/await более напоминает синхронный код, хотя делает в принципе то же, что и промис.
	3. если в случае последовательного исполнения нескольких асинхронных операций происходит ошибка, то async/await предоставляет более подробную информацию.

		const makeRequest = async () => {
		  await callAPromise()
		  await callAPromise()
		  await callAPromise()
		  await callAPromise()
		  await callAPromise()
		  throw new Error("oops");
		}

		makeRequest()
		  .catch(err => {
		    console.log(err);
		    // output
		    // Error: oops at makeRequest (index.js:7:9)
		 })	

===============================
отлов ошибок в цепочках промиса 

	просиходит при помощи второго коллбека error или при помощи блока catch. при этом catch вообще может вернуть промис и работоспособность дальнейшей цепочки восстановится(то же самое можно сделать из коллбека error).

	catch может проверить ошибку через instancof и в зависимости от этого обоработать или пробросить дальше. если она пробрасывается дальше, то следующие блоки then пропускаются, а следующий блок catch срабатывает. 

	в промисе и блоках then/catch всегда есть неявный try/catch. это выражается в том, что если намеренно выбрасывается исключение 

		throw new Error("Ошибка!");

	, то оно заворачивается в reject.

===============================
статические методы класса Promise

	1. Promise.resolve - создаёт успешно выполненный промис
	2. Promise.reject - создаёт неуспешно выполненный промис
	3. Promise.all - получает несколько промисов, ждёт их завершения и отдаёт результаты в виде массива(или ошибку)
	4. Promise.allSettled - то же самое, но результаты отдаются при любом исходе в виде массива с элементами: {status:"fulfilled", value:результат}
	5. Promise.race - получает несколько промисов и ждёт первый выполнившийся(или ошибку)
	6. Promise.any - то же самое, но ждёт только первый успешный промис, ошибка игнорируется

===============================
можно ли отменить выполнение промиса?

	нет

===============================
что такое ajax?

	в одной из версий IE появился объект XMLHttpRequest. от него можно было создать экземпляр и затем повесить обработчики. этот объект стал использоваться для асинхронный действий, например, можно было отправить запрос на сервер, получить успешный ответ и обновить DOM, не перезагружая страницу.

		let xhr = new XMLHttpRequest();

		xhr.onload = function() {
		  alert(`Загружено: ${xhr.status} ${xhr.response}`);
		};

		xhr.onerror = function() { 
		  alert(`Ошибка соединения`);
		};

		xhr.onprogress = function(event) { // запускается периодически
		  alert(`Загружено ${event.loaded} из ${event.total}`);
		};		

	технологии, которые позволяли производить подобные действия называются AJAX. например fetch используется для отправки запросаов, promise для их обработки, js для изменения DOM.

	fetch - это часть браузерного апи. он выполняет запрос на сервер и возвращает промис, который содержит объект ответа и дополнительные вещи типа статуса:

		let response = await fetch(url);
		if (response.ok) {
		  let json = await response.json();
		} else {
		  alert("Ошибка HTTP: " + response.status);
		}

	или так:

		fetch('http://jsonplaceholder.typicode.com/posts')
		  .then((response) => response.json())
		  .then((data) => data)	

	По умолчанию fetch() запросы не включают в себя cookies 

	axios ещё одна библиотека для работы с запросами. она как и fetch возвращает промис.

		axios.get('/path').then(res => {
		    console.log(res); 
		});

		axios.post('/path', {"Name": "Vova"}).then(res => {
		    console.log(res);	

===============================
чем observable отличается от промиса?

	1. генерирует поток значений, а промис отдаёт только одно значение
	2. observable можно отменить, а промис нельзя
	3. для использования observable нужно подключать библиотеку, а промис это нативная возможность js

===============================
промисификация 
	
	это преобразования асинхронной функции, которая работает на коллбеках в функцию, которая возвращает промис.

	то есть создаётся обертка над оригинальной функцией, эта обёртка возвращает промис, содержащий resolve или reject. 

		было:

			function getData(onSuccess, onError) {
			  setTimeout(function () {
			    const result = Math.random()
			    if (result > 0.5) {
			      onSuccess(result)
			    } else {
			      onError(new Error('Что-то пошло не так'))
			    }
			  }, 1000)
			}

		стало:

			function getData() {
			  return new Promise(function (resolve, reject) {
			    const result = getData(
			      function (result) {
			        resolve(result)
			      },
			      function (error) {
			        reject(error)
			      }
			    )
			  })
			}	

===============================
функция

	это набор последовательных команд, который можно переиспользовать. кроме того функция может содержать свойства (как обычный объект потому что функция это и есть объект), а так же переменные (объявленные через var). к переменным нельзя обратиться извне, а к свойствам можно.

		function foo() {
		  var count = 2;	// переменная
		  foo.count = 1;	// свойство
		  console.log(count); // 2
		  console.log(foo.count); // 1
		}

		foo();

		console.log(foo.count); // 1


================================
что такое http?

	это протокол обмена данными между клиентом и сервером, который не предполагает сохранения состояния.

	Чтобы отобразить веб страницу, браузер отправляет начальный запрос для получения HTML-документа этой страницы. После получения ответа браузер изучает этот документ, и запрашивает дополнительные файлы, необходимые для отбражения содержания веб-страницы (исполняемые скрипты, информацию о макете страницы - CSS таблицы стилей, дополнительные ресурсы в виде изображений и видео-файлов), которые непосредственно являются частью исходного документа, но расположены в других местах сети. Далее браузер соединяет все эти ресурсы для отображения их пользователю в виде единого документа — веб-страницы.

	после ввода адреса в адресную строку формируется запрос, который состоит из 3 составляющих: 
		метод, 
		путь к ресурсу, 
		версия http-протокола,
		заголовки запроса,
		тело запроса (присутствует на всегда, зависит от метода запроса)

	ответ сервера содержит: 
		версию http-протокола, 
		код ответа, 
		человекточитаемый статус ответа, 
		заголовки ответа, 
		тело ответа (присутствует на всегда, зависит от метода запроса)

	Пример запроса:
	    GET http://ya.ru/index.html HTTP/1.1

	Пример ответа:
	    HTTP/1.1 200 Ok


	методы:
		OPTIONS - используется для проверки возможностей сервера. в частности для случая кроссдоменных запросов.
		GET - Используется для запроса содержимого указанного ресурса.
		HEAD - Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело.
		POST - предназначен для передачи данных на сервер. при повторении не обязательно возвращает одинаковые результаты. в контексте REST используется для изменения данных. предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого.
		PUT - 
		PATCH - 
		DELETE - удаляет ресурс.


	Код состояния информирует клиента о результатах выполнения запроса. 
		1** - информационный
		2** - успешно
		3** - редирект
		4** - ошибка на строне клиента
		5** - ошибка на стороне сервера

		200 - ОК
		404 - not found
		401 - запрещено
		500 - ошибка сервера


	Заголовок HTTP (HTTP Header) — это строка в HTTP-сообщении, содержащая разделённую двоеточием пару вида «параметр-значение

	HTTP-заголовки разделяются на четыре основных группы:
	General Headers (Основные заголовки) — должны включаться в любое сообщение клиента и сервера.
	Request Headers (Заголовки запроса) — используются только в запросах клиента.
	Response Headers (Заголовки ответа) — присутствуют только в ответах сервера.
	Entity Headers (Заголовки сущности) — сопровождают каждую сущность сообщения.

	Присутствие тела сообщения в запросе отмечается добавлением к заголовкам запроса поля заголовка Content-Length или Transfer-Encoding.	

================================
разница между http и https

	https шифрует трафик, хотя он чуть медленнее http. 
	http использует порт 80. https использует порт 443.


	сертификаты бывают: ssl, tls.

	сертификаты выдаёт центр сертификации. по сути  ЦС выдаёт клиенту и серверу набор ключей, которые те используют в шифровании. поэтому ЦС должен иметь доверие пользователей.

================================
CORS

	существует ограничение, из-за котрого невозможно выполнять асинхронные кроссдоменные запросы (то есть запросы на другой источник). например, клиент асинхронно загружает с сервера js-скрипт, согласно политике одного домена, этот скрипт может отправить запрос только на этот же сервер, но не на другой. CORS это механизм, которые позволяет это ограничение обойти. 

	для этого в некоторых случаях отправляется предварительный запрос OPTIONS, который содержит специальные заголоки. если сервер устраивает, что его будет использовать клиент в качестве другого источника, то он отправляет специальные заголовки, которые разрешают последующий запрос. в этом случае фактически запрос состоит из двух запросов.

	но сервер может заблокировать запрос. это поможет предотвратить ситуацию когда клиент загружает скрипт, а этот скрипт берёт куки клиента и ломится с ними на сайт банка. сайт банка, получив предварительный запрос, пошлёт отказ.



	jsonp это способ способ загрузить json с другого домента. как известно, политика одного домена этого не разрешает. но если динамически создать элемент script и в его scr поместить запрос, то кроссдоменный запрос отработает без проблем.

	важно то, что к url нужно в виде get-параметра добавить коллбек, который выполнится сразу после получения данных:

		var s = document.createElement("script");
		s.src = "demo_jsonp2.php?callback=myDisplayFunction";
		document.body.appendChild(s);

		function myDisplayFunction(myObj) {
			console.log(myObj.name);
		}	

================================
что такое rest архитектура?

	это способ создания API с помощью протокола HTTP.

	rest это архитектурный стиль взаимодействия между компонентами распределённой системы. например клиент и сервер физически находятся в разных местах. обмен сигналами происходит через http-запросы. для клиента это значит, что если он хочет отправить сигнал на сервер, то должен будет использовать запрос, сформированный с url строго определённого типа.

	действие запроса определяется тем какой он использует метод: get, post, delete put и т.д. некоторые из методов предполагают отправку данных(post), некоторые просто посылают сигнал(delete). 

	например:

		delete book/3 удаляет запись, соответствующую книге №3.
		post book/3 записывает данные в книгу №3. при этом сами данные отправляются в теле запроса.

	принципы:

		клиент сервер разделены.
		каждый запрос должен содержать в себе всю необходимую информацию потому что http не сохраняет состояние.
		необходимо использовать кеширование для большей эффективности.
		клиент может запрашивать скрипты и выполнять их. 

================================
same origin policy 

	это политика одного источника. она определяла как скрипт или картинка, загруженная с одного сервера можети взаимодействовать с другим сервером (например, послать запрос на другой сервер).

	две страницы имеют одинаковый источник, если у них одинаковы:

		протокол,
		домен,
		порт

	когда появился CORS стало возможно более тонко настроить политику одного источника, основываясь на заголовках предварительного запроса OPTIONS.

================================
mime тип

	всё, что не является чистым текстом передаётся в теле запроса в закодированном виде. чтобы принимающая сторона могла декодировать содержимое ей нужно знать по каким правилам она будет декодировать. это правило называется mime-типом и прописывается в заглоловке content type. 

	mime типы могут быть такие:

		image/png
		image/jpg
		image/gif

		audio/mp4
		audio/mpeg

	то есть для обычного текста используется кодировка, а для закодированного текста используется mime-тип.


================================
CSRF

	это атака, в результате которой злоумышленние отправляет самодельную форму, вместе с реальными куками пользователя. для этого он: 

		1. заманивает пользователя на свой сайт
		2. конструирует форму
		3. автоматически отправляет её в сервис банка
		4. куки тоже отправляются
		5. банк получает куки, убеждается, что пользователь реальный,
		6. но банк никак не убеждается, что форма тоже была реальная, а не поддельная

	чтобы избежать этой атаки банк генерирует ключ на своей стороне и отправляет его закодированную версию чтобы пользователь подписал ей форму.
	после отправки подписанной формы банк сравнивает ключ и закодированную версию ключа.

XSS

	это уязвимость интерактивных элементов, которые, получая скрипт, заключённый в теги <script></script> сразу его начинают выполнять. а этот скрипт имеет доступ к кукам и может их отправить по email злоумышленнику.

	к примеру в чате 10 пользователей. злоумышленник отправляет всем скрипт и у каждого браузер выполняет этот скрипт. в результате злоумышленник получает 10 кук, при помощи которых может авторизоваться на популярном сайте.

	в другом случае злоумышленник может поместить скрипт не в чат, а в БД.

	в другом случае злоумышленник может поместить скрипт в один из гет-параметров.


================================
статус ответа 302

	301 это редирект страницы на другой url. а 302 это временный редирект страницы на новый url, при этом поисковые системы понимают, что не нужно менять свой индекс потому что скоро сайт снова станет доступен по старому адресу. 

	часто 302 используется во время проведения на сайте тех. работ.

================================
TCP и IP 

	основная роль IP заключается в поиске адреса, на который будут доставлены данные, а TCP отвечает именно за передачу данных. 

	TCP/IP аппаратно независим. то есть он может отправлять данные между устройствами с различной технологией преедачи данных.

================================
HTTP2

	это следующая версия протокола HTTP. её особенностями являются:

		1. бинарный формат, а не текстовый
		2. все запросы объединяются в один запрос, 
		3. дополнительные ресурсы страницы типа картинок и скриптов известны сразу
		4. время ожидания уменьшается, но увеличивается нагрузка на пропускную способность канала

================================
коды http ответов

	1** - информационный
	2** - успешно
	3** - редирект
	4** - ошибка на строне клиента
	5** - ошибка на стороне сервера

	200 - ОК
	404 - not found
	401 - запрещено
	500 - ошибка сервера

================================
веб сокеты

	это протокол обмена данными между клиентом и сервром, который позволяет  инициировать отправку данных не запросом клиента, а иннициативной сервера. при этом сервер может иметь постоянную реактивную связь с несколькмими клиентами. при этом запросы могут идти одновременно в обоих направлениях.

	кроме обычных веб сокеров ws существует шафрованная версия веб сокетов wss. это аналог https.

	перед установкой веб сокет соединения сначала отправляется запрос-рукопожатие в виде обычного http с определёнными заголовками.

	веб сокеты тоже используют протокол TCP для доставки данных. то есть большоие куски данных могут разбиваться на пакеты.

================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
основы js
================================
что такое область видимости?

	область видимости это область программы, в пределах которой установлена связь между объявлением переменной и обращением к переменной. 
	Окружение для области видимости — это доступные из текущего блока внешние переменные.

	существуют лексические и динамические области видимости.

	  лексическая область видимости (связь между объявлением переменной и обращением к переменной) формируются на этапе лексического разбора, а не на этапе выполнения программы.

	  то есть если разработчик написал функцию IN, которая вложена в функцию OUT, то после запуска программы функция IN всегда будет искать переменную сначала в своей области видимости, а затем в области видимости функции OUT:

	    function OUT() {
	      let a = 1;
	      function IN() {
	        console.log(a);
	      }
	    }

	  динамическая область видимости формируется на этапе выполнения. то есть если вызванная функция не находит переменную, то она будет искать её у функции, которая находится в стеке вызовов ниже:

	    let value = 2;

	    function showValue() {
	     console.log("Value from showValue: " + value); // 3
	    }

	    function wrapper() {
	     let value = 3;
	     console.log("Value from wrapper: " + value); // 3
	     showValue();
	    }

	    wrapper();  

	Область видимости определяет доступность переменных. существует глобальная область видимости и локальная.

	глобально объявленная переменная доступна из любых функций и блоков. переменные, которые объявлены в функциях и блоках недоступны извне. важно понимать, что если переменная не найдена в текущей области видимости, то она ищется во внешней и т.д.

================================
что такое замыкание?

	Замыкание – это способность внутренней функции получить доступ к переенным внешней функции уже после того как внешняя функция отработала.

	понятие замыкания тесно с вязано с понятиями область видимости и лексическое окружение.
	на этапе лексического анализа для каждой области видимости создаётся объект лексического окружения, который содержит:

		1. все переменные функции/блока с их значениями
		2. ссылку на лексическое окружение, в котором находится её определение.

	таким образом объекты лексических окружений выстраиваются в древовидную структуру. каждый узел этой структуры существует до тех пор пока хотя бы один из дочерних узлов на него ссылается. это ключевой момент.

	далее поиск переменных будет проходить сначала внутри ЛО этой функции, а затем в более внешних ЛО.

	рассмотрим пример:

		function outer() {
			const count = 10;
		  
			return function inner() {
				console.log(count);
			}
		}
		const count = 100;
		outer()();		// output: 10

	суть примера в том, что ЛО функции outer продолжает жить пока на неё ссылается хоты бы одно внутреннее ЛО. и поэтому функци inner будет искать недостающие переменные в ЛО функции outer

	важно понимать, что при каждом запуске одной той же функции создаётся новое ЛО (на основе написанного до запуска программы кода).

	--------------------------
	В C и большинстве других распространенных языков после возврата функции (оператор return или просто окончание работы) все локальные переменные становятся недоступными, так как фрейм стека уничтожается. В JavaScript они остаются в некотором смысле доступными.

	Замыкание — это фрейм стека, который выделяется, когда функция начинает свое работу, и не освобождается после ее возврата

	--------------------------
	в случае с коллбеками замыкания тоже действуют:

		let a = 111;

		function outer(cb) {
		  console.log('outer', a); // 111
		  cb();	// 22
		}

		function bla() {
		  let a = 22;

		  let f = function () {
		    console.log('a=', a); // 22
		  };

		  outer(f);
		}

		bla();

	важно понимать, что замыкания это применение правил области видимости для функции, которая выполняется вне своей лексической области видимости.

	Замыкание — это когда функция может запомнить и иметь доступ к своей лексической области видимости даже тогда, когда она вызывается вне своей лексической области видимости.

=======================
что такое лексическое окружение?

	если область видимости это набор правил, при помощи которых значения переменных ищутся в зависимости от места их объявления, то лексическое окружение это реализация этих правил.    

	технически лексическое окружение представляет из себя объект, который создаётся на этапе работы анализатора кода и содержит:

	  1. ссылку на родительское лексическое окружение
	  2. набор переменных и их значений, определённых в функции

	если в результате выполнения программы переменная не найдена в текущем ЛО, то она ищется во внешнем, и т.д.

	ЛО не удаляется сборщиком мусора до тех пока пока хотя бы одно внутреннее ЛО имеет ссылку на него. ЛО формируется на этапе работы анализатора кода и не может измениться после запуска программы.

	ЛО это объект, который создаётся для: 

		1. функции , 
		2. для блока (в частности для каждой итерации цикла или блоков тиа if), 
		3. для скрипта 

================================
что такое контекст выполнения функции?

	контекст выполнения это объект, из которого вызванная функция берёт свойства через ссылку this. обычно контекст указывают при вызове так:

		context.func();

	важно понимать, что контекст определяется объектом из котрого ВЫПОЛНЕНА функция, а лексическое окружение определяется функцией, внутри, которой ЗАПИСАНА функция.

	this.внутри функции указывает на контекст объекта, в котором она была выполнена:

		const obj = {
			a: 10,
			inner: function() {
				console.log('inner', this);
			}
		}

		const outer = function() {
			console.log('outer', this);
		}

		outer();							// window
		obj.inner();						// { a: 10, inner: f }
		inner = obj.inner;
		inner();							// window - потеря контекста

	----------------------------

	привязка this происходит при каждом вызове функции, на основании ее точки вызова.

	точка вызова это место в коде, где была вызвана функция (не там, где она объявлена). точку вызова можно отследить по стеку вызванных функций.

	правила для определения привязанного контекста:

		1. привязка по умолчанию

			когда функция вызывается без применения последующих правил:

				function foo() {
					console.log( this.a );
				}
				var a = 2;
				foo(); // 2		

			важно понимать, что если функция выполнена с привязкой по умолчанию, то контекстом будет window или undefined(это зависит от 'use strict'). при этом не важно вложена ли функция в другую функцию или нет. следующий код выведет 3:

				var a = 3
				function qwe() {
				  var a = 2;
				  function foo() {
				    console.log( this.a );
				  }
				  foo(); // 3
				}
				qwe() 			

		2. неявная привязка

			это когда перед функцией стоит владеющий объект:

				function foo() {
					console.log( this.a );
				}
				var obj = {
					a: 2,
					foo: foo
				};
				obj.foo(); // 2		

			важно то, что в качестве владеющего объекта может выступать функция потому что она тоже является объектом.

		3. явная привязка

			это использование call/apply

				function foo() {
					console.log( this.a );
				}
				var obj = {
					a: 2
				};
				foo.call( obj ); // 2		

			или использование bind

				function foo(something) {
					console.log( this.a, something );
					return this.a + something;
				}
				var obj = {
					a: 2
				};
				var bar = foo.bind( obj );
				var b = bar( 3 ); // 2 3
				console.log( b ); // 5

			по сути это вызов функции, которая внутри себя использует явную привязку

		4. new-привязка

			когда функция вызывается с указанием перед ней new, то:

				1. создаётся пустой объект {}
				2. this = {}
				3. этот объект заполняется через this.a = 123;
				4. функция возвращает сконструированный выше объект

			function foo(a) {
				this.a = a;
			}
			var bar = new foo( 2 );
			console.log( bar.a ); // 2	

=================
что такое стрелочная функция?

	СФ не имеет собственного контекста и ищет контекст вверх по иерархии лексического окружения, к которому принадлежит. 

	то есть контекст стрелочной функции определяется на этапе лексического анализа, а контекст обычной функции определяется на этапе вызова функции.

	отличия стрелочной функции от обычной.

		1. стрелочная функция не имеет собственного контекста. 
		2. не имеет названия
		3. не имеет псевдомассива arguments
		4. в ряде случаев можно не писать return
		5. Стрелочные функции нельзя использовать с new

		const obj = {
		  a: 10,
		  inner: () => {
		    console.log('inner', this);
		  }
		}

		obj.inner();					// window
		const f = obj.inner;
		f.call({a: 100});				// window

	то же самое для обычной функции:

		const obj = {
		  a: 10,
		  inner: function() {
		    console.log('inner', this);
		  }
		}
	  obj.inner();	// { a: 10, inner: f }

  	-------------------

		let group = {
		  title: "Our Group",
		  students: ["John", "Pete", "Alice"],

		  showList() {
		    this.students.forEach(
		      student => console.log(this.title + ': ' + student)
		      // ошибки нет, хотя КАЖЕТСЯ, что СФ выполняется из контекста window
		    );
		  }
		};

		group.showList();	

		// Our Group: John
		// Our Group: Pete
		// Our Group: Alice		

		-----------------

		function greetWaitAndAgain() {
		  console.log(`Hello, ${this.name}!`)
		  setTimeout(() => {
		    console.log(`Hello again, ${this.name}!`)
		  })
		}

		const user = { name: 'Alex' }

		user.greetWaitAndAgain = greetWaitAndAgain;
		user.greetWaitAndAgain()

		// Hello, Alex!
		// Hello again, Alex!
		// setTimeout принадлежит функции greetWaitAndAgain, а та является частью объекта user. следовательно this стрелочной функции будет ссылаться на user.

================================
что такое промисы?

	промис это объект, который используется для выполнения асинхронного кода. он содержит функцию-экзекутор, которая выполняется сразу после создания промиса. в функции-экзекуторе происходит вызов resolve или reject. затем результат спускается по цепочке подписчиков.

		состояние до выполнения промиса - pending. после выполнения - filfilled или rejected.
		результат до выполнения - undefined. после выполнения value или error.

		console.log(1);
		const p = new Promise((resolve, reject) => {
		  console.log(2);
		  resolve('resolve!');	// reject('reject!');
		  console.log(3);
		});
		console.log(4);

		// вывод консоли будет: 1 2 3 4

	промис отдаёт thenable объект, на который можно подписаться при помощи двух коллбеков:

		p.then(
			success => console.log('success!'),
			error => console.log('error!')
		)

		then можно объединять в цепочки при этом важно помнить, что блок success или error должен вернуть тоже промис иначе в следующем блоке success будет undefined. то есть исполнение в любых случаях пройдёт по всем then в любом случае(даже после catch потому что catch это тот же then, но без первого коллбека).

			new Promise((resolve, reject) => resolve('resolve!'))
			  .then(
			    (success) => {
			      console.log('success!1', success);
			      reject();
			    },
			    (error) => console.log('error!1', error)
			  )
			  // .catch((error) => {
			  //   console.log('catch after 1', error);
			  //   return 444;
			  // })
			  // то же самое, что и...
			  .then(null, (error) => {
			    console.log('error after 1', error);
			    return 444;
			  })
			  .then(
			    (success) => {
			      console.log('success!2', success);
			      return 666;
			    },
			    (error) => console.log('error!2', error)
			  )
			  // finally никак не влияет на цепочку, но может вернуть reject()
			  .finally(() => {
			    console.log('fff');
			    return 777;
			  })
			  .then(
			    (success) => console.log('success!3', success),
			    (error) => console.log('error!3', error)
			  );

				// success!1 resolve!
				// error after 1 ReferenceError
				// success!2 444
				// fff
				// success!3 666

	-----------

	промисификация это переписывание функции, которая принимает 2 коллбека в промис. эта новая функция будет возвращать промис.

		было:

			function getData(onSuccess, onError) {
			  setTimeout(function () {
			    const result = Math.random()
			    if (result > 0.5) {
			      onSuccess(result)
			    } else {
			      onError(new Error('Что-то пошло не так'))
			    }
			  }, 1000)
			}

		стало:

			function getData() {
			  return new Promise(function (resolve, reject) {
			    getData(
			    	result => resolve(result),
			      error => reject(error)
			    )
			  })
			}

	------------

	Promise.all - аналог forkJoin. то есть ждёт завершения всех промисов и возвращает их результаты в виде массива. отклоняется, если хотя бы один из переданных промисов завершится с ошибкой.
	Promise.allSettled - аналог Promise.all, но результат возвращает в виде { status: "fulfilled", value: "^_^" }. не имеет значения завершились промисы успешно или с ошибкой.
	Promise.any - аналог all(), но возвращает значение первого успешно выполненного промиса. завершится с ошибкой, если все переданные промисы завершатся с ошибкой.
	Promise.race - возвращает значение первого выполнившегося промиса даже если он завершился с ошибкой.
	
================================
что такое hoisting?

	hoisting это процесс помещения переменных в лексическое окружение на этапе компиляции и присвоение им значений на этапе выполнения. при этом будет получена ошибка, если на этапе компиляции обратиться к let или const. для var значение будет undefined. function declaration и параметры функции будут доступны сразу.

		function f1() {
		  console.log('before', a);	// output: undefined
		  var a = 100;
		  console.log('after', a);	// output: 100
		}
		f1();

		function f2() {
		  console.log('before', a);	// output: ERROR
		  let a = 100;
		  console.log('after', a);	// output: 100
		}
		f2();

	function declaration и входящие параметры функции будут доступны сразу.

	классы нужно объявлять именно перед созданием инстанса.

	Назначение переменных имеет приоритет перед объявлением функции.
		var double = 22;
		function double(num) {
		  return (num*2);
		}
		console.log(typeof double); // Вывод: number


	Объявление функции имеет приоритет перед объявлением переменной.
		var double;
		function double(num) {
		  return (num*2);
		}
		console.log(typeof double); // Вывод: function

================================
что такое event-loop? как он работает?

	эвент луп(ЭЛ) это цикл, который обрабатывает поступающие в него задачи. задачи могут быть синхронными и асинхронными(событиями). синхронные заполняют стек, а асинхронные попадают в очередь. если к событию не привязан обработчик, то оно не обрабатвается циклом событий.

	когда функция начинает выполнение, то создаётся контекст выполнения. он помещается в стек. если эта функция вызывает другую функцию, то в стек попадает ещё один контекст. таким образом по мере выполнения синхронных задач стек загружается и разгружается.

	когда в стеке нет задач, то начинают выполняться асинхронные задачи из очереди. setTimeout помещает задачу в очередь по прошествиии времени, указанного во втором аргументе.

	любое событие, например клик, помещается в очередь асинхронных событий(если на клик повешен обработчик, конечно же).

	важно понимать, что очерель событий начинает работать только после того как весь код основного скрипта выполнился и поэтому js-движок перешёл в режим ожидания.

	очередь асинхронных событий состоит из микроадач(приоритетных) и макрозадач (не приоритетных). микрозадачи это промисы, макрозадачи это setTimeout, события браузера, сетевые запросы. существует возможность принудительно микромизировать задачу при помощи queueMicrotask(f).

	после каждой макрозадачи начинается перерисовка экрана. но экран не перерисовывается после каждой микрозадачи, необходимо чтобы все микрозадачи выполнились.

	после каждой макрозадачи движок исполняет все задачи из основного потока или из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице

================================
что такое иммутабельность?

	это состояние объекта, в котором его после инициализации невозможно изменить. результатом попытки любого изменения такого объекта будет новый объект. при этом старый объект остаётся без изменений.

	если объект имеет вложенную структуру, то все вложенные объекты, не подвергшиеся модификации, будут переиспользованы.

================================
как перебрать объект?

	// a 1 d 3
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		for (key in obj) {
		  console.log(key, obj[key]); 
		}

	// a 1
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		for (key in obj) {
		  if (obj.hasOwnProperty(key)) {
		    console.log(key, obj[key]); 
		  }
		}

	// a 1
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		const keys = Object.keys(obj);
		keys.forEach((key) => console.log(key, obj[key]));

	// 1
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		const keys = Object.values(obj);
		keys.forEach((value) => console.log(value));	

	// a 1
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		const keys = Object.entries(obj);
		keys.forEach(([key, value]) => console.log(key, value));

	// a 1
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		const keys = Object.getOwnPropertyNames(obj); // массив перечисляемых и неперечисляемых свойств объекта
		keys.forEach((key) => console.log(key, obj[key]));

===============================
способы создания объекта

	1. var person = new Object();

	2. const obj = {}

	3. var person = Object.create(null);

	4. 
		const Construct = function () {
		  this.name = 'masha';
		};
		const person = new Construct();
		console.log(person);		

================================
способы копирования объектов:

	1. JSON.parse(JSON.stringify(obj))

		глубокая копия. методы не копируются. не работает для циклических объектов. кроме несериализуемых данных: undefined, symbol()

			JSON.parse(JSON.stringify(itemsInCart))


	2. Object.assign

		неглубокая копия. методы копируются

			const a = { name: 'Joe Bloggs' };
			const b = Object.assign({}, a);
			console.log(a === b); //=> flase		


	3. clone = { ...user };

		неглубокая копия. методы копируются

			const a = { name: 'Joe Bloggs' }
			const b = { ...a, age: 27 };
			console.log(a === b) //=> false		


	4. for (let key in user) {}

		неглубокая копия. методы копируются

			function copy(mainObj) {
			  let objCopy = {};

			  for (let key in mainObj) {
			    objCopy[key] = mainObj[key];
			  }
			  return objCopy;
			}

			const mainObj = {
			  a: function () {
			    console.log(123);
			  },
			  b: 5,
			  c: {
			    x: 7,
			  },
			};

			const copyObj = copy(mainObj);
			console.log(copyObj); // ok
			copyObj.a(); /// 123		


	5. рекурсивный обход

		глубокая рекурсия. методы не копируются

			function isPrimitive(obj) {
			  return (
			    obj == null ||
			    typeof obj === 'number' ||
			    typeof obj === 'string' ||
			    typeof obj === 'boolean'
			  );
			}

			function isArray(obj) {
			  return Array.isArray(obj);
			}

			function isObject(obj) {
			  return obj != null && typeof obj === 'object';
			}

			function deepClone(obj) {
			  if (isPrimitive(obj)) {
			    return obj;
			  } else if (isArray(obj)) {
			    return obj.map((val) => {
			      return deepClone(val);
			    });
			  } else if (isObject(obj)) {
			    let res = {};
			    for (let k in obj) {
			      res[k] = deepClone(obj[k]);
			    }
			    return res;
			  }
			}

			const obj1 = {
			  a: 10,
			  b: [{ a: 1 }, { b: 2 }],
			};

			const obj2 = deepClone(obj1);
			obj1.b[0].a = 100;
			console.log(obj1, obj2);


	6. lodash cloneDeep()

		глубокая копия

	7. structuredClone()

		глубокая копия

================================
что такое глубокая и мелкая копия объекта?

	если объект состоит из вложенных структур, то при создании копии копируются только приммитивы, а объекты ссылаются на одно и то же место в памяти.

		const itemsInCart = [
		  { product: 'Носки', quantity: 3 },
		  { product: 'Штаны', quantity: 1 },
		  { product: 'Кепка', quantity: 1 },
		];
		const clonedCart = [...itemsInCart];

		itemsInCart[0].quantity = 4;

		console.log(itemsInCart[0].quantity);	// 4
		console.log(clonedCart[0].quantity);	// 4

	глубокая копия это когда оригинал и копия полностью независимы. мелкая копия это когда копия и оригинал зависимы вложенными структурами.

================================
e.preventDefault()

	отменяет стандартное событие. например, клик по ссылке не приведёт к переходу на другую страницу. или клик по чекбоксу не будет менять состояние чекбокса.

		<input type="checkbox" id="my-checkbox" />
		document
		  .getElementById('my-checkbox')
		  .addEventListener('click', (e) => e.preventDefault());

event.stopPropagation()

	останавливает всплытие. то есть всплывающее событие будет вызывать все обработчики на своём пути. но, встретив, stopPropagation оно остановится.

		<body onclick="alert('сюда обработка не дойдёт')">
		  <button onclick="event.stopPropagation()">Кликни меня</button>
		</body>

================================
DOM

	это объект, который строится на основе парсинга html-документа сразу после загрузки html с сервера. DOM имеет более строгую структуру потому что html может иметь ошибки в виде незакрытых случайно тегов.

	DOM позволяет менять html средствами js.

window 

	это глобальный объект браузера. он хранит все глобально доступные свойства и методы. например, alert(), console.log(). контекст window не обязательно писать перед точкой.

	каждая вкладка браузера содержит свой отдельный window.

	Window.location - получает или устанавливает url.
	Window.localStorage - хранит объект локального храналища с методами добавления и получения.
	Window.history - хранит объект истории браузера(только чтение)

================================
document

	Это объект, который позволяет работать с html-структурой страницы, а так же с куками.

	window — содержит свойства и методы для управления окном браузера. document — позволяет работать с содержимым страницы.

================================
addEventListener 

	это альтернативный способ добавить обработчик события html-элементу. в отличие от атрибутивного способа он позволяет программно удалять обработчики, а так же повесить несколько обработчиков событий на один элемент (атрибут так не умеет и будет перезатирать предыдущие). 

================================
делегирование событий

	это способ обработать много элементов похожим образом при помощи назначения обработчика их родителю, а не каждому элементу.

	event.target позволяет понять на каком конкретно элементе произошло событие.

================================
модификация в DOM

	document.createElement('div');

	document.body.append(div);
	document.body.prepend(div);

	document.body.insertAdjacentHTML("afterbegin", `<div class="alert">
		<strong>Всем привет!</strong> Вы прочитали важное сообщение.
	</div>`);	

	div.remove()

	elem.cloneNode(true) создаёт «глубокий» клон элемента

================================
requestAnimationFrame

	это функция, предоставляемая браузером, которая приводит частоту обновления анимации к частоте обновления экрана. по сути эта функция похожа на setTimeout, но интервал обновления браузер рассчитывает сам.

	кроме того начало каждого цикла анимации будет совпадать с началом цикла перерисовки в браузере, это экономит ресурсы браузера.

		function step(timestamp) {
		  // animation code
		  window.requestAnimationFrame(step);
		}
		window.requestAnimationFrame(step);	

web workers

	это средство для запуска скриптов в фоновом режиме. скрипты выполняются не в контексте window. эти скрипты не влияют на работу основного потока приложения.

	в отдельном файле нужно написать скрипт, который будет выполняться фоном и передать его в конструктор:

		var myWorker = new Worker("worker.js");

	пример отправки данных в воркер:

		myWorker.postMessage([first.value,second.value]);

	внутри воркера данные принимаются при помощи слушателя событий:

		onmessage = function(e) {
		  var workerResult = 'Result: ' + (e.data[0] * e.data[1]);
		  postMessage(workerResult);
		}		

	веб воркеры могут быть выделенные и разделяемые. 

	прмер кода:

		// web-worker.js
		onmessage = e => {
		  console.log("worker " + e.data);
		  postMessage("message from worker");
		};

		// index.js
		var myWorker;

		function send() {
		  myWorker.postMessage(document.getElementById("input").value);
		}

		if (window.Worker) {
		  myWorker = new Worker("web-worker.js");

		  myWorker.onmessage = e => {
		    console.log(e.data);
		  };
		}

================================
web api

	это функционал, который предоставляет браузер для встроенного языка JS. существуют апи для:

		1. работы с локальным хранилищем браузера
		2. для AJAX-запросов
		3. для геолокации
		4. для работы с устройствами, например считывающие геолокацию смартфона

	любой апи это объект, который предоставляет несколько публичных методов.

		var myGeo = navigator.geolocation;
		myGeo.getCurrentPosition(function(position) { ... });

		коллбек запустится, когда текущее положение устройства будет успешно считано.


================================
итератор

	это объект, который при помощи метода next() перебирает итерируемый объект.

	итерируемый объект имеет свойство с ключом Symbol.iterator. значением его является ссылка на итератор. в контексте цикла исполььзуется эта ссылка и итератор при каждом проходе цикла запускает next();

================================
генератор

	это функция котрая может возвращать значение многократно. после создания генератора можно использовать next(), что приведёт к очередному возвращаению значения.

		function* generator() {
		  yield 1;
		  yield 2;
		  yield 3;
		}
		const gen = generator(); // "Generator { }"
		console.log(gen.next().value); // 1	

	так как генератор это итерируемый объект, то внутри него есть свойство с ключом Symbol.iterator.

	генератор можно преебирать при помощи цикла, в этом случае цикл при каждом проходе будет неявно пинать next().


================================
Различия между for...of и for...in

	for...of перебирает итерируемый объект.

	for...in перебирает ключи объекта, в том свойства и унаследованные. если при помощи for...in перебирать массив, то будут выведены индексы элементов массива: 1, 2, 3 и т. д. причём в виде строки, а не числа.



================================
===============================
что такое прототип?

	есть: 

		1. объекты,
		2. функции-конструкторы, из которых сделаны эти объекты,
		3. объекты-хранилища (прототипы), которые есть у каждой функции-конструктора.

	важно понимать, что у обычных объектов нет прототипов.

	ссылка __proto__ есть и у функций-конструкторов и у объектов. ссылка __proto__ это геттер/сеттер для ссылки [[prototype]], которая напрямую недоступня для редактирования прграммисту.

	современный вариант __proto__ это: 

		Object.getPrototypeOf(arg),
		Object.setPrototypeOf(arg1, arg2).

	у объектов __proto__ указывает на прототип функции-конструктора, при помощи которой был сделан объект. например:

		const obj = new Object();
		console.log(obj); // {}
		console.log(obj.__proto__); // Object.prototype

	у функций-конструкторов __proto__ указывает на прототип родительской функции-конструктора (как изместно функции-конструкторы объединены в иерархию, на вершине которой находится Object)

	таким образом, существует возможность искать недостающие свойства и методы вверх по цепочке __proto__ в прототипе функции-конструктора. а если там не находится, то поиск будет продолжаться по __proto__ функции конструктора.

	однако существует возможность сделать так чтобы __proto__ объекта не ссылалась на простотип функции-конструктора, а ссылалась на другой объект:

		const person = {
		  age: 18,
		};

		const user = {
		  name: 'John',
		};

		user.__proto__ = person;

		console.log(user.age); // 18

		в этом случае user имеет в __proto__ ссылку на объект person вместо ссылки на прототип функции-конструктора. однако person всё равно ссылается через __proto__ на прототип конструктора Object поэтому оба объекта будут иметь доступ к методам: toString, valueOf и т.д.


================================
================================
================================
================================
================================
================================
================================
