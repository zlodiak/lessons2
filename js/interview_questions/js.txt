================================
================================
перечислить типы данных в js

null 
undefined
symbol	// let id = Symbol("id");
bigint	// const bigInt = 1234567890123456789012345678901234567890n;
number
string
boolean
object
+
function (унаследованы от object)

================================
что такое вычисляемое свойство?

это свойство объекта, заданное в квадратных скобках. в качестве имени можно использовать выражение. в частности символьный тип.

================================
что такое свойство-значение и свойство-акцессор?

это функция, которая имеет доступ к свойствам-значениям через this. в остальном оно ведёт себя как функция(геттер/сеттер).
существует возможность задавать их через defineProperty

let user = {
  name: "Steve",
  surname: "Rogers",
get fullName() {
    return `${this.name} ${this.surname}`;
  },
set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }
};
// set fullName is executed with the given value.
user.fullName = "Bruce Wayne";
alert(user.name); // Bruce
alert(user.surname); // Wayne

--------

let user = {
  name: "Steve",
  surname: "Rogers"
};
Object.defineProperty(user, 'fullName', {
  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }  
});
// set fullName is executed with the given value.
user.fullName = "Bruce Wayne";
alert(user.name); // Bruce
alert(user.surname); // Wayne

================================
в чём разница между приммитивным и ссылочным типом?

есть разница при копировании. примитивные типы копируют значения, а ссылочные - ссылки.

let message = "Привет!";
let phrase = message;
message = 'qwerty';
console.log(message, phrase);

let user = { name: "Иван" };
let admin = user; 
user.name = 'sergey';
console.log(user.name, admin.name)

================================
в чём разница между == и ===?

оператор === сранвивает типы и значения.

оператор == сначала приводит операнды к одому типу и только после этого сравнивает значения.

Если оба операнда являются объектами, то JavaScript сравнивает внутренние ссылки, которые равны в том случае, если они ссылаются на один и тот же объект в памяти.
если же один из операндов является примитивом, а другой объектом, то: 
1. объект преобразуется в примитив, 
2. затем они приводятся к одному типу,
3. затем они сравниваются


================================
есть ли в js возможность сделать свойство объекта приватным?

приватные свойства по соглашению начинаются со знака _. но это не синтаксис, а просто соглашение. оно может быть нарушено.

Приватные свойства и методы должны начинаться с #. Они доступны только внутри класса. 

	class CoffeeMachine {
	  #waterLimit = 200;
	  #checkWater(value) {
	    if (value < 0) throw new Error("Отрицательный уровень воды");
	    if (value > this.#waterLimit) throw new Error("Слишком много воды");
	  }
	}

	let coffeeMachine = new CoffeeMachine();

	coffeeMachine.#checkWater(); // Error
	coffeeMachine.#waterLimit = 1000; // Error

this['#name'] не работает. 

================================
Можно ли в js вызвать функцию до ее объявления? Как это работает? 

================================
что делает Object.create()?

// Объект, создаваемый при помощи Object.create(null) не имеет прототипа,
	var data = Object.create(null);
	data.text = "Привет";

================================
как добавить или изменить свойство объекта, не использую точечную нотацию или квадратные скобки?

	const o = {}; // Создаём новый объект
	Object.defineProperty(o, 'a', {
	  value: 37,
	  writable: true,
	  enumerable: true,
	  configurable: true
	});
	// Свойство 'a' существует в объекте o и имеет значение, равное 37

свойство-акцессор можно менять так:

	Object.defineProperty(user, 'fullName', {
	  set fullName(value) {
	    [this.name, this.surname] = value.split(" ");
	  }  
	});

================================
рассказать о клонировании объектов:

1. JSON.parse(JSON.stringify(obj))
глубокая копия. методы не копируются. не работает для циклических объектов.

2. Object.assign
неглубокая копия. методы копируются

3. for (let key in user) {}
неглубокая копия. методы копируются

4. clone = { ...user };
неглубокая копия. методы копируются

5. рекурсивный обход
глубокая рекурсия. методы копируются

	const Y = deepClone(Z);
	function deepClone(obj) {
	  const clObj = {};
	  for(const i in obj) {
	    if (obj[i] instanceof Object) {
	      clObj[i] = deepClone(obj[i]);
	      continue;
	    }
	    clObj[i] = obj[i];
	  }
	  return clObj;
	}
	Y.addnlProp = { fd: 45 };
	console.log('Z object after cloning: ', Z);
	console.log('Y object: ', Y);

6. lodash cloneDeep()

================================
что такое замыкание?

Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ даже после того как внешняя функция отработала. 

понятие замыкания тесно с вязано с понятиями область видимости и лексическое окружение.
на этапе выполнения функции для неё создаётся объект лексического окружения, который содержит:
1. все переменные функции
2. ссылку на лексическое окружение, в котором находится её определение.

далее поиск переменных будет проходить сначала внутри ЛО этой функции, а затем в более внешних ЛО.

рассмотрим пример:

	function outer() {
		const count = 10;
	  
		return function inner() {
			console.log(count);
		}
	}
	const count = 100;
	outer()();		// output: 10

суть примера в том, что ЛО функции outer продолжает жить пока на неё ссылается хоты бы одно внутреннее ЛО. и поэтому функци inner будет искать недостающие переменные в ЛО функции outer

важно понимать, что при каждом запуске одной той же функции создаётся новое ЛО.

--------------------------

В C и большинстве других распространенных языков после возврата функции (оператор return или просто окончание работы) все локальные переменные становятся недоступными, так как фрейм стека уничтожается. В JavaScript они остаются в некотором смысле доступными.

Замыкание — это фрейм стека, который выделяется, когда функция начинает свое работу, и не освобождается после ее возврата

================================
что такое лексическое окружение?

ЛО это объект, который создаётся для: 
1. функции на этапе выполнения, 
2. для блока кода на выполнения(в частности для каждой итерации цикла или блоков тиа if), 
3. для скрипта на этапе выполнения. 

ЛО состоит из переменных функции/блока и из ссылки на внешнее ЛО.

если в результате выполнения программы переменная не найдена в текущем ЛО, то она ищется во внешнем, и т.д.

ЛО не удаляется сборщиком мусора до тех пока пока хотя бы одно внутреннее ЛО имеет ссылку на него.

================================
что такое hoisting?

hoisting это процесс помещения переменных в лексическое окружение на этапе компиляции и присвоение им значений на этапе выполнения. при этом будет получена ошибка, если на этапе компиляции обратиться к let или const. для var значение будет undefined. function declaration и параметры функции будут доступны сразу.

	function f1() {
	  console.log('before', a);	// output: undefined
	  var a = 100;
	  console.log('after', a);	// output: 100
	}
	f1();

	function f2() {
	  console.log('before', a);	// output: ERROR
	  let a = 100;
	  console.log('after', a);	// output: 100
	}
	f2();

классы нужно объявлять именно перед созданием инстанса.

Назначение переменных имеет приоритет перед объявлением функции.
	var double = 22;
	function double(num) {
	  return (num*2);
	}
	console.log(typeof double); // Вывод: number


Объявление функции имеет приоритет перед объявлением переменной.
	var double;
	function double(num) {
	  return (num*2);
	}
	console.log(typeof double); // Вывод: function

================================
что такое контекст выполнения функции?

контекст выполнения это объект, в контексте которого произошёл вызов функции. обычно контекст указывают при вызове так:
contextObj.funcName();
или
funcName.call(contextObj);

важно понимать, что если функция выполнена из глобального уровня, то контекстом будет window или undefined(это зависит от 'strict mode').

важно понимать, что контекст определяется объектом из котрого ВЫПОЛНЕНА функция, а лексическое окружение пределяется функцией, внутри, которой ЗАПИСАНА функция

this.внутри функции указывает на контекст объекта, в котором она была выполнена:

	const obj = {
		a: 10,
		inner: function() {
			console.log('inner', this);
		}
	}

	const outer = function() {
		console.log('outer', this);
	}

	outer();							// window
	obj.inner();						// { a: 10, inner: f }
	inner = obj.inner;
	inner();							// window

================================
что такое IIFE? приведите пример

================================
как можно запретить добавление и удаление свойств объекту?

Object.seal(obj);

================================
как сделать так чтобы свойства объекта стали неизменяемыми и при этом невозможно было ни добавить, ни удалить свойства?

Object.freeze(obj)

================================
что такое Named Function Expression? 

var f = function sayHi(...) { /* тело функции */ };
фцнкция sayHi может вызвать себя изнутри. это может понадобиться при рекурсии.

================================
чем отличаются _proto_ и .prototype?

Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__.

	var animal = {
	  eats: true
	};
	var rabbit = {
	  jumps: true
	};
	rabbit.__proto__ = animal;
	console.log(rabbit.eats)	// true

или 

	var animal = {
	  eats: true
	};
	function Rabbit(name) {
	  this.name = name;
	  this.__proto__ = animal;
	}
	var rabbit = new Rabbit("Кроль");
	console.log( rabbit.eats ); // true

Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.
При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора.

	var animal = {
	  eats: true
	};
	function Rabbit(name) {
	  this.name = name;
	}
	Rabbit.prototype = animal;
	var rabbit = new Rabbit("Кроль"); //  rabbit.__proto__ == animal
	console.log(rabbit.eats)	// true

================================
что такое коллбек? что такое ад коллбеков?

коллбек это функция, которая передаётся аргументом в асинхронную функцию и выполняется когда асинхронная функция получит результат.

с цчётом вышесказанного сам коллбек тоже может быть асинхронным и получать синхронную функцию в виде аргумента. и так до бесконечности. это ад коллбеков.

чтобы избежать неоднозначности принято использовать промисы. промисы позволяют выполнять последующий колбек только  после того как отработает предыдущий. при этом визуально вместо лесенки код выстраивается в цепочки(chaining).
промис может быть в трёх состояниях: успех, провал, ожидание.

Promise.all принимает набор промисов, ждёт пока все они выполнятся и возвращает их результат в виде массива.

вместо промисов можно использовать конструкицию async/await

================================
что такое промис?

это обёртка над асинхронной функцией(executor) и коллбеком. в зависимости от результата выполнения асинхронной функции выполняется один из коллбеков.

let promise = new Promise(function(resolve, reject) {
  // эта функция(executor) выполнится автоматически, при вызове new Promise
  setTimeout(() => resolve("done"), 1000);
});

фактически коллбеки выносятся в then, resolve, reject являются всего лишь посредиками:
promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);

если блоки then возвращают значения, то их можно объединять в цепочки.

================================
что такое async/await?

если перед функцией стоит async, то она вернёт промис.

	async function f() {
	  return 1;
	}
	f().then(alert); // 1

внутри такой функции можно использовать await, который остановит ход выполнения ВНУТРИ async функции и будет ждать выполнения асинхронной операции.
при этом ход выполнения ВНЕ async функции будет идти без задержки.

	async function f() {
	  let promise = new Promise((resolve, reject) => {
	    setTimeout(() => resolve("готово!"), 1000)
	  });

	  let result = await promise; // будет ждать, пока промис не выполнится (*)
	  alert(result); // "готово!"
	}
	f();

для отлова ошибко используется блок try/catch

================================
упорядочены ли ключи в объекте?

если ключи могут быть преобразованы к числу, то упорядочены. в ином случае - нет

================================
чем отличается постфиксный инкремент от префиксного?

постфиксный выполняется поле приравнивания:

	let i = 0;
	let s = i++		// s = 0

	let i = 0;
	let s = ++i		// s = 1	

================================
как js-классу назначить свойства без использования конструктора?

	class MyClass {
	  a = 1;
	  b = 2;
	  c = 3;
	}

	const m = new MyClass();
	console.log(m.b);

================================
в чём разница между Object.assign() и spread-оператором?

spread-оператор всегда создаёт новый объект, а Object.assign лишь мутирует существующий. поэтому в случае со spread-оператором происходит перезапись объекта по ссылке.

	const a = { name: 'Joe Bloggs' }
	const b = { ...a, age: 27 };
	console.log(a === b) //=> false

	const a = { name: 'Joe Bloggs' }
	const b = Object.assign(a, { age: 27 });
	console.log(a === b) //=> true

================================
что такое event-loop? как он работает?

эвент луп(ЭЛ) это цикл, который обрабатывает поступающие в него задачи. задачи могут быть синхронными и асинхронными(событиями). синхронные заполняют стек, а асинхронные попадают в очередь. еслик задаче не привязан обработчик, то она не обрабатвается циклом событий. куча это неструктурированная память, в которой хранятся объявления.

когда функция начинает выполнение, то создаётся контекст выполнения. он помещается в стек. если эта функция вызывает другую функцию, то в стек попадает ещё один контекст. таким образом по мере выполнения синхронных задач стек разгружается.

когда в стеке нет задач, то выполняются асинхронные задачи из очереди. setTimeout помещает задачу в очередь по прошествиие времени, указанного во втором аргументе.

любое событие, например клик, помещается в очередь асинхронных событий(если на клик повешен обработчик, конечно же).

важно понимать, что очерель событий начинает работать только после того как весь код основного скрипта выполнился и поэтому js-движок перешёл в режим ожидания.

очередь асинхронных событий состоит из микроадач(приоритетных) и макрозадач (не приоритетных). микрозадачи это промисы и события, макрозадачи это setTimeout. существует возможность принудительно микромизировать задачу при помощи queuMicrotask(f).

================================
что такое модуль?

если подключить скрипт в станицу, то может произойти так, что переменные скрипта заместят переменные страницы(если у них одинаковые названия). чтобы этого не произошло код скрипта помещется в отдельную область видимости. переменные из этой области видимости экспортируеются при помощи return

	var lodash = (function() {

	  var version;
	  function assignDefaults() { ... }

	  return {
	    defaults: function() {  }
	  }

	})();

с момента появления es6 стало возможным использовать модули при помощи import/export

в ES6 модуль это отдельеый файл. но также возможно использовать специальную конструкцию:

    module {  // анонимный внутренний модуль
        let tmp = …;  // не станет глобальной
    }

================================
что такое строгий режим?

СР влюучается в скрипте или функции. перед его объявлением не должно быть кода.

СР делает не прощает некоторые неоднозначности в js. например, не разрешает присвоить значение необъявленной переменной(будет ошибка). не разрешает перечилять в объекте свойства с одинаковыми именами. не разрешает использовать некоторые служебные слова, которые зарезервированя для будущего стандарта ES: private, yeld, interface etc.

================================
что такое webassembly?

это бинарный формат, который позволяет браузеру выполнять js быстрее. это не язык программирования, а просто виртуальная машина.

перед разработчиками wasm стоит ряд задач, связанных с безопасностью, кроссплатформенностью и отсустствием потребности использовать что-то кроме браузера. поэтому разработка wasm затянулась.

================================
что такое try/catch/finally?

это блоки для обработки исключений. каждое исключение должно быть  однозначно идентифицировано.ю если этого не произошло, то происходит проброс исключения. это техника, при которой неопознанное исключение из блока catch при помощи throw отправляется во внешний блок try/catch/finally

================================
что такое всплыте/погружение событий в DOM?

в DOM элементы имеют вложенную структуру. при клике на один из внутренних элементов происходит погружение события, а потом всплытие. обработчики работают только со стадией всплытия, но это можно изменить припомощи третьего аргумента addEventListener()

всплытие события можно пректатить на любом уровне при помощи e.stopPropagation(). 

если меню состоит из 10 пунктов, то не обязательно отлавливать клик на каждом из ни. достаточно назначить обработчик внешнему блоку. это называется делегирование событий.

================================
что такое spread и rest операторы?

spread позволяет разобрать перечислимый объект. например можно клонировать массив. или в вызове функции использовать один аргумент, в теле функции он будет разбит на несколько:

	var log = function(a, b, c) {
	  console.log(a, b, c);
	};
	log(...['Spread', 'Rest', 'Operator']);

rest делает обратное. например при помощи него функция может принять один rest-аргумет, но внутри функци разбить его на несколько. при этом отпадает надобность в arguments

	var log = function(a, b, ...rest) {
	  console.log(a, b, rest);
	};

	log('Basic', 'rest', 'operator', 'usage'); // Basic rest ['operator', 'usage']

================================
что такое Деструктурирующее присваивание?

это способ при помощи присвоить отдельным переменным каждое значение из итерируемого объекта.

	let myArray = [1,2,3];
	let [a, b, c] = myArray;
	console.log(a); // 1
	console.log(b); // 2
	console.log(c); // 3

для объекта:

	let myObject = { a: 1, b: 2, c: 3, d: 4};
	let {b, d} = myObject;
	console.log(b); // 2
	console.log(d); // 4

================================
что такое иммутабельность?

это объект, который после инициализации невозможно изменить. результатом любой модификации будет новый объект.

================================
что такое каррирование?

это преобразование функции, которая принимает несколько аргументов к набору функций, каждая из которых принимает по одному аргументу

	function curry(func) {
	  return function curried(...args) {
	    if (args.length >= func.length) {
	    	console.log('first', this)
	      return func.apply(this, args);
	    } else {
	    	console.log('second')
	      return function(...args2) {
	        return curried.apply(this, args.concat(args2));
	      }
	    }
	  };
	}

	function sum(a, b, c) {
	  return a + b + c;
	}
	let curriedSum = curry(sum);
	console.log( curriedSum(1)(2)(3) );

================================
что такое утиная типизация?

это проверка того, что объект реализует определённый интерфейс. при этом он может дополнительно иметь другие методы и свойства.

	def method(obj):
	   obj.start()
При утиной типизации мы не заботимся о типе объекта obj, нам лишь важно, что у него есть метод start. Если же такого метода нет, то исключение нас разочарует.

================================
что такое defer и async?

в процессе загрузки страницы может получиться так, что подключенный скрипт блокирует отрисовку html. чтобы решить эту проблему в элемент скрипта можно добавить атрибут defer. в этом случае скрипты начнут загружаться в фоновом режиме, а запустятся только после того как html отрисован(событие DOMContentLoaded)

также можно пометить скрипт атрибутом async. в этом случае скрипты загружаются в фоновом режиме. порядок не сохраняется. запускаться они будут по мере загрузки.

================================
что такое fetch?

fetch это ещё один способ сделать асинхронный запрос. в ответ приходит промис. таким образом запрос выглядит так:

	fetch('https://api...')
	  .then(response => response.json())

есть возможность отправлять и получать заголовки:

	fetch('https://api...', {
	  headers: {
	    Authentication: 'secret'
	  }
	})
	.then(response => response.headers.get('Content-Type'))

пример post-запроса:

	fetch('https://api...', {
	  method: 'POST',
	  headers: {
	    'Content-Type': 'application/json;charset=utf-8'
	  },
	  body: JSON.stringify(user)
	});

================================
что такое web sockets?

WS это протокол, позволяющий браузеру и серверу поддерживать постоянное соединение. так же как в случае XHR создаётся объект вебсокета, инициализируется адресом и затем слушаются коллбеки.

================================
что такое класс?

класс это новая языковая конструкция, которая появилась в ES6. внутри класс представляет из себя функцию, тело которой состоит из конструктора класса. методы класса сохраняются в prototype. оператор new создаёт объект из конструктора класса с методами из прототипа.

	class User {
	  constructor(name) { this.name = name; }
	  sayHi() { alert(this.name); }
	}

	let user = new User("Иван");
	user.sayHi();	

это то же самое, что и:

	function User(name) {
	  this.name = name;
	}

	User.prototype.sayHi = function() {
	  alert(this.name);
	};

	let user = new User("Иван");
	user.sayHi();

================================
что такое функция? рассказать о this в функции.

функция это конструкция языка. с помощью неё можно создавать переиспользуемые куски кода. функцию можно использовать как конструктор для создания объекта. функцию можно запускать в определённом контексте.

	function User(name) {
	  this.name = name;
	}

	User.prototype.Say = function() {
	  console.log('sss', this.name)
	}

	const f1 = new User('sergey');

	console.log(f1, typeof f1, User.prototype)
	f1.Say()

в примере выше будет создан объект со свойством name и методом Say()

можно функцию f1 запустить в другом контексте:

	const f2 = f1.Say;
	f2.call({name: 'misha'})	

this функции всегда будет браться из контекста.

================================
что такое стрелочная функция?

СФ это краткая запись функции. она не имеет arguments. она не имеет имени. не может быть вызвана с new.
она не имеет собственного контекста выполнения(собственного this). то есть не важно какой объект при вызове ставить перед точкой или в аргументе call(), всё равно она будет иметь брать this из лексического окружения.

	const obj = {
	  a: 10,
	  inner: () => {
	    console.log('inner', this);
	  }
	}

	obj.inner();					// window
	const f = obj.inner;
	f.call({a: 100});				// window

то же самое для обычной функции:

	const obj = {
	  a: 10,
	  inner: function() {
	    console.log('inner', this);
	  }
	}
  	obj.inner();	// { a: 10, inner: f }

не иметь собственного this значить не иметь собственного контекста.

this функции всегда будет браться извне.

================================
что такое область видимости?

Область видимости определяет доступность переменных. существует глобальная область видимости и локальная.

глобально объявленная переменная доступна из любых функций и блоков. переменные, которые объявлены в функциях и блоках недоступны извне. важно понимать, что если переменная не найдена в текущей области видимости, то она ищется во внешней и т.д.


================================
что такое NaN?

NaN или Not A Number (не число) — это значение, получаемое в результате выполнения числовой операции над нечисловым значением

================================
Как определить наличие свойства в объекте?

	console.log('prop' in o) 

	o.hasOwnProperty('prop2')

	console.log(o['prop'])

================================
Как в JS создать объект?

	Объектный литерал:

	Функция-конструктор:

	Object.create:

================================
В чем разница между оператором «in» и методом hasOwnProperty?

оператор «in» проверяет наличие свойства не только в самом объекте, но и в его прототипах, а метод hasOwnProperty — только в объекте.

================================
Почему 0.1 + 0.2 === 0.3 — это false?

все числа в языке (даже целые) представлены в формате с плавающей запятой (float). эти числа — бесконечные дроби. Для их хранения выделяется ограниченный объем памяти, поэтому возникают подобные неточности.

================================
что такое транспилер и полифилл?

Транспайлер - переписывает новый синтаксис языка в старый.

	// объявление переменных в новом стиле
	const a = `константа`;
	let b = `изменяемая переменная`;

	// приводит к объявлению в старом стиле
	var a = `константа`;
	var b = `изменяемая переменная`;

Полифилл - реализовывает функции из новой версии языка, которых нет в старой

	// проверка является ли arr массивом в новом варианте
	if (Array.isArray(arr) === true) alert('массив!');

	// проверка является ли arr массивом в старом варианте

	// Полифилл функции из "новой" версии для старой "версии" языка
	// (для примера здесь, пропишем прямо в прототип Array)
	Array.__proto__.isArray = function(value) {
	return value instanceof Array;
	};

	if (Array.isArray(arr) === true) alert('массив!');

================================
внедрение зависимостей — это метод, с помощью которого объект получает другие объекты, от которых он зависит, называемые зависимостями, а не создает их сам.

то есть вместо композиции используется более абстрактный подход:

	import { Engine } from './Engine';

	class Car {
	    private engine: Engine;

	    public constructor (engine: Engine) {
	        this.engine = engine;
	    }
	    
	    public startEngine(): void {
	        this.engine.fireCylinders();
	    }
	}



dependency injection делится на 3 вида:

1. constructor injection. в этом случае зависимость передаётся через конструктор класса и далее присваивается свойству класса

class A:
	def __init__(self, logger):
		self.logger = logger

2. method injection. в этом случае зависимость передаётся через метод класса и в большинстве случаев на присваивается свойству класса, но присваивается локальной переменной метода

class A:
	def set_logger(self, logger):
		logger_obj = logger
		logger_obj.write('blabla')

3. property injection. в этом случае зависимость приравнивается свойству объекта

a = A()
a.prop = B()

================================
new Map()

это аналог объекта, но ключаси могут быть любые типы. при итерации порядок ключей сохраняется
в new WeakMap() ключами могут быть только объекты


new Set()

это аналог массива, но все значения уникальны.
в new WeakSet элементами коллекции могут быть только объекты



================================
localStorage одно хранилище для всех вкладок. не очищается после закрытия вкладок или браузера.

sessionStorage хранилище для отдельной вкладки. не очищается после рефреша. очищается после закрытия вкладки или браузера.

================================
отсутствие собственного this у стрелочной функции

обычная функция имеет тот контекст(this), из которого она запускается. а отсутствующие переменные ищутся по цепочке родительских объектов.
у стрелочной функцииы и отсутствующие переменные, и контекст(this) ищутся по цепочке ролительских объектов.

пример потери контекста. потому что функция фактически вызывается с глобальным контекстом windeow.growUp. при этом у window нет age.

	function Person() {
	  // В конструкторе Person() `this` указывает на себя.
	  this.age = 0;

	  setInterval(function growUp() {
	    // В нестрогом режиме, в функции growUp() `this` указывает
	    // на глобальный объект, который отличается от `this`,
	    // определяемом в конструкторе Person().
	    this.age++;
	  }, 1000);
	}

	var p = new Person();


проблему можно решить, запомнив this в переменную:

	function Person() {
	  var that = this;
	  that.age = 0;

	  setInterval(function growUp() {
	    // Функция с обратным вызовом(callback) содержит переменную that, которая
	    // ссылается на требуемый объект this.
	    that.age++;
	  }, 1000);
	}


или проблему можно решить просто используя стрелочную функцию

	function Person(){
	  this.age = 0;

	  setInterval(() => {
	    this.age++; // `this` указывает на объект Person
	  }, 1000);
	}

	var p = new Person();

================================
пример потери контекста функции:

this.x = 9;
var module = {
  x: 81,
  getX: function() { return this.x; }
};

module.getX(); // 81

var getX = module.getX;
getX(); // 9, поскольку в этом случае this ссылается на глобальный объект

// создаём новую функцию с this, привязанным к module
var boundGetX = getX.bind(module);
boundGetX(); // 81

================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
