================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
измерение производительности:

	var t0 = performance.now();
	doSomething();
	var t1 = performance.now();
	console.log("Call to doSomething took " + (t1 - t0) + " milliseconds.");


	можно измерять производительность:

		1. поставить перед блоком синхронного кода и после блка синхронного кода метки на основе data и в конце скрипта получить разницу вычитанием.

			const a = new Date().getTime();
			const arr = [1, 2, 3]
			const arr2 = arr.map(d => d * 10000000000);
			const b = new Date().getTime();
			console.log(b, a , b - a);	// 1730589406665 1730589406664 1

			можно сделать то же самое, но при помощи performance api:

				метод performance.now() вернет текущее время в миллисекундах:

					const firstNow = performance.now()
					// This loop is just to simulate slow calculations
					for (let i = 0; i < 100000; i++){
					  var ii = Math.sqrt(i)
					}
					const secondNow = performance.now()

					const howLongDidOurLoopTake = secondNow - firstNow				



		2. применить тот же самый подход, но использовать performance api, то есть набор статических методов, которые есть в объекте window.performance:

			Метод mark позволяет разместить маркер времени.

				performance.mark('start');

			Метод measure позволяет измерить разницу во времени между двумя маркерами.

				async function timeDuration() {
				    performance.mark('start');
				    await new Promise(resolve => setTimeout(resolve, 100))
				    performance.mark('end');
				  
				    return performance.measure('time', 'start', 'end').duration;
				  }
				  
				  timeDuration().then((result) => console.log(result));		
				  
			Метод getEntriesByType позволяет получить доступ ко всем созданным объектам определённого типа	

			Методы clearMarks/clearMeasures используются для удаления ранее добавленных маркеров и измерителей из кеша браузера	


			полный пример:

				performance.mark('start');
				performance.mark('end');
				performance.measure('time_duration', 'start', 'end');

				console.log(performance.getEntriesByType('mark').length);
				// output: 2
				console.log(performance.getEntriesByType('measure').length);
				// output: 1

				performance.clearMarks();
				performance.clearMeasures();
				console.log(performance.getEntriesByType('mark').length);
				// output: 0
				console.log(performance.getEntriesByType('measure').length);
				// output: 0		
				

		3. использовать инструменты разработчика в хроме:	

			network:

				предоставляет водопад для каждого ресурса и время загрузки этого ресурса. 

				даёт возможность отключить кеширование

			Performance Insights:

				анализирует страницу и предоставляет подробный водопад, на котром показаны:

					dom content loaded

					время отрисовки первого элемента контента

					время отрисовку крупнейшего элемента контента

					время доступности интерактивных элементов

			Performance

				даёт созвомжность посмотреть внешний вид страницы на любой метке времени

				выводит время каждого этапа:

					загрузка

					загрузка скриптов

					отрисовка страницы

					раскрашивание

					и т.д.

			lighthouse:

				устанавливает может ли сайт работать офлайн

				скорсоть загрузки оценивает

				проверяет безопасность. например есть ли https

				оценивает качество SEO





================================
оператор ??

	действует почти как || , но не учитывает true/false, а учитывает только null, undefined

	при этом || тоже учитывает null, undefined

		const response = {
		    enableAudio: 0
		}

		const enableAudio = response.enableAudio || 1;
		enableAudio
		// 1	

		---

		const response = {
		    enableAudio: 0
		}

		const enableAudio = response.enableAudio ?? 1;
		enableAudio
		// 0

================================
тип bigint

	создать можно двумя способами:

		1. через конструктор BigInt
		2. добавить в кноце цифры символ n

	не разрешается в операциях смешивать обычные числа и bigint-числа. но операции сравнения работают корректно.

	не разрешается использовать унарный оператор + для преобразования строки в число

================================
эмуляция клика по html с использованием координат

	let clickEvent = new MouseEvent("click", {
	    bubbles: true,
	    cancelable: true,
	    clientX: track.width.baseVal.value - thumb.width.baseVal.value,
	    clientY: 0
	});
	track.dispatchEvent(clickEvent)

	тут больше: https://www.javascripttutorial.net/javascript-dom/javascript-dispatchevent/

эмуляция клика по элементу:

	let btn = document.querySelector('.btn');

	 btn.addEventListener('click', function () {
	        alert('Mouse Clicked');
	 });

	let clickEvent = new Event('click');
	btn.dispatchEvent(clickEvent);

================================
чтобы приложение было интерактивным необходимо чтобы браузер посылал события, а разработчик своим кодом улавливал их. 

например, если на элемент DOM пользователь кликнул, то программист может подписаться на событие клика и обработать его при помощи коллбека.

подписаться можно двумя способами:

	1. on-свойства элементов 

		onclick,
		onmouseenter,
		onscroll

		buttonElement.onclick = function() {
		  squareDiv.style = `background-color: ${getColor()};`
		}		

	2. addEventListener()

		buttonElement.addEventListener('click', function() {
		  squareDiv.style = `background-color: ${getColor()};`
		})	


	второй способ рпедпочтительнее потому что можно на один элемент повесить несколько событий.

================================
перечислить типы данных в js

null 
undefined
symbol	// let id = Symbol("id");
bigint	// const bigInt = 1234567890123456789012345678901234567890n;
number
string
boolean
object
+
function (унаследованы от object)

================================
что такое вычисляемое свойство?

это свойство объекта, заданное в квадратных скобках. в качестве имени можно использовать выражение. в частности символьный тип.

например у каждого итерируемого объекта есть вычисляемое свойство [Symbol.iterator], оно ссылается на итератор. этот итератор через this перебирает итерируемый объект в цикле, пиная next()

================================
в чём разница между == и ===?

	оператор === сранвивает типы и значения.

	оператор == сначала приводит операнды к одому типу и только после этого сравнивает значения.

	Если оба операнда являются объектами, то JavaScript сравнивает внутренние ссылки, которые равны в том случае, если они ссылаются на один и тот же объект в памяти.
	если же один из операндов является примитивом, а другой объектом, то: 
	1. объект преобразуется в примитив, 
	2. затем они приводятся к одному типу,
	3. затем они сравниваются


================================
есть ли в js возможность сделать свойство объекта приватным?

	приватные свойства по соглашению начинаются со знака _. но это не синтаксис, а просто соглашение. оно может быть нарушено.

	Приватные свойства и методы должны начинаться с #. Они доступны только внутри класса. 

		class CoffeeMachine {
		  #waterLimit = 200;
		  #checkWater(value) {
		    if (value < 0) throw new Error("Отрицательный уровень воды");
		    if (value > this.#waterLimit) throw new Error("Слишком много воды");
		  }
		}

		let coffeeMachine = new CoffeeMachine();

		coffeeMachine.#checkWater(); // Error
		coffeeMachine.#waterLimit = 1000; // Error

	this['#name'] не работает. 

================================
что делает Object.create()?

	создаёт объект с определённым в аргументе прототипом

	// Объект, создаваемый при помощи Object.create(null) не имеет прототипа,
		var data = Object.create(null);
		data.text = "Привет";

================================
как добавить или изменить свойство объекта, не использую точечную нотацию или квадратные скобки?

	const o = {}; // Создаём новый объект
	Object.defineProperty(o, 'a', {
	  value: 37,
	  writable: true,
	  enumerable: true,
	  configurable: true
	});
	// Свойство 'a' существует в o и имеет значение, равное 37

свойство-акцессор можно менять так:

	Object.defineProperty(user, 'fullName', {
	  set fullName(value) {
	    [this.name, this.surname] = value.split(" ");
	  }  
	});


================================
что такое Named Function Expression? 

	var f = function sayHi(...) { /* тело функции */ };
	фцнкция sayHi может вызвать себя изнутри. это может понадобиться при рекурсии.

	sayHi() можно вызвать изнутри sayHi(). то эе самое можно сделать и с f(). но f() доступна внешнему коду для переименования, а sayHi() нет.

		let sayHi = function(who) {
		  if (who) {
		    alert(`Hello, ${who}`);
		  } else {
		    sayHi("Guest"); // Ошибка: sayHi не является функцией
		  }
		};

		let welcome = sayHi;
		sayHi = null;

		welcome(); // Ошибка, вложенный вызов sayHi больше не работает!	

================================
упорядочены ли ключи в объекте?

	если ключи могут быть преобразованы к числу, то упорядочены. в ином случае - нет

================================
чем отличается постфиксный инкремент от префиксного?

	постфиксный выполняется после приравнивания:

		let i = 0;
		let s = i++		// s = 0

		let i = 0;
		let s = ++i		// s = 1	

	------------

	также будут различаться операции добавления элементав массив:

	arr.push(i++)

	и

	arr.push(++i)

================================
как js-классу назначить свойства без использования конструктора?

	class MyClass {
	  a = 1;
	  b = 2;
	  c = 3;
	}

	const m = new MyClass();
	console.log(m.b);

================================
в чём разница между Object.assign() и spread-оператором?

spread-оператор всегда создаёт новый объект, а Object.assign лишь мутирует существующий. поэтому в случае со spread-оператором происходит перезапись объекта по ссылке.

	const a = { name: 'Joe Bloggs' }
	const b = { ...a, age: 27 };
	console.log(a === b) //=> false

	const a = { name: 'Joe Bloggs' }
	const b = Object.assign(a, { age: 27 });
	console.log(a === b) //=> true

	но

	const a = { name: 'Joe Bloggs' };
	const b = Object.assign({}, a, { age: 27 });
	console.log(a === b); //=> flase

================================
что такое модуль?

	если подключить скрипт в страницу, то может произойти так, что переменные скрипта заместят переменные страницы(если у них одинаковые названия). чтобы этого не произошло код скрипта помещется в отдельную область видимости. переменные из этой области видимости экспортируеются при помощи return

		var lodash = (function() {

		  var version;
		  function assignDefaults() { ... }

		  return {
		    defaults: function() {  }
		  }

		})();

	с момента появления es6 стало возможным использовать модули при помощи import/export

	в ES6 модуль это отдельеый файл. но также возможно использовать специальную конструкцию:

	    module {  // анонимный внутренний модуль
	        let tmp = …;  // не станет глобальной
	    }

================================
что такое строгий режим?

	СР вклюучается в скрипте или функции. перед его объявлением не должно быть кода.

	СР не прощает некоторые неоднозначности в js. например, не разрешает присвоить значение необъявленной переменной(будет ошибка). не разрешает перечилять в объекте свойства с одинаковыми именами. не разрешает использовать некоторые служебные слова, которые зарезервированы для будущего стандарта ES: private, yield, interface etc. не разрешает передавать в функцию аргументы с одинаковыми именами

================================
что такое webassembly?

	это бинарный формат, который позволяет браузеру выполнять js быстрее. это не язык программирования, а просто виртуальная машина.

	перед разработчиками wasm стоит ряд задач, связанных с безопасностью, кроссплатформенностью и отсустствием потребности использовать что-то кроме браузера. поэтому разработка wasm затянулась.

================================
что такое try/catch/finally?

	это блоки для обработки исключений. каждое исключение должно быть  однозначно идентифицировано. если этого не произошло, то происходит проброс исключения. это техника, при которой неопознанное исключение из блока catch при помощи throw отправляется во внешний блок try/catch/finally

	Хорошей практикой считается обрабатывать в модуле только те ошибки, которые связаны непосредственно с ним, а все остальные пробрасывать дальше.

		try {
			// some code
		} catch (e) {
		  if (e.name == "SyntaxError") { // exception identification
		    alert( "Извините, в данных ошибка" );
		  } else {
		    throw e;
		    //  throw new Error({})
		  }
		}	

	finally выполняется в любом случае.

	catch не отловит асинхронное событие. например такое:

		try {
		  setTimeout(function() {
		    noSuchVariable; // скрипт упадёт тут
		  }, 1000);
		} catch (e) {
		  alert( "не сработает" );
		}	

		здесь объект ошибки e имеет два обязательных свойства: name, message


================================
что такое всплыте/погружение событий в DOM?

	в DOM элементы имеют вложенную структуру. при клике на один из внутренних элементов происходит погружение события, а потом всплытие. обработчики работают только со стадией всплытия, 

		addEventListener("click", highlightThis); // по умолчанию третий аргумент = false

	но это можно изменить припомощи третьего аргумента addEventListener():

		addEventListener("click", highlightThis, true);

	всплытие события можно пректатить на любом уровне при помощи e.stopPropagation():

		<style>
		  div {
		    padding: 50px;
		    background-color: rgba(255, 0, 0, 0.2);
		  }
		</style>

		<div id="d3">
		  DIV3
		  <div id="d2">
		    DIV 2
		    <div id="d1">DIV 1</div>
		  </div>
		</div>

		<script>
		  const el1 = document.getElementById('d1');
		  const el2 = document.getElementById('d2');
		  const el3 = document.getElementById('d3');

		  el1.addEventListener('click', (e) => {
		    console.log('div1 was clicked'); // display
		  });

		  el2.addEventListener('click', (e) => {
		    e.stopPropagation();
		    console.log('div2 was clicked'); // display
		  });

		  el3.addEventListener('click', (e) => {
		    console.log('div3 was clicked'); // NOT display
		  });
		</script>

	если меню состоит из 10 пунктов, то не обязательно отлавливать клик на каждом из них. достаточно назначить обработчик внешнему блоку. это называется делегирование событий.
	
	event.target указывает на элемент, на котром первоначально произошло событие.

================================
что такое каррирование?

	это преобразование функции, которая принимает несколько аргументов к набору функций, каждая из которых принимает по одному аргументу

		function curry(func) {
		  return function curried(...args) {
		    if (args.length >= func.length) {
		    	console.log('first', this)
		      return func.apply(this, args);
		    } else {
		    	console.log('second')
		      return function(...args2) {
		        return curried.apply(this, args.concat(args2));
		      }
		    }
		  };
		}

		function sum(a, b, c) {
		  return a + b + c;
		}
		let curriedSum = curry(sum);
		console.log( curriedSum(1)(2)(3) );

================================
что такое утиная типизация?

	это проверка того, что объект реализует определённый интерфейс. при этом он может дополнительно иметь другие методы и свойства.

		def method(obj):
		   obj.start()
		   
	При утиной типизации мы не заботимся о типе объекта obj, нам лишь важно, что у него есть метод start. Если же такого метода нет, то выбрасывается исключение.

================================
что такое defer и async?

	в процессе загрузки страницы может получиться так, что подключенный скрипт блокирует отрисовку html. чтобы решить эту проблему в элемент скрипта можно добавить атрибут defer. в этом случае скрипты начнут загружаться в фоновом режиме, а запустятся только после того как html будет сформирован, НО до события DOMContentLoaded. при этом запускаться они будут в последовательности подключения.

	также можно пометить скрипт атрибутом async. в этом случае скрипты загружаются в фоновом режиме. порядок не сохраняется. запускаться они будут по мере загрузки.

	На практике defer используется для скриптов, которым требуется доступ ко всему DOM-дереву или если важен их порядок выполнения.

	А async хорош для независимых скриптов, например счётчиков и рекламы, порядок выполнения которых не играет роли.

================================
что такое fetch?

	это часть веб апи браузера.
	fetch это ещё один способ сделать асинхронный запрос. в ответ приходит промис. таким образом запрос выглядит так:

		fetch('https://api...')
		  .then(response => response.json())

	есть возможность отправлять и получать заголовки:

		fetch('https://api...', {
		  headers: {
		    Authentication: 'secret'
		  }
		})
		.then(response => response.headers.get('Content-Type'))

	пример post-запроса:

		fetch('https://api...', {
		  method: 'POST',
		  headers: {
		    'Content-Type': 'application/json;charset=utf-8'
		  },
		  body: JSON.stringify(user)
		});


================================
Как определить наличие свойства в объекте?

	o.hasOwnProperty('prop2')	// этот метод НЕ проверяет существование свойств в цепочке прототипов объекта.

	console.log('prop' in o) // а этот проверяет

	console.log(o[prop]) // а этот проверяет


================================
В чем разница между оператором «in» и методом hasOwnProperty?

	оператор «in» проверяет наличие свойства не только в самом объекте, но и в его прототипах, а метод hasOwnProperty — только в объекте.

================================
Почему 0.1 + 0.2 === 0.3 — это false?

	все числа в языке (даже целые) представлены в формате с плавающей запятой (float). эти числа — бесконечные дроби. Для их хранения выделяется ограниченный объем памяти, поэтому возникают подобные неточности.

================================
что такое транспилер и полифилл?

	Транспайлер - переписывает новый синтаксис языка в старый.

		// объявление переменных в новом стиле
		const a = `константа`;
		let b = `изменяемая переменная`;

		// приводит к объявлению в старом стиле
		var a = `константа`;
		var b = `изменяемая переменная`;

	Полифилл - реализовывает функции из новой версии языка, которых нет в старой

		// проверка является ли arr массивом в новом варианте
		if (Array.isArray(arr) === true) alert('массив!');

		// проверка является ли arr массивом в старом варианте

		// Полифилл функции из "новой" версии для старой "версии" языка
		// (для примера здесь, пропишем прямо в прототип Array)
		Array.__proto__.isArray = function(value) {
		return value instanceof Array;
		};

		if (Array.isArray(arr) === true) alert('массив!');

================================
внедрение зависимостей — это способ, с помощью которого объект получает другие объекты, от которых он зависит, называемые зависимостями, а не создает их сам.

	то есть вместо композиции используется более абстрактный подход:

		import { Engine } from './Engine';

		class Car {
		    private engine: Engine;

		    public constructor (engine: Engine) {
		        this.engine = engine;
		    }
		    
		    public startEngine(): void {
		        this.engine.fireCylinders();
		    }
		}



	dependency injection делится на 3 вида:

	1. constructor injection. в этом случае зависимость передаётся через конструктор класса и далее присваивается свойству класса

	class A:
		def __init__(self, logger):
			self.logger = logger

	2. method injection. в этом случае зависимость передаётся через метод класса и в большинстве случаев не присваивается свойству класса, но присваивается локальной переменной метода

	class A:
		def set_logger(self, logger):
			logger_obj = logger
			logger_obj.write('blabla')

	3. property injection. в этом случае зависимость приравнивается свойству объекта

		a = A()
		a.prop = B()

================================
new Map()

	это аналог объекта, но ключами могут быть любые типы. при итерации порядок ключей сохраняется
	в new WeakMap() ключами могут быть только объекты и сборщик мусора удаляет WeakMap даже если в нём есть элемент


new Set()

	это аналог массива, но все значения уникальны.
	в new WeakSet элементами коллекции могут быть только объекты и сборщик мусора удаляет WeakSet даже если в нём есть элемент



================================
localStorage 

	одно хранилище для всех вкладок. не очищается после закрытия вкладок или браузера. Максимальный объем данных ограничен размером 5MB. принадлежит объекту window

	Хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга.

	При установке значения в хранилище срабатывает глобальное событие storage, с помощью которого можно отслеживать изменения в хранилище:

		window.addEventListener('storage', function (evt) {
		  console.log(evt)
		})

		Событие содержит свойства:

			key — ключ, который был изменён (при вызове метода clear() ключ будет null);
			oldValue — старое значение, записанное в поле;
			newValue — новое значение, записанное в поле;
			url — адрес страницы, на которой вызвано изменение.

		 событие срабатывает на всех остальных объектах window, где доступно хранилище, кроме того окна, которое его вызвало.



sessionStorage 

	хранилище для отдельной вкладки (Другая вкладка с той же страницей будет иметь другое хранилище.). не очищается после рефреша. очищается после закрытия вкладки или браузера. Максимальный объем данных ограничен размером 5MB.
	принадлежит объекту window

================================
пример потери контекста функции:

	this.x = 9;
	var module = {
	  x: 81,
	  getX: function() { return this.x; }
	};

	module.getX(); // 81

	var getX = module.getX;
	getX(); // 9, поскольку в этом случае this ссылается на глобальный объект

	// создаём новую функцию с this, привязанным к module
	var boundGetX = getX.bind(module);
	boundGetX(); // 81


=================
что такое async-await?

	это синтаксический сахар для промисов. конструкция async-await работает как генератор, то есть останавливает свою работу, передаёт выполнение далее по потоку и затем снова получает возможность продолжить.

		const f = async function () {
		  console.log(2);
		  const value = await Promise.resolve('value');
		  console.log(value);
		  console.log(4);
		};

		console.log(1);
		f();
		console.log(3);

		// вывод в консоль: 1 2 3 value 4 

	отлов ошибок делается при помощи try/catch

		const f = async function () {
		  console.log(2);
		  try {
		    const value = await Promise.resolve('value');
		    console.log(value);
		    console.log(4);
		  } catch (error) {Другая вкладка с той же страницей будет иметь другое хранилище.
		    console.log('error', error);
		  }
		};

		console.log(1);
		f();
		console.log(3);

		// вывод в консоль: 1 2 3 value 4 

	на async-функцию можно подписаться при помощи then:

		const f = async function () {
		  console.log(2);
		  return await Promise.resolve('value');
		  console.log(4);
		};

		console.log(1);
		f().then(
		  (s) => console.log('s', s),
		  (e) => console.log('e', e)
		);
		console.log(3);	

		// вывод в консоль 1 2 3 s value

=================
пример потери контекста

	this определяется в момент вызова функции. Если записать метод объекта в переменную и вызвать её, значение this изменится.

		const user = {
		  name: 'Alex',
		  greet() {
		    console.log(`Hello, my name is ${this.name}`)
		  },
		}

		const greet = user.greet
		greet()

		// Hello, my name is

	тот же код в строгом режиме выдаст ошибку потому что у undefined нет свойства name
  
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
популярные вопросы
===============================
примитивные и ссылочные типы данных

	объект это ссылочный тип данных. он хранится и сравнивается по ссылке, которая ведёт на место в памяти.

	остальные типы это примитивные типы. они хранятся и копируются по значению.

----
в чём разница между приммитивным и ссылочным типом?

	есть разница при копировании. примитивные типы копируют значения, а ссылочные - ссылки.

	let message = "Привет!";
	let phrase = message;
	message = 'qwerty';
	console.log(message, phrase);	// 'qwerty' 'Привет'

	let user = { name: "Иван" };
	let admin = user; 
	user.name = 'sergey';
	console.log(user.name, admin.name)	// sergey sergey

===============================
мутабельные и иммутабельные типы.

	объект это мутабельный тип потому что можно изменить один из его элементов при этом ссылка на объект останется прежней. то есть при изменении объекта он возвращает старое значение, частично изменённое.

	примитивные типы все иммутабельны потому что при переназначении возвращают новое значение. но в контексте библиотек (redux, ngrx) объекты тоже могут быть иммутабельны. то есть при любом изменении потребителю будет возвращаться изменённая копия объекта.

===============================
приведение каких значений при помощи boolean даст false?

	Boolean(false);         // false
	Boolean(undefined);     // false
	Boolean(null);          // false
	Boolean('');            // false
	Boolean(NaN);           // false
	Boolean(0);             // false
	Boolean(-0);            // false
	Boolean(0n);            // false	

	Boolean(true);          // true
	Boolean('hi');          // true
	Boolean(1);             // true
	Boolean([]);            // true
	Boolean([0]);           // true
	Boolean([1]);           // true
	Boolean({});            // true
	Boolean({ a: 1 });      // true	

	оператор !! действует следующим образом: первый знак ! приводит значение к логическому и инвертирует его. Второй оператор ! снова инвертирует полученное значение. 

===============================
что такое NaN?

	это значение, получаемое в результате выполнения числовой операции над нечисловым значением:

		'string' / 4
		'string' * 3

	это значение можно получить, если пытаться привести к числу нечисловое значение:

		Number('123,4') // NaN
		Number(undefined) // NaN

		console.log(Number('123.4')) // 123.4
		console.log(parseFloat('123.4')) 	// 123.4
		console.log(parseInt('123.4')) 	// 123


	Number.isNaN() проверяет переданное аргументом значение и возвращает true, если это значение NaN.

===============================
что будет если сложить число и строку, в которой записано число?

	3 + '55' = '355'

===============================
как проверить тип переменной null?

	так как typeof null = Object , то тип проверяется на null:

		1:

			let s = null;
			console.log(s === null);

		2:

			let s = null;
			console.log(Object.is(s, null));

===============================
что такое Symbol?

	примитивный тип данных, значение которого не видно разработчику. к значению можно только обратиться через переменную, которой присвоен символ. каждое значение уникально (даже если имеют одинаковый id). Символы могут использоваться в качестве имён вычисляемых свойств в объектах. Символы игнорируются циклом for…in

		const sym = Symbol('name')	// аргумент-имя не обязателен, это просто описание
		const symTwo = Symbol('name')
		console.log(sym === symTwo) // false

	пример символьного свойства объекта:

		const secondaryId = Symbol()
		const user = {
		  'id': 193,
		  'name': 'Ольга',
		  [secondaryId]: 'olga-1'
		}
		console.log(user[secondaryId])

	существует глобальный реестр символов:

		const sym = Symbol.for('name'); // аргумент-имя может отсутствовать
		const symTwo = Symbol.for('name');
		console.log(sym === symTwo); // true

		то есть многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.

	можно получить название ключа по названию переменной хранения:

		let id = Symbol.for('key');
		let arg = Symbol.keyFor(id);
		console.log(id, arg); // SymbolObject key		

===============================
особенности JS

	1. однопоточный язык.
	2. работает в различных средах (браузер, нода)
	3. в зависимости от среды имее дополнительное апи. например, в браузере есть setTimeout, fetch
	4. в 2015 году вышло большое обновление
	5. использует ООП и возможности функционального программирования
	6. язык с динамической, слабой, неявной типизацией
	7. объекты связаны прототипным наследованием. 
	8. классы это синтаксический сахар для обычных функций

===============================
function declaration vs function expression

	FD это объявление типа function Name() {}. оно моментально высплывает на уровне блока, то есть  может быть вызвана раньше, чем она объявлена.

	FE это функция без имени, которая присвоена переменной:

		let f = function() {}

===============================
IIFE

	это функция, которая запускается сразу после объявления:

		(function() {
		    alert("I am an IIFE!");
		})();

	такая функция используется чтобы создать модуль:

		var module = (function () {
		  var name = 'Barry';
		  return { name };
		})();
		console.log(module.name);	

	работает так:

		1. переменной присваиваем результат функции
		2. () это просто знаки группировки, можно обойтись и без них
		3. переменная name не видна за пределами блока. это её область видимости
		4. финальные скобки сразу запускают функцию на исполнение
		5. return предоставляет публичный интерфейс

===============================
что такое коллбеки?

	Колбэк это просто переданная в виде аргумента функция, которая вызывается, когда принимающая функция получает ожидаемый результат. принимающая функция может быть синхронной или асинхронной.

	функции в JS могут принимать и возвращать другие функции. когда функция получает другие функции в качестве аргументов, то она в своём теле может выполнить один из аргументов-функций. в этом случае управление вернётся во внешний код.

	итак, функция, которая в виде аргумента передаётся другой функции это и есть коллбек.

	для коллбеков существую 2 проблемы:

	    1. невозможно точно выстроить их в очередь
	    2. если коллбек передаётся в сторонний код, то этот код может выполнить коллбек несколько раз. то есть происходит временная передача управление скриптом сторонней программе(инверсия управления).

	коллбек это функция, которая передаётся аргументом в асинхронную функцию и выполняется когда асинхронная функция получит результат.

	с учётом вышесказанного сам коллбек тоже может быть асинхронным и получать синхронную функцию в виде аргумента. и так до бесконечности. это ад коллбеков. проблема не столько во вложенностях сколько в невозможности точно сказать на какой ступени ада произойдёт  первое выполнение.	   

	пример ада коллбеков:  

		let resultA, resultB, resultC;

		function addAsync (num1, num2, callback) {
		    return $.getJSON('http://www.example.com', {
		        num1: num1,
		        num2: num2
		    }, callback);
		}

		addAsync(1, 2, success => {
		    // callback 1
		    resultA = success; // Получаем 3

		    addAsync(resultA, 3, success => {
		        // callback 2
		        resultB = success; // Получаем 6

		        addAsync(resultB, 4, success => {
		            // callback 3
		            resultC = success; // Получаем 10

		            console.log('total' + resultC);
		            console.log(resultA, resultB, resultC);
		        });
		    });
		});	

		видно, что чтобы в промисе вызвать промис приходится использовать много отступов.

		пример решения той же задачи, но через цепочки промисов:

			addAsync(1, 2)
			    .then(success => {
			        resultA = success;
			        return resultA;
			    })
			    .then(success => addAsync(success, 3))
			    .then(success => {
			        resultB = success;
			        return resultB;
			    })
			    .then(success => addAsync(success, 4))
			    .then(success => {
			        resultC = success;
			        return resultC;
			    })
			    .then(success => {
			        console.log('total: ' + success)
			        console.log(resultA, resultB, resultC)
			    });		

===============================
чистая функция

	1. не имеет сайд-эффектов
	2. при получении одинаковых аргументов возвращает одинаковый ответ

	Примеры побочных эффектов:

		Видоизменение входных параметров
		console.log
		HTTP вызовы (AJAX/fetch)
		Изменение в файловой системе
		Запросы DOM

===============================
мемоизация

	это сохранение функцией результатов в кеше. каждый результат помечен индексом. если входящий аргумент совпадает с индексом, то значение отдаётся из кеша.

		function memoizedAddTo80() {
		  let cache = {};
		  return function (n) {
		    if (n in cache) {
		      console.log('cache');
		      return cache[n];
		    } else {
		      console.log('calc');
		      cache[n] = n + 80;
		      return cache[n];
		    }
		  };
		}
		const memoized = memoizedAddTo80();

		console.log(memoized(5));
		console.log(memoized(5));
		console.log(memoized(5));
		console.log(memoized(10));

		// calc cache cache calc

	по сути мемоизация это кеширование на основе замыкания

===============================
как сохранить родительский контекст при вызове IIFE?

	IIFE вызывается после объявления в контексте window:

		property1 = 'ffff';
		(function (par1, par2, par3) {
		  console.log(par1, par2, par3);
		  console.log(this.property1);
		})(1, 2, 3);
		// вывод в консоль: ffff

	сохранить контекст можно, используя bind():

		property1 = 'ssss';
		var a = {
		  property1: 'ffff',
		  method1: function () {
		    (function (par1, par2, par3) {
		      console.log(this.property1);
		    }.bind(this)(1, 2, 3));
		  },
		};
		a.method1();	
		// вывод в консоль ffff

	или использовать стрелочную функцию

		var a = {
		  property1: "test",
		  method1: function() {
		    ((par1, par2, par3) => {
		      console.log(this.property1);
		    })(1, 2, 3);
		  }
		};

		a.method1();

===============================
Object.seal()

	запрещает добавление и удаление свойств. при этом менять значение существующих свойств можно.

	const obj = {
	  a: 11,
	  b: 22,
	};
	Object.seal(obj);

	obj.a = 333;
	obj.c = 444;
	console.log(obj);

	// { a: 333, b: 22 }


Object.freeze()

	делает то же что и seal, но при этом невозможно изменить значение существующих свойств.

	const obj = {
	  a: 11,
	  b: 22,
	};
	Object.freeze(obj);

	obj.a = 333;
	obj.c = 444;
	console.log(obj);	

	// { a: 11, b: 22 }

===============================
дескрипторы объекта

	у объекта есть ключ-значение, у этого ключа-значения есть дескриптор, с помощью которого можно:

		1. установить значение
		2. сделать его неперечислимым в цике
		3. запретить изменение значения
		4. запретить изменять сам дескриптор

	устанавливается дескриптор так:

		Object.defineProperty(obj, 'a', {
		  enumerable: false,
		});	

	получить значение дескриптора для свойства 'a' можно так:

		Object.getOwnPropertyDescriptor(obj, 'a')	

	вот пример работы этих свойств:

		let obj = {
		  a: 1,
		  b: 2,
		};

		Object.defineProperty(obj, 'a', {
		  enumerable: false,
		});

		let descriptor = Object.getOwnPropertyDescriptor(obj, 'a');

		console.log(descriptor);
		// вывод в консоль: {value: 1, writable: true, enumerable: false, configurable: true}

		for (let k in obj) {
		  console.log(k, obj[k]);
		}

		// вывод в консоль: b 2

===============================
hasOwnProperty()

	проверяет существует ли ключ в объекте и возвращает true/false. в отличие от in не проверяет наличие свойства в цепочке прототипа.

		let obj1 = {
		  a: 1,
		  b: 2,
		};

		let obj2 = {
		  c: 3,
		  d: 4,
		};

		obj2.__proto__ = obj1;

		console.log('a' in obj2);
		// true

		console.log(obj2.hasOwnProperty('a'), obj2['a']);
		// false 1

		for (let x in obj2) {
		  console.log(x);
		}
		// c d a b

===============================
откуда свойства у всех сущностей?

	в JS все сущности являются объектами. эти объекты имеют иерархию предков. все эти объекты наследуются от Object. 

	строка получает в наследство метод length массив получает в наследство методы push() от Array и т. д.

	когда происходит обращение к свойству/методу примитива, то он оборачивается в обёртку, которая является конструктором, создающим примитив. например для строкового примитива это String(). этот конструктор унаследованные имеет методы и свойства.

===============================
собственные объекты vs объекты хоста

	js имеет чётко определённый набор собственных объектов, которые доступны всегда: Math, Date, parseInt, Error и т. д.

	но JS используется в различных окружениях(браузер, node), у каждого из которых определён различный набор объектов хоста: window, document, setTimeout  т.д.

===============================
методы массивов

	arr.push(...items) – добавляет элементы в конец,
	arr.pop() – извлекает элемент из конца,
	arr.shift() – извлекает элемент из начала,
	arr.unshift(...items) – добавляет элементы в начало.

	arr.splice(1, 1); // начиная с индекса 1, получить 1 элемент

		const arr = [1, 2, 3];
		console.log(arr.splice(1, 2));	// [2, 3]


	arr.slice([start], [end]) возвращает новый массив, в который копирует все элементы с индекса start до end включительно 

		const arr = [1, 2, 3];
		console.log(arr.slice(0, 2));	// [1, 2]


	arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.

		const arr = [1, 2];
		console.log(arr.concat([8, 9]));	// [1, 2, 8, 9]


	includes()
	forEach()
	map()
	filter()
	reduce()
	find()

	sort получает кастомную функцию сравнения, получающую тоже 2 значения, которая будет возвращать 1, 0, -1

	reverse
	join

===============================
push 

	добавляет элементы в конец массива

unshift

	добавляет элементы в начало массива. этот метод более затратен так какв памяти весь массив придётся сдвинуть по ячейкам, на это требуется больше ресурсов. 

===============================
как работает метод sort()

	если он отрабатывает без аргументов, то все элементы сортируеются на основе кодов символов в строке. 

	если аргументом передаётся функция, то она должна принимать 2 аргумента(a, b), которые будет сравнивать и возвращать:  1 0 -1. для учёт особенностей местного алфавита можно использовать для сравнения:

		'a'.localeCompare('b');

			// Буква "а" идёт перед "в", поэтому результат будет отрицательным
			"а".localeCompare("в");		

	Для числового сравнения, вместо строкового, функция сравнения может просто вычитать b из a

	пример поиска наименьшего числа в массиве числе: args.sort((a, b) => a - b)[0]

===============================
метод some()

	 проверяет наличие определённого элемента в массиве и возварщает true/false

		const arr = [1, 2, 3, 4, 5];
		const has = arr.some((x) => x === 2);
		console.log(has);	// true

метод every()

	позволяет узнать удовлетворяют ли все элементы массива условию и возвращает true/false

		const arr = [1, 2, -3, 4, 5];
		const con = arr.every((x) => x > 0);
		console.log(con);	// false

===============================
деструктуризация 

	это присваивание элементов итерируемого объекта переменным в форме укороченного синтаксиса.

	для массива:

		const [a, b] = [1, 2];
		console.log(a, b);  // 1 2

		var тоже допускается

	для объекта:

		const { a, b } = { a: 1, b: 2 };
		console.log(a, b); // 1 2	

		есть возможность переопределить имена переменных: const { a: x, b: y }.

		ещё пример:

			const { b, a } = { a: 1, b: 2 };
			console.log(a, b); // 1 2			

	для строк:

		const [a, b] = 'qwe';
		console.log(a, b); // q w	

===============================
spread vs rest

	spread позволяет передавать итерируемые коллекции как аргументы или добавлять их в новый массив/объект. то есть этот оператор преобразует массив в набор значений.

		function f(a, b) {
		  console.log(a); // 1
		  console.log(b); // 2
		}
		const nums = [1, 2];
		f(...nums);

	или

		const coll = [1, 2];
		const arr = [...coll, 3, 4];
		console.log(arr);

	или 

		const obj1 = { a: 1, b: 2 };
		const obj2 = { c: 3 };
		const obj3 = { ...obj1, ...obj2, d: 4 };
		console.log(obj3);

	rest оператор применяется для того чтобы пометить остаточные параметры функции. например функция вызвана с 4 аргументами, но принимает только 2 именованных:

		function f(a, b, ...c) {
		  console.log(a, b, c);		// 1 2 [3,4]
		}
		f(1, 2, 3, 4);

	то есть rest набор значений собирает в массив.

===============================
ООП

	суть ООП заключается в том, чтобы составлять систему из объектов, решающих простые задачи, которые вместе составляют сложную программу. Объект состоит из состояний и методов, которые работают с этими состояниями. У объектов есть поведение, наследуемое от классаы или других объектов

	принципы:

		абстракция - способ выделить главное в объекте и забыть о не имеющем значения для понимания. например, есть объект Чайник, программисту важно знать что его можно включать и выключать, а каким именно способом он нагревает воду, точный вес, прочность и т.д. знать не нужно чтобы пользоваться чайником.

		инкапсуляция - способ ограничить доступ к составляющим объекта. например у чайника публичные методы это включение и выключение, остальные методы скрыты модификаторами доступа private или protected чтобы вредители не смогли попользоваться чайником и, уходя, изменить температуру нагрева до 50 градусов. принципиальное отличие от абстракции в том, что астракция работает с вниманием разработчика, а инкапсуляция с безопасностью объекта.

		наследование - способ организовывать классы в иерерхию таким образом, что наследник имеет доступ к методам и свойствам родителей. это позволяет избежать дублирования кода. наследование это принцип проектирования "от общего к частному", а композиция это принцип проектирования "от частного к общему". надо наследованию предпочитать композицию потому что не всегда понятно от какого именно родителя логично унаследоваться. например, чайник с таймером наследовать нужно от ёмкости или от таймера?

		полиморфизм - это способность метода/класса/функции выполнять различные операции в зависимости от получаемых данных. например объект истории хранит множество объектов типа Расход. но появилась необходимость кроме расходов хранить доходы. в этом случае создаётся класс Record, который принимает аргумент: type, amount. таким образом Record будет полиморфен, то есть в зависимости от аргумента type имеет различное значение и функционал(помещает в разные массивы доход и расход).	это называется мнимый полиморфизм.

		другой пример: есть класс Person, у которого есть метод приветствия greet(). класс Coder наследуется от Person. у Coder тоже есть свой метод greet(), который переопределяет метод greet класса Person.
		далее в цикле переберём массив, состоящий из инстансов person и coder. в этом цикле будем запускать класс greet(). в результате один и тот же меод выводит различные приветствия. это называется параметрический полиморфизм.

		также примером полиморфизма является:

			'ssssss'.length
			['a', 's', 'd'].length

		length унаследован от Object и обрабатывает строку и массив разными алгоритмами.

		-------------

		ассоциация:

			композиция:

				это когда включаемый в класс объект создаётся внутри класса.

					class Engine{}

					class Car {
					    public Car() {
					        this.engine = new Engine(360);
					 	}				
					 }

			агрегация:

				это когда включаемый в класс объект создаётся вне класса (DI).

					class Engine{}      

					class Car {
					    public Car(Engine someEngine) {
					         this.engine = someEngine;
					    }
					}

					Engine goodEngine = new Engine(360);
					Car porshe = new Car(goodEngine);		

		принципиальная разница в том, что в случае агрегации предоставленным объектом могут пользоваться другие сущности и, в частности, могут его удалить.

		--------------

		Класс представляет собой формальное абстрактное множество обобщённых характеристик сущности (знаний об объектах).
		 
		К характеристикам сущностей относятся свойства (описание объекта) и методы (активность объекта).
		 
		объекты хранят состояние (т.е. конкретные значения всех свойств, описанных в классе)
		 
		инкапсуляция это ограничение доступа к составляющим объекта для более прогнозируемого их изменения разработчиком.		


===============================
в JS наследование одиночное поэтому каждый объект может иметь только один прототип.

===============================
что такое функциональное программирование?

	в ФП все сущности представляются в виде чистых функций, которые принимают стейт и возвращают копию изменённого стейта. эти функции объединяются в композицию потому что являются функциями высшего порядка.

	То есть функция — это отображение входных данных на выходные.

	Чистые функции, которые лежат в основе ФП, надёжны, потому что всегда выдают одинаковый результат при одинаковых входных данных.

	ссылочная прозрачность это возможность заменить вызов чистой функции на конкретный результат.

	При компиляции кода, который обладает ссылочной прозрачностью, некоторые его куски можно «выполнить» заранее и получить готовое значение.

	но создание полных копий стейта требует ресурсов.

	полезные программы не могут существовать без сайд-эффектов поэтому такие эффекты нужно грамотно встраивать в функциональные программы.

	функциональные программы могут потреблять много оперативной памяти потому что в ней хранится стейт.

===============================
парадигмы программирования:

	1. функциональное программирование (конвейер чистых функций)
	2. ООП (классы аналоги объектов реального мира)
	3. процедурное (много подпрограмм, связанных беспорядочно. подпрограммы могут принимать аргументы. есть оператор goto

===============================
встроенные прототипы

	все объекты-конструкторы объединены в иерархию. все подклассы наследуют методы суперклассов потому что их __proto__ указывают на прототипы родителей. самый верхний суперкласс это Object.

		любой объект имеет метод toString(), который представляет объект в виде строки.
		любой массив имеет свойство length и метод push(). он перезаписывает метод toString() на свой собственный, который просто выводит элементы массива через папятую.

	при обращении к свойствам примитивов временно создаётся объект-обёртка, которая предоставляет методы и затем исчезает.

	Встроенные прототипы можно изменять. Например, если добавить метод к String.prototype, метод становится доступен для всех строк:

===============================
что такое ES классы

	класс это новая языковая конструкция, которая появилась в ES6. внутри класс представляет из себя функцию, тело которой состоит из конструктора класса. методы класса хранятся в prototype функции. оператор new создаёт объект из конструктора класса с методами из прототипа.

		class User {
		  constructor(name) { this.name = name; }
		  sayHi() { alert(this.name); }
		}

		let user = new User("Иван");
		user.sayHi();	

	это то же самое, что и:

		function User(name) {
		  this.name = name;
		}

		User.prototype.sayHi = function() {
		  alert(this.name);
		};

		let user = new User("Иван");
		user.sayHi();


	Классы всегда используют use strict.

===============================
герреты/сеттеры

	в объекте есть свойства-данные, а есть свойства-аксессоры, которые являются методами, но вне объекта выглядят как свойства данные.

	свойство-акцессор это функция, которая имеет доступ к свойствам-значениям через this. в остальном оно ведёт себя как функция(геттер/сеттер).
	существует возможность задавать их через defineProperty

	let user = {
		name: "Steve",
		surname: "Rogers",
		get fullName() {
		    return `${this.name} ${this.surname}`;
		  },
		set fullName(value) {
		    [this.name, this.surname] = value.split(" ");
		  }
	};
	// set fullName is executed with the given value.
	user.fullName = "Bruce Wayne";
	alert(user.name); // Bruce
	alert(user.surname); // Wayne

	--------

	let user = {
	  name: "Steve",
	  surname: "Rogers"
	};
	Object.defineProperty(user, 'fullName', {
	  set fullName(value) {
	    [this.name, this.surname] = value.split(" ");
	  }  
	});
	// set fullName is executed with the given value.
	user.fullName = "Bruce Wayne";
	alert(user.name); // Bruce
	alert(user.surname); // Wayne


===============================
способы расширения класса

	через наследование. наследовать можно от встроенных классов:

		class PowerArray extends Array {
		  isEmpty() {
		    return this.length === 0;
		  }
		}
		let arr = new PowerArray(1, 2, 5, 10, 50);
		alert(arr.isEmpty()); // false	

	то же самое через прототип:

		Array.prototype.isEmpty = function () {
		  return this.length === 0;
		};
		let arr = new Array();
		console.log(arr.isEmpty());	

	также класс можно расширять через композицию (включение другого класса через свойство):

		class PowerArray {
		  isEmpty(n) {
		    return n.length === 0;
		  }
		}

		class Example {
		  constructor(x) {
		    this.a = new PowerArray();
		  }

		  start(n) {
		    const s = this.a.isEmpty(n);
		    console.log(s);
		  }
		}

		const example = new Example();
		example.start([1, 2]);
			
===============================
статические свойства и методы

	они принадлежат не экземпляру, а именно классу. this там равно классу. они наследуются через ссылку [[prototype]].

	статические методы используются для того чтобы хранить общий функционал. например, их можно использовать как фабрику экземпляров, которые немного отличаются от обычных экземпляров:

		class Article {
		  constructor(title, date) {
		    this.title = title;
		    this.date = date;
		  }

		  static createTodays() {
		    // помним, что this = Article
		    return new this("Сегодняшний дайджест", new Date());
		  }
		}	

	статические свойства используются для хранения общих констант и могут использоваться статическими методами. статический метод обращается к статическому свойству через this.

		class Money {
		  static rates = {
		    usd: {
		      eur: 0.7,
		    }
		  };

		  static setRate(from, to, value) {
		    this.rates[from][to] = value;
		  }
		}	

===============================
ключевоe слово new

	используется для создания объекта из конструктора. конструктором может выступать функция или класс.

	при использовании new происходит следующее:

		1. Создаётся новый пустой объект, и он присваивается this. (this = {})
		2. в пустой объект добавляются свойства через this.
		3. Возвращается объект со свойствами.	

	цель конструкторов - предоставить возможность создания однотипных объектов.

===============================
super используется:

	1. в конструкторе дочернего класса для запуска конструктора родительского класса. super должно использоваться до первого this потому что не смысла объявлять переменную и сразу после этого её заменять на переменную из родителя:

		class Fish {
		  constructor(habitat, length) {
		    this.habitat = habitat
		    this.length = length
		  }
		  
		  renderProperties(element) {
		    element.innerHTML = JSON.stringify(this)
		  }
		}
		class Trout extends Fish {
		  constructor(habitat, length, variety) {
		    super(habitat, length)
		    this.variety = variety
		  }
		  
		   renderPropertiesWithSuper(element) {
		    element.className="green" 
		    super.renderProperties(element);
		  }
		}

	2. для вызова методов родительского класса

		см. пример выше

	3. для связывания объектных литералов (дочерний может вызвать метод родительского)

		var obj1 = {
		  method1() {
		    console.log('method 1');
		  }
		}

		var obj2 = {
		  method2() {
		    super.method1();
		  }
		}

		Object.setPrototypeOf(obj2, obj1);

	4. для вызова статических методов родительского класса

		class Rectangle {
		  static logNbSides() {
		    return 'У меня 4 стороны';
		  }
		}

		class Square extends Rectangle {
		  static logDescription() {
		    return super.logNbSides() + ', равные между собой';
		  }
		}	

===============================
класс это синтаксический сахар над обычной функцикй:

	class Hero {
		constructor(name, level) {
			this.name = name;
			this.level = level;
		}

		// Adding a method to the constructor
		greet() {
			return `${this.name} says hello.`;
	    }
	}	

	то же самое:

	function Hero(name, level) {
		this.name = name;
		this.level = level;
	}

	// Adding a method to the constructor
	Hero.prototype.greet = function() {
		return `${this.name} says hello.`;
	}	

===============================
promise vs async/await

	1. в промисах ошибки отлавливаются при помощи коллбеков, а в async\await при помощи try/catch
	2. запись async/await более напоминает синхронный код, хотя делает в принципе то же, что и промис.
	3. если в случае последовательного исполнения нескольких асинхронных операций происходит ошибка, то async/await предоставляет более подробную информацию.

		const makeRequest = async () => {
		  await callAPromise()
		  await callAPromise()
		  await callAPromise()
		  await callAPromise()
		  await callAPromise()
		  throw new Error("oops");
		}

		makeRequest()
		  .catch(err => {
		    console.log(err);
		    // output
		    // Error: oops at makeRequest (index.js:7:9)
		 })	

-----

	если перед функцией стоит async, то она вернёт промис.

		async function f() {
		  return 1;
		}
		f().then(alert); // 1

	внутри такой функции можно использовать await, который остановит ход выполнения ВНУТРИ async функции и будет ждать выполнения асинхронной операции.
	при этом ход выполнения ВНЕ async функции будет идти без задержки.

		async function f() {
		  let promise = new Promise((resolve, reject) => {
		    setTimeout(() => resolve("готово!"), 1000)
		  });

		  let result = await promise; // будет ждать, пока промис не выполнится (*)
		  alert(result); // "готово!"
		}
		f();

	для отлова ошибко используется блок try/catch. то есть другими словами, исключения высплывают во внешнюю функцию

===============================
отлов ошибок в цепочках промиса 

	просиходит в блоке then при помощи второго коллбека error или при помощи блока catch. при этом catch вообще может вернуть промис и работоспособность дальнейшей цепочки восстановится(то же самое можно сделать из коллбека error).

	catch может проверить ошибку через instancof и в зависимости от этого обоработать или пробросить дальше. если она пробрасывается дальше, то следующие блоки then пропускаются, а следующий блок catch срабатывает. 

	в промисе и блоках then/catch всегда есть неявный try/catch. это выражается в том, что если намеренно выбрасывается исключение 

		throw new Error("Ошибка!");

	, то оно заворачивается в reject.

===============================
статические методы класса Promise

	1. Promise.resolve - создаёт успешно выполненный промис

	2. Promise.reject - создаёт неуспешно выполненный промис

	3. Promise.all - получает несколько промисов, ждёт их завершения и отдаёт результаты в виде массива(или ошибку), если хотя бы один из промисов завершается с ошибкой, то ничего не отдаёт.

	4. Promise.allSettled - то же самое, но результаты отдаются при любом исходе в виде массива с элементами: {status:"fulfilled", value:результат}

	5. Promise.race - получает несколько промисов и ждёт первый выполнившийся(или ошибку)

	6. Promise.any - то же самое, но ждёт только первый успешный промис, ошибка игнорируется

===============================
можно ли отменить выполнение промиса?

	до недавнего времени промис нельзя было отменить, но теперь можно при помощи AbortController. это API, которое предоставляет браузер. оно живёт в window:

		function delay(duration, signal) {
		  return new Promise((resolve, reject) => {
		    if (signal.aborted) {
		      return reject(new DOMException('Operation aborted', 'AbortError'));
		    }

		    const timeoutId = setTimeout(() => {
		      resolve();
		    }, duration);

		    signal.addEventListener('abort', () => {
		      clearTimeout(timeoutId);
		      reject(new DOMException('Operation aborted', 'AbortError'));
		    });
		  });
		}

		const controller = new AbortController();
		const signal = controller.signal;

		delay(5000, signal)
		  .then(() => {
		    console.log('Promise resolved');
		  })
		  .catch(error => {
		    if (error.name === 'AbortError') {
		      console.log('Promise aborted');
		    } else {
		      console.error('Promise failed:', error);
		    }
		  });

		// Отменяем промис через 3 секунды

		setTimeout(() => {
		  controller.abort();
		}, 3000);


		здесь new AbortController() это некоторая глобальная переменная, за которой можно следить при помощи конструкции:

			if (signal.aborted) {}


===============================
что такое ajax?

	в одной из версий IE появился объект XMLHttpRequest. от него можно было создать экземпляр и затем повесить обработчики. этот объект стал использоваться для асинхронный действий, например, можно было отправить запрос на сервер, получить успешный ответ и обновить DOM, не перезагружая страницу.

		let xhr = new XMLHttpRequest();

		xhr.onload = function() {
		  alert(`Загружено: ${xhr.status} ${xhr.response}`);
		};

		xhr.onerror = function() { 
		  alert(`Ошибка соединения`);
		};

		xhr.onprogress = function(event) { // запускается периодически
		  alert(`Загружено ${event.loaded} из ${event.total}`);
		};		

	технологии, которые позволяли производить подобные действия называются AJAX. например fetch используется для отправки запросаов, promise для их обработки, js для изменения DOM.

	fetch - это часть браузерного апи. он выполняет запрос на сервер и возвращает промис, который содержит объект ответа и дополнительные вещи типа статуса:

		let response = await fetch(url);
		if (response.ok) {
		  let json = await response.json();
		} else {
		  alert("Ошибка HTTP: " + response.status);
		}

	или так:

		fetch('http://jsonplaceholder.typicode.com/posts')
		  .then((response) => response.json())
		  .then((data) => data)	

	По умолчанию fetch() запросы не включают в себя cookies 

	axios ещё одна библиотека для работы с запросами. она как и fetch возвращает промис.

		axios.get('/path').then(res => {
		    console.log(res); 
		});

		axios.post('/path', {"Name": "Vova"}).then(res => {
		    console.log(res);	

===============================
чем observable отличается от промиса?

	1. генерирует поток значений, а промис отдаёт только одно значение
	2. observable можно отменить, а промис нельзя
	3. для использования observable нужно подключать библиотеку, а промис это нативная возможность js
	4. у observable есть набор конвейерных функций для обработки результата

===============================
промисификация 
	
	это преобразования асинхронной функции, которая работает на коллбеках в функцию, которая возвращает промис.

	то есть создаётся обертка над оригинальной функцией, эта обёртка возвращает промис, содержащий resolve или reject. 

		было:

			function getData(onSuccess, onError) {
			  setTimeout(function () {
			    const result = Math.random()
			    if (result > 0.5) {
			      onSuccess(result)
			    } else {
			      onError(new Error('Что-то пошло не так'))
			    }
			  }, 1000)
			}

		стало:

			function getData() {
			  return new Promise(function (resolve, reject) {
			    const result = getData(
			      function (result) {
			        resolve(result)
			      },
			      function (error) {
			        reject(error)
			      }
			    )
			  })
			}	

===============================
функция

	это набор последовательных команд, который можно переиспользовать. кроме того функция может содержать свойства (как обычный объект потому что функция это и есть объект), а так же переменные (объявленные через var). к переменным нельзя обратиться извне, а к свойствам можно.

		function foo() {
		  var count = 2;	// переменная
		  foo.count = 1;	// свойство
		  console.log(count); // 2
		  console.log(foo.count); // 1
		}

		foo();

		console.log(foo.count); // 1


	функцию можно запускать в определённом контексте.

		function User(name) {
		  this.name = name;
		}

		User.prototype.Say = function() {
		  console.log('sss', this.name)
		}

		const f1 = new User('sergey');

		console.log(f1, typeof f1, User.prototype)
		f1.Say()

	в примере выше будет создан объект со свойством name и методом Say()

	можно функцию f1 запустить в другом контексте:

		const f2 = f1.Say;
		f2.call({name: 'misha'})	

	this функции всегда будет браться из контекста.

	-------------

	функция это объект поэтому она тоже может быть контекстом:

		const a = {
		  z: 1,
		  x: 2,
		};

		const b = function () {};
		b.z = 100;
		b.x = 200;

		function f() {
		  console.log(this.z);
		}

		f.call(a); // 1
		f.call(b); // 100		


================================
что такое http?

	это протокол обмена данными между клиентом и сервером, который не предполагает сохранения состояния.

	Чтобы отобразить веб страницу, браузер отправляет начальный запрос для получения HTML-документа этой страницы. После получения ответа браузер изучает полученный документ, и запрашивает дополнительные файлы, необходимые для отбражения содержания веб-страницы (исполняемые скрипты, CSS таблицы стилей, дополнительные ресурсы в виде изображений и видео-файлов), которые непосредственно являются частью исходного документа, но расположены в других местах сети. Далее браузер соединяет все эти ресурсы для отображения их пользователю в виде единого документа — веб-страницы.

	после ввода адреса в адресную строку формируется запрос, который состоит из 3 составляющих: 
		метод, 
		путь к ресурсу, 
		версия http-протокола,
		заголовки запроса,
		тело запроса (присутствует на всегда, зависит от метода запроса)

	ответ сервера содержит: 
		версию http-протокола, 
		код ответа, 
		человекточитаемый статус ответа, 
		заголовки ответа, 
		тело ответа (присутствует на всегда, зависит от метода запроса)

	Пример запроса:
	    GET http://ya.ru/index.html HTTP/1.1

	Пример ответа:
	    HTTP/1.1 200 Ok


	методы:
		OPTIONS - используется для проверки возможностей сервера. в частности для случая кроссдоменных запросов (метод и список заголовков, которые будут отправлены при последующем запросе ресурса).
		GET - Используется для запроса содержимого указанного ресурса.
		HEAD - Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело.
		POST - предназначен для передачи данных на сервер. при повторении не обязательно возвращает одинаковые результаты. в контексте REST используется для изменения данных. предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого.
		PUT - 
		PATCH - 
		DELETE - удаляет ресурс.


	Код состояния информирует клиента о результатах выполнения запроса. 
		1** - информационный
		2** - успешно
		3** - редирект
		4** - ошибка на строне клиента
		5** - ошибка на стороне сервера

		200 - ОК
		404 - not found
		401 - запрещено
		500 - ошибка сервера


	Заголовок HTTP (HTTP Header) — это строка в HTTP-сообщении, содержащая разделённую двоеточием пару вида «параметр-значение

	HTTP-заголовки разделяются на четыре основных группы:
	General Headers (Основные заголовки) — должны включаться в любое сообщение клиента и сервера.
	Request Headers (Заголовки запроса) — используются только в запросах клиента.
	Response Headers (Заголовки ответа) — присутствуют только в ответах сервера.
	Entity Headers (Заголовки сущности) — сопровождают каждую сущность сообщения.

	Присутствие тела сообщения в запросе отмечается добавлением к заголовкам запроса поля заголовка Content-Length или Transfer-Encoding.	

================================
cookies

	cookies 

		это строковые данные, которые сервер устанавливает на клиент после того как отвечает с заголовком Set-cookie. после этого браузер будет к каждому запросу на этот сервер отправлять связанные с ним куки в заголовке Cookie. сервер может установить на клиенте несколько куки.

	кроме имя=значения кука может включать дополнительные директивы, которые перечисляются через точку с запятой. исли они не указаны, то после окончания сессии кука удаляется:

		expires - дата до которой хранить куку на клиенте

		Max-Age - количество секунд, которое хранить куку на клиенте

		Domain - если не задан, то поддомены не учитываются при отправке кук. если задан, то поддомены учитываются

		Path - путь, который должен быть в урле чтобы кука отправилась

		Secure - кука будет отправляться только если используется шифрованный протокол

		HttpOnly - доступ к куке средствами JS запрещён, даже к чтению. (Document.cookie)

		SameSite - не отправлять куки при запросе сопутствующих ресурсов, например страница расположена на домене, который установил куку, а изображения этой страницы тянутся с других доменов. в этом случае, если SameSite не указан, то при запросе изображений тоже будут отправляться куки домена страницы.

		Куки с samesite=strict никогда не отправятся, если пользователь пришёл не с этого же сайта. это тоже помогает защититься от CSRF. например, сервер банка всегда получает свои куки, которые он установил в браузер пользователя. при этом пользователь находился на определённом сайте. если пользователь перейдёт на другой сайт, то сервер банка не получит доступ к кукам, которые он же установил.

================================
разница между http и https

	https шифрует трафик, хотя он чуть медленнее http. при этом сообщение не может быть изменено потому что подписывается цифровой подписью. кроме того сообщение передаётся именно на заданный сервер. предполагает дополнительные рукопожатия.

	http использует порт 80. https использует порт 443.


	сертификаты бывают: ssl, tls.

	сертификаты выдаёт центр сертификации. по сути  ЦС выдаёт клиенту и серверу набор ключей, которые те используют в шифровании. поэтому ЦС должен иметь доверие пользователей.

	сертификаты могут быть также самоподписанными. в этом случае не требуется наличие третьей стороны.

================================
CORS

	существует ограничение, из-за котрого невозможно выполнять асинхронные кроссдоменные запросы (то есть запросы на другой источник). например, клиент загружает с сервера js-скрипт, согласно политике одного домена, этот скрипт может отправить запрос только на этот же сервер, но не на другой. CORS это механизм, которые позволяет это ограничение обойти. 

	для этого в некоторых случаях отправляется предварительный запрос OPTIONS, который содержит специальные заголоки(список методов и заголовков основного запроса). если сервер устраивает, что его будет использовать клиент в качестве другого источника, то он отправляет специальные заголовки, которые разрешают последующий запрос. в этом случае фактически запрос состоит из двух запросов.

	но сервер может заблокировать запрос. это поможет предотвратить ситуацию когда клиент загружает скрипт, а этот скрипт берёт куки клиента и ломится с ними на сайт банка. сайт банка, получив предварительный запрос, пошлёт отказ.



	jsonp это способ способ загрузить json с другого домента. как известно, политика одного домена этого не разрешает. но если динамически создать элемент script и в его scr поместить запрос, то кроссдоменный запрос отработает без проблем.

	важно то, что к url нужно в виде get-параметра добавить коллбек, который выполнится сразу после получения данных:

		var s = document.createElement("script");
		s.src = "demo_jsonp2.php?callback=myDisplayFunction";
		document.body.appendChild(s);

		function myDisplayFunction(myObj) {
			console.log(myObj.name);
		}	

================================
что такое rest архитектура?

	это способ создания API с помощью протокола HTTP.

	rest это архитектурный стиль взаимодействия между компонентами распределённой системы. например клиент и сервер физически находятся в разных местах. обмен сигналами происходит через http-запросы. для клиента это значит, что если он хочет отправить сигнал на сервер, то должен будет использовать запрос, сформированный с url строго определённого типа.

	действие запроса определяется тем какой он использует метод: get, post, delete put и т.д. некоторые из методов предполагают отправку данных(post), некоторые просто посылают сигнал(delete). 

	например:

		delete book/3 удаляет запись, соответствующую книге №3.
		post book/3 записывает данные в книгу №3. при этом сами данные отправляются в теле запроса.

	принципы:

		клиент сервер разделены.
		каждый запрос должен содержать в себе всю необходимую информацию потому что http не сохраняет состояние.
		необходимо использовать кеширование для большей эффективности.
		клиент может запрашивать скрипты и выполнять их. 

================================
same origin policy 

	это политика одного источника. она определяет как скрипт или картинка, загруженная с одного сервера может взаимодействовать с другим сервером (например, послать запрос на другой сервер).

	две страницы имеют одинаковый источник, если у них одинаковы:

		протокол,
		домен,
		порт

	когда появился CORS стало возможно более тонко настроить политику одного источника, основываясь на заголовках предварительного запроса OPTIONS.

================================
mime тип

	всё, что не является чистым текстом передаётся в теле запроса в закодированном виде. чтобы принимающая сторона могла декодировать содержимое ей нужно знать по каким правилам она будет декодировать. это правило называется mime-типом и прописывается в заглоловке content type. 

	mime типы могут быть такие:

		image/png
		image/jpg
		image/gif

		audio/mp4
		audio/mpeg

	то есть для обычного текста используется кодировка, а для закодированного текста используется mime-тип.


================================
CSRF

	это атака, в результате которой злоумышленние отправляет самодельную форму, вместе с реальными куками пользователя. для этого он: 

		1. конструирует форму
		2. заманивает пользователя на свой сайт
		3. автоматически отправляет форму в сервис банка
		4. куки тоже отправляются
		5. банк получает куки, убеждается, что пользователь реальный,
		6. но банк никак не убеждается, что форма тоже была реальная, а не поддельная

	чтобы избежать этой атаки банк генерирует ключ на своей стороне и отправляет его закодированную версию чтобы пользователь подписал ей форму.
	после отправки подписанной формы банк сравнивает ключ и закодированную версию ключа.

XSS

	это уязвимость интерактивных элементов, которые, получая скрипт, заключённый в теги <script></script> сразу его начинают выполнять. а этот скрипт имеет доступ к кукам и может их отправить по email злоумышленнику.

	к примеру в чате 10 пользователей. злоумышленник отправляет всем скрипт и у каждого браузер выполняет этот скрипт. в результате злоумышленник получает 10 кук, при помощи которых может авторизоваться на популярном сайте.

	в другом случае злоумышленник может поместить скрипт не в чат, а в БД.

	в другом случае злоумышленник может поместить скрипт в один из гет-параметров.


================================
статус ответа 302

	301 это редирект страницы на другой url. а 302 это временный редирект страницы на новый url, при этом поисковые системы понимают, что не нужно менять свой индекс потому что скоро сайт снова станет доступен по старому адресу. 

	часто 302 используется во время проведения на сайте тех. работ.

================================
TCP и IP 

	основная роль IP заключается в поиске адреса, на который будут доставлены данные, а TCP отвечает именно за передачу данных. 

	TCP/IP аппаратно независим. то есть он может отправлять данные между устройствами с различной технологией преедачи данных.

================================
HTTP2

	это следующая версия протокола HTTP. её особенностями являются:

		1. бинарный формат, а не текстовый
		2. все запросы объединяются в один запрос и разбиваются на пакеты, 
		3. дополнительные ресурсы страницы типа картинок и скриптов известны сразу
		4. время ожидания уменьшается, но увеличивается нагрузка на пропускную способность канала

================================
коды http ответов

	1** - информационный
	2** - успешно
	3** - редирект
	4** - ошибка на строне клиента
	5** - ошибка на стороне сервера

	200 - ОК
	404 - not found
	401 - запрещено
	500 - ошибка сервера

================================
веб сокеты

	это протокол обмена данными между клиентом и сервром, который позволяет  инициировать отправку данных не запросом клиента, а инициативной сервера. при этом сервер может иметь постоянную реактивную связь с несколькмими клиентами. при этом запросы могут идти одновременно в обоих направлениях.

	кроме обычных веб сокеров ws существует шафрованная версия веб сокетов wss. это аналог https.

	перед установкой веб сокет соединения сначала отправляется запрос-рукопожатие в виде обычного http с определёнными заголовками.

	веб сокеты тоже используют протокол TCP для доставки данных. то есть большоие куски данных могут разбиваться на пакеты.

================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
основы js
================================
что такое область видимости?

	область видимости это область программы, в пределах которой установлена связь между объявлением переменной и обращением к переменной. 
	Окружение для области видимости — это доступные из текущего блока внешние переменные.

	существуют лексические и динамические области видимости.

	  лексическая область видимости (связь между объявлением переменной и обращением к переменной) формируются на этапе лексического разбора, а не на этапе выполнения программы.

	  то есть если разработчик написал функцию IN, которая вложена в функцию OUT, то после запуска программы функция IN всегда будет искать переменную сначала в своей области видимости, а затем в области видимости функции OUT:

	    function OUT() {
	      let a = 1;
	      function IN() {
	        console.log(a);
	      }
	    }

	  динамическая область видимости формируется на этапе выполнения. то есть если вызванная функция не находит переменную, то она будет искать её у функции, которая находится в стеке вызовов ниже:

	    let value = 2;

	    function showValue() {
	     console.log("Value from showValue: " + value); // 3
	    }

	    function wrapper() {
	     let value = 3;
	     console.log("Value from wrapper: " + value); // 3
	     showValue();
	    }

	    wrapper();  

	Область видимости определяет доступность переменных. существует глобальная область видимости и несколькок локальных.

	глобально объявленная переменная доступна из любых функций и блоков. переменные, которые объявлены в функциях и блоках недоступны извне. важно понимать, что если переменная не найдена в текущей области видимости, то она ищется во внешней и т.д.

================================
что такое замыкание?

	Замыкание – это способность внутренней функции получить доступ к переменным внешней функции уже после того как внешняя функция отработала.

	понятие замыкания тесно с вязано с понятиями область видимости и лексическое окружение.
	на этапе лексического анализа для каждой области видимости создаётся объект лексического окружения, который содержит:

		1. все переменные функции/блока с их значениями
		2. ссылку на внешнее лексическое окружение

	таким образом объекты лексических окружений выстраиваются в древовидную структуру. каждый узел этой структуры существует до тех пор пока хотя бы один из дочерних узлов на него ссылается. это ключевой момент.

	далее поиск переменных будет проходить сначала внутри ЛО этой функции, а затем в более внешних ЛО.

	рассмотрим пример:

		function outer() {
			const count = 10;
		  
			return function inner() {
				console.log(count);
			}
		}
		const count = 100;
		outer()();		// output: 10

	суть примера в том, что ЛО функции outer продолжает жить пока на неё ссылается хоты бы одно внутреннее ЛО. и поэтому функци inner будет искать недостающие переменные в ЛО функции outer

	ещё пример:

		function getCounter() {
			let counter = 0;
			
			return function() {
				return counter++;
			}
		}

		let count = getCounter();
		console.log(count());  // 0
		console.log(count());  // 1
		console.log(count());  // 2	

	--------------------------
	в C и большинстве других распространенных языков после возврата функции (оператор return или просто окончание работы) все локальные переменные становятся недоступными, так как фрейм стека уничтожается. В JavaScript они остаются в некотором смысле доступными.

	Замыкание — это фрейм стека, который выделяется, когда функция начинает свое работу, и не освобождается после ее возврата

	--------------------------

	Замыкание - это способ получения доступа и управления внешними переменными из функции.

	--------------------------
	в случае с коллбеками замыкания тоже действуют:

		let a = 111;

		function outer(cb) {
		  console.log('outer', a); // 111
		  cb();	// 22
		}

		function bla() {
		  let a = 22;

		  let f = function () {
		    console.log('a=', a); // 22
		  };

		  outer(f);
		}

		bla();

=======================
что такое лексическое окружение?

	если область видимости это набор правил, при помощи которых устанавливается связь между объявлением переменной и обращением к ней, то лексическое окружение это реализация этих правил.    

	технически лексическое окружение представляет из себя объект, который создаётся на этапе работы анализатора кода и содержит:

	  1. ссылку на родительское лексическое окружение
	  2. набор переменных и их значений, определённых в функции

	если в результате выполнения программы переменная не найдена в текущем ЛО, то она ищется во внешнем, и т.д.

	ЛО не удаляется сборщиком мусора до тех пока пока хотя бы одно внутреннее ЛО имеет ссылку на него. ЛО формируется на этапе работы анализатора кода и не может измениться после запуска программы.

	ЛО это объект, который создаётся для: 

		1. функции , 
		2. для блока (в частности для каждой итерации цикла или блоков тиа if), 
		3. для скрипта 

================================
что такое контекст выполнения функции?

	контекст выполнения это объект, из которого вызванная функция берёт свойства через ссылку this. обычно контекст указывают при вызове так:

		context.func();

	важно понимать, что контекст определяется объектом из котрого ВЫПОЛНЕНА функция, а лексическое окружение определяется функцией, внутри, которой ЗАПИСАНА функция.

	this внутри функции указывает на контекст объекта, в котором она была выполнена:

		const obj = {
			a: 10,
			inner: function() {
				console.log('inner', this);
			}
		}

		const outer = function() {
			console.log('outer', this);
		}

		outer();							// window
		obj.inner();						// { a: 10, inner: f }
		inner = obj.inner;
		inner();							// window или undefined - потеря контекста

	----------------------------

	привязка this происходит при каждом вызове функции, на основании ее точки вызова.

	привязка контекста определяется в момент вызова функции.

	правила для определения привязанного контекста:

		1. привязка по умолчанию

			когда функция вызывается без применения последующих правил:

				function foo() {
					console.log( this.a );
				}
				var a = 2;
				foo(); // 2		

			важно понимать, что если функция выполнена с привязкой по умолчанию, то контекстом будет window или undefined(это зависит от 'use strict'). при этом не важно вложена ли функция в другую функцию или нет. следующий код выведет 3:

				var a = 3
				function qwe() {
				  var a = 2;
				  function foo() {
				    console.log( this.a );
				  }
				  foo(); // 3
				}
				qwe() 			

		2. неявная привязка

			это когда перед функцией стоит владеющий объект:

				function foo() {
					console.log( this.a );
				}
				var obj = {
					a: 2
				};
				obj.foo(); // 2		

			важно то, что в качестве владеющего объекта может выступать функция потому что она тоже является объектом.

		3. явная привязка

			это использование call/apply

				function foo() {
					console.log( this.a );
				}
				var obj = {
					a: 2
				};
				foo.call( obj ); // 2		

			или использование bind

				function foo(something) {
					console.log( this.a, something );
					return this.a + something;
				}
				var obj = {
					a: 2
				};
				var bar = foo.bind(obj);
				var b = bar( 3 ); // 2 + 3
				console.log( b ); // 5

			по сути это вызов функции, которая внутри себя использует явную привязку

		4. new-привязка

			когда функция вызывается с указанием перед ней new, то:

				1. создаётся пустой объект {}
				2. this = {}
				3. этот объект заполняется через this.a = 123;
				4. функция возвращает сконструированный выше объект

			в этом случае контекстом служит тело функции-конструктора.

			function foo(a) {
				this.a = a;
			}
			var bar = new foo( 2 );
			console.log( bar.a ); // 2	

	----------------------------

	пример нежелательного помещения переменных в window

		function Person(firstName, lastName) {
		    this.firstName = firstName;
		    this.lastName = lastName;
		}

		Person('Joe', 'Smith');

		const { firstName, lastName } = window;
		console.log(firstName, lastName);  // Joe Smith	

	чтобы этого избежать нужно использовать классы со словом так как мы не можем вызывать классы без new.

=================
что такое стрелочная функция?

	СФ не имеет собственного контекста и ищет контекст вверх по иерархии лексического окружения, к которому принадлежит. 

	то есть контекст стрелочной функции определяется на этапе лексического анализа, а контекст обычной функции определяется на этапе вызова функции.

	отличия стрелочной функции от обычной.

		1. стрелочная функция не имеет собственного контекста. 
		2. не имеет названия
		3. не имеет псевдомассива arguments
		4. в ряде случаев можно не писать return
		5. Стрелочные функции нельзя использовать с new

		const obj = {
		  a: 10,
		  inner: () => {
		    console.log('inner', this);
		  }
		}

		obj.inner();					// window
		const f = obj.inner;
		f.call({a: 100});				// window

	то же самое для обычной функции:

		const obj = {
		  a: 10,
		  inner: function() {
		    console.log('inner', this);
		  }
		}
	  obj.inner();	// { a: 10, inner: f }

  	-------------------

  	можно поспорить с тем, что стрелочная функция не имеет имени:

		const func1 = () => console.log(123);
		console.log(func1.name);

		const func2 = function() {
			console.log(123)
		};
		console.log(func2.name);  	

  	-------------------

		let group = {
		  title: "Our Group",
		  students: ["John", "Pete", "Alice"],

		  showList() {
		    this.students.forEach(
		      student => console.log(this.title + ': ' + student)
		      // ошибки нет, хотя КАЖЕТСЯ, что СФ выполняется из контекста window
		    );
		  }
		};

		group.showList();	

		// Our Group: John
		// Our Group: Pete
		// Our Group: Alice		

		-----------------

		function greetWaitAndAgain() {
		  console.log(`Hello, ${this.name}!`)
		  setTimeout(() => {
		    console.log(`Hello again, ${this.name}!`)
		  })
		}

		const user = { name: 'Alex' }

		user.greetWaitAndAgain = greetWaitAndAgain;
		user.greetWaitAndAgain()

		// Hello, Alex!
		// Hello again, Alex!
		// setTimeout принадлежит функции greetWaitAndAgain, а та является частью объекта user. следовательно this стрелочной функции будет ссылаться на user.

================================
что такое промисы?

	промис это объект, который используется для выполнения асинхронного кода. он содержит функцию-экзекутор, которая выполняется сразу после создания промиса. в функции-экзекуторе происходит вызов resolve или reject. затем результат спускается по цепочке подписчиков.

		состояние до выполнения промиса - pending. после выполнения - filfilled или rejected.
		результат до выполнения - undefined. после выполнения value или error.

		console.log(1);
		const p = new Promise((resolve, reject) => {
		  console.log(2);
		  resolve('resolve!');	// reject('reject!');
		  console.log(3);
		});
		console.log(4);

		// вывод консоли будет: 1 2 3 4

	промис отдаёт thenable объект, на который можно подписаться при помощи двух коллбеков:

		p.then(
			success => console.log('success!'),
			error => console.log('error!')
		)

		then можно объединять в цепочки при этом важно помнить, что блок success или error должен вернуть тоже промис иначе в следующем блоке success будет undefined. то есть исполнение в любых случаях пройдёт по всем then в любом случае(даже после catch потому что catch это тот же then, но без первого коллбека).

			new Promise((resolve, reject) => resolve('resolve!'))
			  .then(
			    (success) => {
			      console.log('success!1', success);
			      reject();
			    },
			    (error) => console.log('error!1', error)
			  )
			  // .catch((error) => {
			  //   console.log('catch after 1', error);
			  //   return 444;
			  // })
			  // то же самое, что и...
			  .then(null, (error) => {
			    console.log('error after 1', error);
			    return 444;
			  })
			  .then(
			    (success) => {
			      console.log('success!2', success);
			      return 666;
			    },
			    (error) => console.log('error!2', error)
			  )
			  // finally никак не влияет на цепочку, но может вернуть reject()
			  .finally(() => {
			    console.log('fff');
			    return 777;
			  })
			  .then(
			    (success) => console.log('success!3', success),
			    (error) => console.log('error!3', error)
			  );

				// success!1 resolve!
				// error after 1 ReferenceError
				// success!2 444
				// fff
				// success!3 666

	-----------

	промисы можно связывать так:

		// Вызываем промис
		var askMom = function () {
		    willIGetNewPhone
		        .then(showOff) // связываем
		        .then(function (fulfilled) {
		            console.log(fulfilled);
		            // output: 'Hey friend, I have a new black Samsung phone.'
		        })
		        .catch(function (error) {
		            // oops, mom don't buy it
		            console.log(error.message);
		            // output: 'mom is not happy'
		        });
		};	

	-----------

	промисификация это переписывание функции, которая принимает 2 коллбека в промис. эта новая функция будет возвращать промис.

		было:

			function getData(onSuccess, onError) {
			  setTimeout(function () {
			    const result = Math.random()
			    if (result > 0.5) {
			      onSuccess(result)
			    } else {
			      onError(new Error('Что-то пошло не так'))
			    }
			  }, 1000)
			}

		стало:

			function getData() {
			  return new Promise(function (resolve, reject) {
			    getData(
			    	result => resolve(result),
			      error => reject(error)
			    )
			  })
			}

	------------

	Promise.all - аналог forkJoin. то есть ждёт завершения всех промисов и возвращает их результаты в виде массива. отклоняется, если хотя бы один из переданных промисов завершится с ошибкой.
	Promise.allSettled - аналог Promise.all, но результат возвращает в виде { status: "fulfilled", value: "^_^" }. не имеет значения завершились промисы успешно или с ошибкой.
	Promise.any - аналог all(), но возвращает значение первого успешно выполненного промиса. завершится с ошибкой, если все переданные промисы завершатся с ошибкой.
	Promise.race - возвращает значение первого выполнившегося промиса даже если он завершился с ошибкой.
	
================================
что такое hoisting?

	hoisting это процесс помещения переменных в лексическое окружение на этапе компиляции и присвоение им значений на этапе выполнения. при этом будет получена ошибка, если на этапе компиляции до объявления обратиться к let или const. для var значение будет undefined. function declaration и параметры функции будут доступны сразу.

		function f1() {
		  console.log('before', a);	// output: undefined
		  var a = 100;
		  console.log('after', a);	// output: 100
		}
		f1();

		function f2() {
		  console.log('before', a);	// output: ERROR
		  let a = 100;
		  console.log('after', a);	// output: 100
		}
		f2();

	function declaration и входящие параметры функции будут доступны сразу.

	классы нужно объявлять именно перед созданием инстанса.

	Назначение переменных имеет приоритет перед объявлением функции.
		var double = 22;
		function double(num) {
		  return (num*2);
		}
		console.log(typeof double); // Вывод: number


	Объявление функции имеет приоритет перед объявлением переменной.
		var double;
		function double(num) {
		  return (num*2);
		}
		console.log(typeof double); // Вывод: function

	---------

	console.log(variable);	// undefined
	var variable = 13;


	console.log(variable);	// variable is not defined
	variable = 13;


	console.log(variable);	// variable is not defined
	const variable = 13;	

================================
что такое event-loop? как он работает?

	эвент луп(ЭЛ) это цикл, который обрабатывает поступающие в него задачи. задачи могут быть синхронными и асинхронными(событиями). синхронные заполняют стек, а асинхронные попадают в очередь. события тоже попадают в стек. если к событию не привязан обработчик, то оно не обрабатвается циклом событий(не попадает в очередь).

	когда функция начинает выполнение, то создаётся контекст выполнения. он помещается в стек. если эта функция вызывает другую функцию, то в стек попадает ещё один контекст. таким образом по мере выполнения синхронных задач стек загружается и разгружается.

	когда в стеке нет задач, то начинают выполняться асинхронные задачи из очереди. setTimeout помещает задачу в очередь по прошествиии времени, указанного во втором аргументе.

	любое событие, например клик, помещается в очередь асинхронных событий(если на клик повешен обработчик, конечно же).

	важно понимать, что очерель событий начинает работать только после того как весь код основного скрипта выполнился(стек станет пустым) и поэтому js-движок перешёл в режим ожидания.

	очередь асинхронных событий состоит из микроадач(приоритетных) и макрозадач (не приоритетных). микрозадачи это промисы, макрозадачи это setTimeout, события браузера, сетевые запросы. существует возможность принудительно микромизировать задачу при помощи queueMicrotask(f).

	после каждой макрозадачи начинается перерисовка экрана. но экран не перерисовывается после каждой микрозадачи, необходимо чтобы все микрозадачи выполнились и только потом начинается перерисовка.

	после каждой макрозадачи движок исполняет все задачи из основного потока или из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице

================================
что такое иммутабельность?

	это состояние объекта, в котором его после инициализации невозможно изменить. результатом попытки любого изменения такого объекта будет новый объект. при этом старый объект остаётся без изменений.

	если объект имеет вложенную структуру, то все вложенные объекты, не подвергшиеся модификации, будут переиспользованы.

================================
как перебрать объект?

	// a 1 d 3
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		for (key in obj) {
		  console.log(key, obj[key]); 
		}

	// a 1
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		for (key in obj) {
		  if (obj.hasOwnProperty(key)) {
		    console.log(key, obj[key]); 
		  }
		}

	// a 1
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		const keys = Object.keys(obj);
		keys.forEach((key) => console.log(key, obj[key]));

	// 1
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		const keys = Object.values(obj);
		keys.forEach((value) => console.log(value));	

	// a 1
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		const keys = Object.entries(obj);
		keys.forEach(([key, value]) => console.log(key, value));

	// a 1
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		const keys = Object.getOwnPropertyNames(obj); // массив перечисляемых и неперечисляемых свойств объекта
		keys.forEach((key) => console.log(key, obj[key]));

	порядок перебора:

		Соглашение говорит, что если имя свойства – нечисловая строка, то такие ключи всегда перебираются в том же порядке, в каком присваивались. Так получилось по историческим причинам и изменить это сложно: поломается много готового кода.

		С другой стороны, если имя свойства – число или числовая строка, то все современные браузеры сортируют такие свойства в целях внутренней оптимизации.

===============================
способы создания объекта

	1. var person = new Object();

	2. const obj = {}

	3. var person = Object.create(null);

	4. 
		const Construct = function () {
		  this.name = 'masha';
		};
		const person = new Construct();
		console.log(person);		

================================
способы копирования объектов:

	1. JSON.parse(JSON.stringify(obj))

		глубокая копия. методы не копируются. не работает для циклических объектов. кроме несериализуемых данных: undefined, symbol()

			JSON.parse(JSON.stringify(itemsInCart))


	2. Object.assign

		неглубокая копия. методы копируются

			const a = { name: 'Joe Bloggs' };
			const b = Object.assign({}, a);
			console.log(a === b); //=> flase		


	3. clone = { ...user };

		неглубокая копия. методы копируются

			const a = { name: 'Joe Bloggs' }
			const b = { ...a, age: 27 };
			console.log(a === b) //=> false		


	4. for (let key in user) {}

		неглубокая копия. методы копируются

			function copy(mainObj) {
			  let objCopy = {};

			  for (let key in mainObj) {
			    objCopy[key] = mainObj[key];
			  }
			  return objCopy;
			}

			const mainObj = {
			  a: function () {
			    console.log(123);
			  },
			  b: 5,
			  c: {
			    x: 7,
			  },
			};

			const copyObj = copy(mainObj);
			console.log(copyObj); // ok
			copyObj.a(); /// 123		


	5. рекурсивный обход

		глубокая копия. методы не копируются

			function isPrimitive(obj) {
			  return (
			    obj == null ||
			    typeof obj === 'number' ||
			    typeof obj === 'string' ||
			    typeof obj === 'boolean'
			  );
			}

			function isArray(obj) {
			  return Array.isArray(obj);
			}

			function isObject(obj) {
			  return obj != null && typeof obj === 'object';
			}

			function deepClone(obj) {
			  if (isPrimitive(obj)) {
			    return obj;
			  } else if (isArray(obj)) {
			    return obj.map((val) => {
			      return deepClone(val);
			    });
			  } else if (isObject(obj)) {
			    let res = {};
			    for (let k in obj) {
			      res[k] = deepClone(obj[k]);
			    }
			    return res;
			  }
			}

			const obj1 = {
			  a: 10,
			  b: [{ a: 1 }, { b: 2 }],
			};

			const obj2 = deepClone(obj1);
			obj1.b[0].a = 100;
			console.log(obj1, obj2);


	6. lodash cloneDeep()

		глубокая копия

	7. structuredClone()

		глубокая копия



-----------------

способы клонирования массива:

	numbers = [1, 2, 3];
	numbersCopy = [...numbers];

	----

	numbers = [1, 2, 3];
	numbersCopy = [];

	for (i = 0; i < numbers.length; i++) {
	  numbersCopy[i] = numbers[i];
	}

	----

	numbers = [1, 2, 3];
	numbersCopy = numbers.map((x) => x);

	----

	numbers = [1, 2, 3];
	numbersCopy = numbers.filter(() => true);

	----

	numbers = [1, 2, 3];

	numbersCopy = numbers.reduce((newArray, element) => {
	  newArray.push(element);

	  return newArray;
	}, []);

	----

	numbers = [1, 2, 3, 4, 5];
	numbersCopy = numbers.slice();

	----

	nestedNumbers = [[1], [2]];
	numbersCopy = JSON.parse(JSON.stringify(nestedNumbers));

	----

	var numbers = [1, 2, 3];
	var numbersCopy = numbers.concat([]); 
	console.log(numbersCopy === numbers) // false

	----

	numbers = [1, 2, 3];
	numbersCopy = Array.from(numbers);

	----

	var numbers = [1, 2, 3];
	var numbersCopy = structuredClone(numbers)
	console.log(numbersCopy === numbers)




================================
что такое глубокая и мелкая копия объекта?

	если объект состоит из вложенных структур, то при создании копии копируются только приммитивы, а объекты ссылаются на одно и то же место в памяти.

		const itemsInCart = [
		  { product: 'Носки', quantity: 3 },
		  { product: 'Штаны', quantity: 1 },
		  { product: 'Кепка', quantity: 1 },
		];
		const clonedCart = [...itemsInCart];

		itemsInCart[0].quantity = 4;

		console.log(itemsInCart[0].quantity);	// 4
		console.log(clonedCart[0].quantity);	// 4

	глубокая копия это когда оригинал и копия полностью независимы. мелкая копия это когда копия и оригинал зависимы вложенными структурами.

================================
e.preventDefault()

	отменяет стандартное событие. например, клик по ссылке не приведёт к переходу на другую страницу. или клик по чекбоксу не будет менять состояние чекбокса.

		<input type="checkbox" id="my-checkbox" />
		document
		  .getElementById('my-checkbox')
		  .addEventListener('click', (e) => e.preventDefault());

event.stopPropagation()

	останавливает всплытие. то есть всплывающее событие будет вызывать все обработчики на своём пути. но, встретив, stopPropagation оно остановится.

		<body onclick="alert('сюда обработка не дойдёт')">
		  <button onclick="event.stopPropagation()">Кликни меня</button>
		</body>

================================
DOM

	это объект, который строится на основе парсинга html-документа сразу после загрузки html с сервера. DOM имеет более строгую структуру потому что html может иметь ошибки в виде незакрытых случайно тегов.

	DOM позволяет менять html средствами js.

window 

	это глобальный объект браузера. он хранит все глобально доступные свойства и методы. например, alert(), console.log(). контекст window не обязательно писать перед точкой.

	каждая вкладка браузера содержит свой отдельный window.

	Window.location - получает или устанавливает url.
	Window.localStorage - хранит объект локального храналища с методами добавления и получения.
	Window.history - хранит объект истории браузера(только чтение)

================================
document

	Это объект, который позволяет работать с html-структурой страницы, а так же с куками.

	window — содержит свойства и методы для управления окном браузера. document — позволяет работать с содержимым страницы.

================================
addEventListener 

	это альтернативный способ добавить обработчик события html-элементу. в отличие от атрибутивного способа он позволяет программно удалять обработчики, а так же повесить несколько обработчиков событий на один элемент (атрибут так не умеет и будет перезатирать предыдущие). 

================================
делегирование событий

	это способ обработать много элементов похожим образом при помощи назначения обработчика их родителю, а не каждому элементу.

	event.target позволяет понять на каком конкретно элементе произошло событие.

================================
модификация в DOM

	document.createElement('div');

	document.body.append(div);
	document.body.prepend(div);

	document.body.insertAdjacentHTML("afterbegin", `<div class="alert">
		<strong>Всем привет!</strong> Вы прочитали важное сообщение.
	</div>`);	

	div.remove()

	elem.cloneNode(true) создаёт «глубокий» клон элемента

	const button = document.querySelector("button");
	button.setAttribute("name", "helloButton");	

================================
requestAnimationFrame

	это функция, предоставляемая браузером, которая приводит частоту обновления анимации к частоте обновления экрана. по сути эта функция похожа на setTimeout, но интервал обновления браузер рассчитывает сам.

	кроме того начало каждого цикла анимации будет совпадать с началом цикла перерисовки в браузере, это экономит ресурсы браузера.

		function step(timestamp) {
		  // animation code
		  window.requestAnimationFrame(step);
		}
		window.requestAnimationFrame(step);	

web workers

	это средство для запуска скриптов в фоновом режиме. скрипты выполняются не в контексте window. эти скрипты не влияют на работу основного потока приложения.

	в отдельном файле нужно написать скрипт, который будет выполняться фоном и передать его в конструктор:

		var myWorker = new Worker("worker.js");

	пример отправки данных в воркер:

		myWorker.postMessage([first.value,second.value]);

	внутри воркера данные принимаются при помощи слушателя событий:

		onmessage = function(e) {
		  var workerResult = 'Result: ' + (e.data[0] * e.data[1]);
		  postMessage(workerResult);
		}		

	веб воркеры могут быть выделенные и разделяемые. 

	прмер кода:

		// web-worker.js
		onmessage = e => {
		  console.log("worker " + e.data);
		  postMessage("message from worker");
		};

		// index.js
		var myWorker;

		function send() {
		  myWorker.postMessage(document.getElementById("input").value);
		}

		if (window.Worker) {
		  myWorker = new Worker("web-worker.js");

		  myWorker.postMessage = e => {
		    console.log(e.data);
		  };
		}

	существуют shared воркеры. с помощью них можно отправлять сообщения между вкладками, iframes. 

		// Первая вкладка: app1.js
		const sharedWorker = new SharedWorker('worker.js')

		sharedWorker.port.onmessage = (event) => {
		  console.log('data from worker', event)
		}

		const sendDataToWorker = () => {
		  sharedWorker.port.postMessage(1)
		}



		// Вторая вкладка: app2.js
		// то же самое



		// Воркер: worker.js
		let sum = 0

		onconnect = (connect) => {
		  const port = connect.ports[0] // В ports всегда один элемент

		  port.onmessage = (event) => {
		    sum += event
		  }

		  port.postMessage(sum)
		}



================================
сервис воркеры

	это часть js, а не часть angular. они похожи на резделяемые веб-воркеры.

	это скрипт, работающий между сайтом и сетью и дающий вам, кроме прочего, возможность перехватывать сетевые запросы и отвечать на них различными способами.  для работы сервис-воркеров необходим HTTPS

	сервис-воркер выполняется в отдельном потоке от потока страницы, которую он контролирует. в нём можно писать js-код.

	Основная часть работы сервис-воркера заключается в прослушивании соответствующих событий и полезном реагировании на них. Различные события запускаются в разные моменты жизненного цикла сервис-воркера.

	создадим сервис-воркер:

		// serviceWorker.js:

		self.addEventListener('install', event => {
		  // Do install stuff
		});

		self.addEventListener('activate', event => {
		  // Do activate stuff: This will come later on.
		});	


	далее на каждой странице сайта подключается этот сервис-воркер:

		if ('serviceWorker' in navigator) {
		  navigator.serviceWorker.register('/serviceWorker.js', {
		    scope: '/'
		  });
		}

	если мы хотим кешировать картинки и скрипты, то измененим наш сервис-воркер:

		self.addEventListener('install', event => {

		  function onInstall () {
		    return caches.open('static')
		      .then(cache => cache.addAll([
		        '/images/lyza.gif',
		        '/js/site.js',
		        '/css/styles.css',
		        '/offline/',
		        '/'
		      ])
		    );
		  }

		  event.waitUntil(onInstall(event));
		});	


	тут больше: https://prgssr.ru/development/sozdaem-service-worker.html#heading-section

================================
широковещательный канал передачи данных.

	позволяет передавать сообщения между вкладками браузера, iframes. это аналог разделяемых веб-воркеров. на этот канал можно подписаться из любого контекста. 

	осуществляется только в контексте одного домена.

		// создание канала
		var bc = new BroadcastChannel('test_channel');

		// отправка сообщений всем подписчикам
		bc.postMessage('This is a test message.');

		// Пример простого обработчика событий, который
		// выводит сообщения в консоль
		bc.onmessage = function (e) { 
		  console.log(e.data); 
		}

		// Отключение от канала
		bc.close()	


		пример файла-отправителя:

			var cannel = new BroadcastChannel('channel1');
			cannel.postMessage('Привет другому окну');		

		пример файла-получателя:

			var cannel = new BroadcastChannel('channel1');
			cannel.onmessage = function (ev) { console.log(ev); }


================================
web api

	это функционал, который предоставляет браузер для встроенного языка JS. существуют апи для:

		1. работы с локальным хранилищем браузера
		2. для AJAX-запросов
		3. для геолокации
		4. для работы с устройствами, например считывающие геолокацию смартфона

	любой апи это объект, который предоставляет несколько публичных методов.

		var myGeo = navigator.geolocation;
		myGeo.getCurrentPosition(function(position) { ... });

		коллбек запустится, когда текущее положение устройства будет успешно считано.


================================
итератор

	это объект, который при помощи метода next() перебирает итерируемый объект.

	итерируемый объект имеет свойство с ключом Symbol.iterator. значением его является ссылка на итератор. в контексте цикла исполььзуется эта ссылка и итератор при каждом проходе цикла запускает next();

================================
генератор

	это функция котрая может возвращать значение многократно. после создания генератора можно использовать next(), что приведёт к очередному возвращаению значения.

		function* generator() {
		  yield 1;
		  yield 2;
		  yield 3;
		}
		const gen = generator(); // "Generator { }"
		console.log(gen.next().value); // 1	

	так как генератор это итерируемый объект, то внутри него есть свойство с ключом Symbol.iterator.

	генератор можно преебирать при помощи цикла, в этом случае цикл при каждом проходе будет неявно пинать next().


================================
Различия между for...of и for...in

	for...of перебирает итерируемый объект (например, массив). а точнее его перечисляемые свойства.

		может быть прерван при помощи инструкции break или continue

	for...in перебирает перечисляемые ключи объекта, в том числе перечисляемые унаследованные свойства. если при помощи for...in перебирать массив, то будут выведены индексы элементов массива: 1, 2, 3 и т. д. причём в виде строки, а не числа.



	Цикл for...in будет перебирать не только собственные свойства объекта, но и перечисляемые свойства, наследуемые от цепочки прототипов:

		const grandParent = { a: 1, b: 2 }
		const parent = { b: 3, c: 4 }
		const object = { c: 5 }

		Object.setPrototypeOf(parent, grandParent)
		Object.setPrototypeOf(object, parent)

		for (const key in object) {
		  console.log(key, object[key])
		}
		// c 5
		// b 3
		// a 1

		порядок обхода следующий:

			1. не отрицательные целочисленные ключи, которые могут быть индексами массива

			2. строковые ключи в порядке хронологии создания


================================
===============================
что такое прототип?

	есть: 

		1. объекты,
		2. функции-конструкторы, из которых сделаны эти объекты,
		3. объекты-хранилища (прототипы), которые есть у каждой функции-конструктора (или класса потому что класс это тоже функция).

	ссылка __proto__ есть и у функций-конструкторов и у объектов. ссылка __proto__ это геттер/сеттер для ссылки [[prototype]], которая напрямую недоступня для редактирования прграммисту.

	современный вариант __proto__ это: 

		Object.getPrototypeOf(arg),
		Object.setPrototypeOf(arg1, arg2).

	у объектов __proto__ указывает на прототип функции-конструктора, при помощи которой был сделан объект. например:

		const obj = new Object();
		console.log(obj); // {}
		console.log(obj.__proto__); // Object.prototype

	у функций-конструкторов __proto__ указывает на прототип родительской функции-конструктора (как известно функции-конструкторы объединены в иерархию, на вершине которой находится Object)

	таким образом, существует возможность для объекта искать недостающие свойства и методы вверх по цепочке __proto__ в прототипе функции-конструктора. а если там не находится, то поиск будет продолжаться по __proto__ функции конструктора.

	однако существует возможность сделать так чтобы __proto__ объекта не ссылалась на простотип функции-конструктора, а ссылалась на другой объект:

		const person = {
		  age: 18,
		};

		const user = {
		  name: 'John',
		};

		user.__proto__ = person;

		console.log(user.age); // 18

		в этом случае user имеет в __proto__ ссылку на объект person вместо ссылки на прототип функции-конструктора. однако person всё равно ссылается через __proto__ на прототип конструктора Object поэтому оба объекта будут иметь доступ к методам: toString, valueOf и т.д.

	у стрелочной функции прототипа нет.

	важно то, что при поиске свойства конструктора через цепочку прототипов значение сначала ищется в самом конструкторе и только потом в его прототипе:

		function A() {
		  this.qwe = 222;
		}

		A.prototype.qwe = 111;
		console.log(A.prototype)	// {qwe: 111}

		const a = new A();
		console.log(a.__proto__);	// {qwe: 111}
		console.log(a.qwe);	// 222	


---------

чем отличаются _proto_ и .prototype?

	Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__.

		var animal = {
		  eats: true
		};
		var rabbit = {
		  jumps: true
		};
		rabbit.__proto__ = animal;
		console.log(rabbit.eats)	// true

	или 

		var animal = {
		  eats: true
		};
		function Rabbit(name) {
		  this.name = name;
		  this.__proto__ = animal;
		}
		var rabbit = new Rabbit("Кроль");
		console.log( rabbit.eats ); // true

	Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.
	При создании объекта через new, в его прототип __proto__ записывается ссылка на функцию-конструктор

		var animal = {
		  eats: true
		};
		function Rabbit(name) {
		  this.name = name;
		}
		Rabbit.prototype = animal;
		var rabbit = new Rabbit("Кроль"); //  rabbit.__proto__ == animal
		console.log(rabbit.eats)	// true

================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
