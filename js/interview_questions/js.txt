================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
чтобы приложение было интерактивным необходимо чтобы браузер посылал события, а разработчик своим кодом улавливал их. 

например, если на элемент DOM пользователь кликнул, то программист может подписаться на событие клика и обработать его при помощи коллбека.

подписаться можно двумя способами:

	1. on-свойства элементов 

		onclick,
		onmouseenter,
		onscroll

		buttonElement.onclick = function() {
		  squareDiv.style = `background-color: ${getColor()};`
		}		

	2. addEventListener()

		buttonElement.addEventListener('click', function() {
		  squareDiv.style = `background-color: ${getColor()};`
		})	

================================
перечислить типы данных в js

null 
undefined
symbol	// let id = Symbol("id");
bigint	// const bigInt = 1234567890123456789012345678901234567890n;
number
string
boolean
object
+
function (унаследованы от object)

================================
что такое вычисляемое свойство?

это свойство объекта, заданное в квадратных скобках. в качестве имени можно использовать выражение. в частности символьный тип.

================================
что такое свойство-значение и свойство-акцессор?

это функция, которая имеет доступ к свойствам-значениям через this. в остальном оно ведёт себя как функция(геттер/сеттер).
существует возможность задавать их через defineProperty

let user = {
  name: "Steve",
  surname: "Rogers",
get fullName() {
    return `${this.name} ${this.surname}`;
  },
set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }
};
// set fullName is executed with the given value.
user.fullName = "Bruce Wayne";
alert(user.name); // Bruce
alert(user.surname); // Wayne

--------

let user = {
  name: "Steve",
  surname: "Rogers"
};
Object.defineProperty(user, 'fullName', {
  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }  
});
// set fullName is executed with the given value.
user.fullName = "Bruce Wayne";
alert(user.name); // Bruce
alert(user.surname); // Wayne

================================
в чём разница между приммитивным и ссылочным типом?

есть разница при копировании. примитивные типы копируют значения, а ссылочные - ссылки.

let message = "Привет!";
let phrase = message;
message = 'qwerty';
console.log(message, phrase);

let user = { name: "Иван" };
let admin = user; 
user.name = 'sergey';
console.log(user.name, admin.name)

================================
в чём разница между == и ===?

оператор === сранвивает типы и значения.

оператор == сначала приводит операнды к одому типу и только после этого сравнивает значения.

Если оба операнда являются объектами, то JavaScript сравнивает внутренние ссылки, которые равны в том случае, если они ссылаются на один и тот же объект в памяти.
если же один из операндов является примитивом, а другой объектом, то: 
1. объект преобразуется в примитив, 
2. затем они приводятся к одному типу,
3. затем они сравниваются


================================
есть ли в js возможность сделать свойство объекта приватным?

приватные свойства по соглашению начинаются со знака _. но это не синтаксис, а просто соглашение. оно может быть нарушено.

Приватные свойства и методы должны начинаться с #. Они доступны только внутри класса. 

	class CoffeeMachine {
	  #waterLimit = 200;
	  #checkWater(value) {
	    if (value < 0) throw new Error("Отрицательный уровень воды");
	    if (value > this.#waterLimit) throw new Error("Слишком много воды");
	  }
	}

	let coffeeMachine = new CoffeeMachine();

	coffeeMachine.#checkWater(); // Error
	coffeeMachine.#waterLimit = 1000; // Error

this['#name'] не работает. 

================================
Можно ли в js вызвать функцию до ее объявления? Как это работает? 

================================
что делает Object.create()?

// Объект, создаваемый при помощи Object.create(null) не имеет прототипа,
	var data = Object.create(null);
	data.text = "Привет";

================================
как добавить или изменить свойство объекта, не использую точечную нотацию или квадратные скобки?

	const o = {}; // Создаём новый объект
	Object.defineProperty(o, 'a', {
	  value: 37,
	  writable: true,
	  enumerable: true,
	  configurable: true
	});
	// Свойство 'a' существует в объекте o и имеет значение, равное 37

свойство-акцессор можно менять так:

	Object.defineProperty(user, 'fullName', {
	  set fullName(value) {
	    [this.name, this.surname] = value.split(" ");
	  }  
	});

================================
что такое IIFE? приведите пример

================================
как можно запретить добавление и удаление свойств объекту?

Object.seal(obj);

================================
как сделать так чтобы свойства объекта стали неизменяемыми и при этом невозможно было ни добавить, ни удалить свойства?

Object.freeze(obj)

================================
что такое Named Function Expression? 

var f = function sayHi(...) { /* тело функции */ };
фцнкция sayHi может вызвать себя изнутри. это может понадобиться при рекурсии.

================================
чем отличаются _proto_ и .prototype?

Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__.

	var animal = {
	  eats: true
	};
	var rabbit = {
	  jumps: true
	};
	rabbit.__proto__ = animal;
	console.log(rabbit.eats)	// true

или 

	var animal = {
	  eats: true
	};
	function Rabbit(name) {
	  this.name = name;
	  this.__proto__ = animal;
	}
	var rabbit = new Rabbit("Кроль");
	console.log( rabbit.eats ); // true

Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.
При создании объекта через new, в его прототип __proto__ записывается ссылка на конструктор

	var animal = {
	  eats: true
	};
	function Rabbit(name) {
	  this.name = name;
	}
	Rabbit.prototype = animal;
	var rabbit = new Rabbit("Кроль"); //  rabbit.__proto__ == animal
	console.log(rabbit.eats)	// true

================================
что такое коллбек? что такое ад коллбеков?

коллбек это функция, которая передаётся аргументом в асинхронную функцию и выполняется когда асинхронная функция получит результат.

с цчётом вышесказанного сам коллбек тоже может быть асинхронным и получать синхронную функцию в виде аргумента. и так до бесконечности. это ад коллбеков.

чтобы избежать неоднозначности принято использовать промисы. промисы позволяют выполнять последующий колбек только  после того как отработает предыдущий. при этом визуально вместо лесенки код выстраивается в цепочки(chaining).
промис может быть в трёх состояниях: успех, провал, ожидание.

Promise.all принимает набор промисов, ждёт пока все они выполнятся и возвращает их результат в виде массива.

вместо промисов можно использовать конструкицию async/await

================================
что такое async/await?

если перед функцией стоит async, то она вернёт промис.

	async function f() {
	  return 1;
	}
	f().then(alert); // 1

внутри такой функции можно использовать await, который остановит ход выполнения ВНУТРИ async функции и будет ждать выполнения асинхронной операции.
при этом ход выполнения ВНЕ async функции будет идти без задержки.

	async function f() {
	  let promise = new Promise((resolve, reject) => {
	    setTimeout(() => resolve("готово!"), 1000)
	  });

	  let result = await promise; // будет ждать, пока промис не выполнится (*)
	  alert(result); // "готово!"
	}
	f();

для отлова ошибко используется блок try/catch

================================
упорядочены ли ключи в объекте?

если ключи могут быть преобразованы к числу, то упорядочены. в ином случае - нет

================================
чем отличается постфиксный инкремент от префиксного?

постфиксный выполняется поле приравнивания:

	let i = 0;
	let s = i++		// s = 0

	let i = 0;
	let s = ++i		// s = 1	

================================
как js-классу назначить свойства без использования конструктора?

	class MyClass {
	  a = 1;
	  b = 2;
	  c = 3;
	}

	const m = new MyClass();
	console.log(m.b);

================================
в чём разница между Object.assign() и spread-оператором?

spread-оператор всегда создаёт новый объект, а Object.assign лишь мутирует существующий. поэтому в случае со spread-оператором происходит перезапись объекта по ссылке.

	const a = { name: 'Joe Bloggs' }
	const b = { ...a, age: 27 };
	console.log(a === b) //=> false

	const a = { name: 'Joe Bloggs' }
	const b = Object.assign(a, { age: 27 });
	console.log(a === b) //=> true

	но

	const a = { name: 'Joe Bloggs' };
	const b = Object.assign({}, a, { age: 27 });
	console.log(a === b); //=> flase

================================
что такое модуль?

если подключить скрипт в станицу, то может произойти так, что переменные скрипта заместят переменные страницы(если у них одинаковые названия). чтобы этого не произошло код скрипта помещется в отдельную область видимости. переменные из этой области видимости экспортируеются при помощи return

	var lodash = (function() {

	  var version;
	  function assignDefaults() { ... }

	  return {
	    defaults: function() {  }
	  }

	})();

с момента появления es6 стало возможным использовать модули при помощи import/export

в ES6 модуль это отдельеый файл. но также возможно использовать специальную конструкцию:

    module {  // анонимный внутренний модуль
        let tmp = …;  // не станет глобальной
    }

================================
что такое строгий режим?

СР влюучается в скрипте или функции. перед его объявлением не должно быть кода.

СР делает не прощает некоторые неоднозначности в js. например, не разрешает присвоить значение необъявленной переменной(будет ошибка). не разрешает перечилять в объекте свойства с одинаковыми именами. не разрешает использовать некоторые служебные слова, которые зарезервированя для будущего стандарта ES: private, yeld, interface etc.

================================
что такое webassembly?

это бинарный формат, который позволяет браузеру выполнять js быстрее. это не язык программирования, а просто виртуальная машина.

перед разработчиками wasm стоит ряд задач, связанных с безопасностью, кроссплатформенностью и отсустствием потребности использовать что-то кроме браузера. поэтому разработка wasm затянулась.

================================
что такое try/catch/finally?

это блоки для обработки исключений. каждое исключение должно быть  однозначно идентифицировано.ю если этого не произошло, то происходит проброс исключения. это техника, при которой неопознанное исключение из блока catch при помощи throw отправляется во внешний блок try/catch/finally

================================
что такое всплыте/погружение событий в DOM?

в DOM элементы имеют вложенную структуру. при клике на один из внутренних элементов происходит погружение события, а потом всплытие. обработчики работают только со стадией всплытия, но это можно изменить припомощи третьего аргумента addEventListener()

всплытие события можно пректатить на любом уровне при помощи e.stopPropagation(). 

если меню состоит из 10 пунктов, то не обязательно отлавливать клик на каждом из ни. достаточно назначить обработчик внешнему блоку. это называется делегирование событий.

================================
что такое spread и rest операторы?

spread позволяет разобрать перечислимый объект. например можно клонировать массив. или в вызове функции использовать один аргумент, в теле функции он будет разбит на несколько:

	var log = function(a, b, c) {
	  console.log(a, b, c);
	};
	log(...['Spread', 'Rest', 'Operator']);

rest делает обратное. например при помощи него функция может принять один rest-аргумет, но внутри функци разбить его на несколько. при этом отпадает надобность в arguments

	var log = function(a, b, ...rest) {
	  console.log(a, b, rest);
	};

	log('Basic', 'rest', 'operator', 'usage'); // Basic rest ['operator', 'usage']

================================
что такое Деструктурирующее присваивание?

это способ при помощи присвоить отдельным переменным каждое значение из итерируемого объекта.

	let myArray = [1,2,3];
	let [a, b, c] = myArray;
	console.log(a); // 1
	console.log(b); // 2
	console.log(c); // 3

для объекта:

	let myObject = { a: 1, b: 2, c: 3, d: 4};
	let {b, d} = myObject;
	console.log(b); // 2
	console.log(d); // 4

================================
что такое каррирование?

это преобразование функции, которая принимает несколько аргументов к набору функций, каждая из которых принимает по одному аргументу

	function curry(func) {
	  return function curried(...args) {
	    if (args.length >= func.length) {
	    	console.log('first', this)
	      return func.apply(this, args);
	    } else {
	    	console.log('second')
	      return function(...args2) {
	        return curried.apply(this, args.concat(args2));
	      }
	    }
	  };
	}

	function sum(a, b, c) {
	  return a + b + c;
	}
	let curriedSum = curry(sum);
	console.log( curriedSum(1)(2)(3) );

================================
что такое утиная типизация?

это проверка того, что объект реализует определённый интерфейс. при этом он может дополнительно иметь другие методы и свойства.

	def method(obj):
	   obj.start()
При утиной типизации мы не заботимся о типе объекта obj, нам лишь важно, что у него есть метод start. Если же такого метода нет, то исключение нас разочарует.

================================
что такое defer и async?

в процессе загрузки страницы может получиться так, что подключенный скрипт блокирует отрисовку html. чтобы решить эту проблему в элемент скрипта можно добавить атрибут defer. в этом случае скрипты начнут загружаться в фоновом режиме, а запустятся только после того как html отрисован(событие DOMContentLoaded)

также можно пометить скрипт атрибутом async. в этом случае скрипты загружаются в фоновом режиме. порядок не сохраняется. запускаться они будут по мере загрузки.

================================
что такое fetch?

fetch это ещё один способ сделать асинхронный запрос. в ответ приходит промис. таким образом запрос выглядит так:

	fetch('https://api...')
	  .then(response => response.json())

есть возможность отправлять и получать заголовки:

	fetch('https://api...', {
	  headers: {
	    Authentication: 'secret'
	  }
	})
	.then(response => response.headers.get('Content-Type'))

пример post-запроса:

	fetch('https://api...', {
	  method: 'POST',
	  headers: {
	    'Content-Type': 'application/json;charset=utf-8'
	  },
	  body: JSON.stringify(user)
	});

================================
что такое web sockets?

WS это протокол, позволяющий браузеру и серверу поддерживать постоянное соединение. так же как в случае XHR создаётся объект вебсокета, инициализируется адресом и затем слушаются коллбеки.

================================
что такое класс?

класс это новая языковая конструкция, которая появилась в ES6. внутри класс представляет из себя функцию, тело которой состоит из конструктора класса. методы класса сохраняются в prototype. оператор new создаёт объект из конструктора класса с методами из прототипа.

	class User {
	  constructor(name) { this.name = name; }
	  sayHi() { alert(this.name); }
	}

	let user = new User("Иван");
	user.sayHi();	

это то же самое, что и:

	function User(name) {
	  this.name = name;
	}

	User.prototype.sayHi = function() {
	  alert(this.name);
	};

	let user = new User("Иван");
	user.sayHi();

================================
что такое функция? рассказать о this в функции.

функция это конструкция языка. с помощью неё можно создавать переиспользуемые куски кода. функцию можно использовать как конструктор для создания объекта. функцию можно запускать в определённом контексте.

	function User(name) {
	  this.name = name;
	}

	User.prototype.Say = function() {
	  console.log('sss', this.name)
	}

	const f1 = new User('sergey');

	console.log(f1, typeof f1, User.prototype)
	f1.Say()

в примере выше будет создан объект со свойством name и методом Say()

можно функцию f1 запустить в другом контексте:

	const f2 = f1.Say;
	f2.call({name: 'misha'})	

this функции всегда будет браться из контекста.

================================
что такое NaN?

NaN или Not A Number (не число) — это значение, получаемое в результате выполнения числовой операции над нечисловым значением

================================
Как определить наличие свойства в объекте?

	console.log('prop' in o) 

	o.hasOwnProperty('prop2')

	console.log(o['prop'])

================================
Как в JS создать объект?

	Объектный литерал:

	Функция-конструктор:

	Object.create:

================================
В чем разница между оператором «in» и методом hasOwnProperty?

оператор «in» проверяет наличие свойства не только в самом объекте, но и в его прототипах, а метод hasOwnProperty — только в объекте.

================================
Почему 0.1 + 0.2 === 0.3 — это false?

все числа в языке (даже целые) представлены в формате с плавающей запятой (float). эти числа — бесконечные дроби. Для их хранения выделяется ограниченный объем памяти, поэтому возникают подобные неточности.

================================
что такое транспилер и полифилл?

Транспайлер - переписывает новый синтаксис языка в старый.

	// объявление переменных в новом стиле
	const a = `константа`;
	let b = `изменяемая переменная`;

	// приводит к объявлению в старом стиле
	var a = `константа`;
	var b = `изменяемая переменная`;

Полифилл - реализовывает функции из новой версии языка, которых нет в старой

	// проверка является ли arr массивом в новом варианте
	if (Array.isArray(arr) === true) alert('массив!');

	// проверка является ли arr массивом в старом варианте

	// Полифилл функции из "новой" версии для старой "версии" языка
	// (для примера здесь, пропишем прямо в прототип Array)
	Array.__proto__.isArray = function(value) {
	return value instanceof Array;
	};

	if (Array.isArray(arr) === true) alert('массив!');

================================
внедрение зависимостей — это метод, с помощью которого объект получает другие объекты, от которых он зависит, называемые зависимостями, а не создает их сам.

то есть вместо композиции используется более абстрактный подход:

	import { Engine } from './Engine';

	class Car {
	    private engine: Engine;

	    public constructor (engine: Engine) {
	        this.engine = engine;
	    }
	    
	    public startEngine(): void {
	        this.engine.fireCylinders();
	    }
	}



dependency injection делится на 3 вида:

1. constructor injection. в этом случае зависимость передаётся через конструктор класса и далее присваивается свойству класса

class A:
	def __init__(self, logger):
		self.logger = logger

2. method injection. в этом случае зависимость передаётся через метод класса и в большинстве случаев на присваивается свойству класса, но присваивается локальной переменной метода

class A:
	def set_logger(self, logger):
		logger_obj = logger
		logger_obj.write('blabla')

3. property injection. в этом случае зависимость приравнивается свойству объекта

a = A()
a.prop = B()

================================
new Map()

это аналог объекта, но ключаси могут быть любые типы. при итерации порядок ключей сохраняется
в new WeakMap() ключами могут быть только объекты


new Set()

это аналог массива, но все значения уникальны.
в new WeakSet элементами коллекции могут быть только объекты



================================
localStorage одно хранилище для всех вкладок. не очищается после закрытия вкладок или браузера.

sessionStorage хранилище для отдельной вкладки. не очищается после рефреша. очищается после закрытия вкладки или браузера.

================================
пример потери контекста функции:

this.x = 9;
var module = {
  x: 81,
  getX: function() { return this.x; }
};

module.getX(); // 81

var getX = module.getX;
getX(); // 9, поскольку в этом случае this ссылается на глобальный объект

// создаём новую функцию с this, привязанным к module
var boundGetX = getX.bind(module);
boundGetX(); // 81


================
коллбек

  это функция, которая передаётся другой асинхронной функции и запускается на выполнение когда в асинхронной функции будет получен результат. то есть стек вызовов передаёт контекст выполнения очереди, а очередь ОБРАТНО возвращает контекст выполнения стеку.

  для коллбеков существую 2 проблемы:

    1. невозможно точно выстроить их в очередь
    2. если коллбек передаётся в торонний код, то этот код может выполнить коллбек несколько раз. то есть происходит временная передача управление скриптом сторонней программе(инверсия управления).

  промис возвращает только единожды сигнал о завершении асинхронной операции, его коллбеки запускаются со стороны исходного срипта.		

=================
что такое async-await?

	это синтаксический сахар для промисов. конструкция async-await работает как генератор, то есть останавливает свою работу, передаёт выполнение далее по потоку и затем снова получает возможность продолжить.

		const f = async function () {
		  console.log(2);
		  const value = await Promise.resolve('value');
		  console.log(value);
		  console.log(4);
		};

		console.log(1);
		f();
		console.log(3);

		// вывод в консоль: 1 2 3 value 4 

	отлов ошибок делается при помощи try/catch

		const f = async function () {
		  console.log(2);
		  try {
		    const value = await Promise.resolve('value');
		    console.log(value);
		    console.log(4);
		  } catch (error) {
		    console.log('error', error);
		  }
		};

		console.log(1);
		f();
		console.log(3);

		// вывод в консоль: 1 2 3 value 4 

	на async-функцию можно подписаться при помощи then:

		const f = async function () {
		  console.log(2);
		  return await Promise.resolve('value');
		  console.log(4);
		};

		console.log(1);
		f().then(
		  (s) => console.log('s', s),
		  (e) => console.log('e', e)
		);
		console.log(3);	

		// вывод в консоль 1 2 3 s value

=================
пример потери контекста

	this определяется в момент вызова функции. Если записать метод объекта в переменную и вызвать её, значение this изменится.

		const user = {
		  name: 'Alex',
		  greet() {
		    console.log(`Hello, my name is ${this.name}`)
		  },
		}

		const greet = user.greet
		greet()

		// Hello, my name is
  
================================
================================
================================
================================
вопросы из навигатора 
===============================
примитивные и ссылочные типы данных

	объект это ссылочный тип данных. он хранится и сравнивается по ссылке, которая ведёт на место в памяти.

	остальные типы это примитивные типы. они хранятся и копируются по значению.

===============================
мутабельные и иммутабельные типы.

	объект это мутабельный тип это объект потому что можно изменить один из его элементов. 

	примитивные типы все иммутабельны потому что при переназначении возвращают новое значение.

===============================
приведение каких значений при помощи boolean даст false?

	Boolean(false);         // false
	Boolean(undefined);     // false
	Boolean(null);          // false
	Boolean('');            // false
	Boolean(NaN);           // false
	Boolean(0);             // false
	Boolean(-0);            // false
	Boolean(0n);            // false	

	Boolean(true);          // true
	Boolean('hi');          // true
	Boolean(1);             // true
	Boolean([]);            // true
	Boolean([0]);           // true
	Boolean([1]);           // true
	Boolean({});            // true
	Boolean({ a: 1 });      // true	

	оператор !! действует следующим образом: первый знак ! приводит значение к логическому и инвертирует его. Второй оператор ! снова инвертирует полученное значение. 

===============================
что такое NaN?

	это значение, получаемое в результате выполнения числовой операции над нечисловым значением:

		'string' / 4
		'string' * 3

	это значение можно получить, если пытаться привести к числу нечисловое значение:

		Number('123,4') // NaN
		Number(undefined) // NaN

	Number.isNaN() проверяет переданное аргументом значение и возвращает true, если это значение NaN.

===============================
что будет если сложить число и строку, в которой записано число?

	3 + '55' = '355'

===============================
как проверить тип переменной null?

	так как typeof null = Object , то тип проверяется на null:

		1:

			let s = null;
			console.log(s === null);

		2:

			let s = null;
			console.log(Object.is(s, null));

===============================
что такое Symbol?

	примитивный тип данных, значение которого не видно разработчику. к значению можно только обратиться через id. каждое значение уникально (даже если имеют одинаковый id). Символы могут использоваться в качестве имён свойств в объектах. Символы игнорируются циклом for…in

		const sym = Symbol('name')	// аргумент-имя не обязателен, это просто описание
		const symTwo = Symbol('name')
		console.log(sym === symTwo)
		// false

	пример символьного свойства объекта:

		const secondaryId = Symbol()
		const user = {
		  'id': 193,
		  'name': 'Ольга',
		  [secondaryId]: 'olga-1'
		}
		console.log(user[secondaryId])

	существует глобальный реестр символов:

		let id = Symbol.for("id"); // если символа не существует, он будет создан

		Многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.

===============================
особенности JS

	1. однопоточный язык.
	2. работает в различных средах (браузер, нода)
	3. в зависимости от среды имее дополнительное апи. например, в браузере есть setTimeout
	4. в 2015 году вышло большое обновление
	5. использует ООП и возможности функционального программирования
	6. язык с динамической, слабой, неявной типизацией
	7. объекты связаны прототипным наследованием. 
	8. классы это синтаксический сахар для обычных функций

===============================
function declaration va function expression

	FD это объявление типа function Name() {}. оно моментально высплывает на уровне блока, то есть  может быть вызвана раньше, чем она объявлена.

	FE это функция без имени, которая присвоена переменной:

		let f = function() {}

===============================
IIFE

	это функция, которая запускается сразу после объявления:

		(function() {
		    alert("I am an IIFE!");
		}());

	такая функция используется чтобы создать модуль:

		var module = (function () {
		  var name = 'Barry';
		  return { name };
		})();
		console.log(module.name);	

	работает так:

		1. переменной присваиваем результат функции
		2. () это просто знаки группировки, можно обойтись и без них
		3. переменная name не видна за пределами блока. это её область видимости
		4. финальные скобки сразу запускают функцию на исполнение
		5. return предоставляет публичный интерфейс

===============================
что такое коллбеки?

	функции в JS могут принимать и возвращать другие функции. когда функция получает другие функции в качестве аргументов, то она в своём теле может выполнить один из фргументов-функций. в этом случае управление вернётся во внешний код.

===============================
чистая функция

	1. не имеет сайд-эффектов
	2. при получении одинаковых аргументов возвращает одинаковый ответ

	Примеры побочных эффектов:

		Видоизменение входных параметров
		console.log
		HTTP вызовы (AJAX/fetch)
		Изменение в файловой системе
		Запросы DOM

===============================
мемоизация

	это сохранение функцией результатов в кеше. каждый результат помечен индексом. если входящий аргумент совпадает с индексом, то значение отдаётся из кеша.

		function memoizedAddTo80() {
		  let cache = {};
		  return function (n) {
		    if (n in cache) {
		      console.log('cache');
		      return cache[n];
		    } else {
		      console.log('calc');
		      cache[n] = n + 80;
		      return cache[n];
		    }
		  };
		}
		const memoized = memoizedAddTo80();

		console.log(memoized(5));
		console.log(memoized(5));
		console.log(memoized(5));
		console.log(memoized(10));

		// calc cache cache calc

===============================
как сохранить родительский контекст при вызове IIFE?

	IIFE вызывается после объявления в контексте window:

		property1 = 'ffff';
		(function (par1, par2, par3) {
		  console.log(par1, par2, par3);
		  console.log(this.property1);
		})(1, 2, 3);
		// вывод в консоль: ffff

	сохранить контекст можно, используя bind():

		property1 = 'ssss';
		var a = {
		  property1: 'ffff',
		  method1: function () {
		    (function (par1, par2, par3) {
		      console.log(this.property1);
		    }.bind(this)(1, 2, 3));
		  },
		};
		a.method1();	
		// вывод в консоль ffff

	или использовать стрелочную функцию

		var a = {
		  property1: "test",
		  method1: function() {
		    ((par1, par2, par3) => {
		      console.log(this.property1);
		    })(1, 2, 3);
		  }
		};

		a.method1();

===============================
Object.seal()

	запрещает добавление и удаление свойств. при этом менять значение существующих свойств можно.

Object.freeze()

	делает то же что и seal, но при этом невозможно изменить значение существующих свойств.

===============================
дескрипторы объекта

	у объекта есть не только ключ-значение, но и дескриптор, спомощью которого можно:

		1. установить значение
		2. сделать его неперечислимым в цике
		3. запретить его изменение
		4. запретить изменять сам дескриптор

	устанавливается дескриптор так:

		Object.defineProperty(obj, 'a', {
		  enumerable: false,
		});	

	получить значение дескриптора для свойства 'a' можно так:

		Object.getOwnPropertyDescriptor(obj, 'a')	

	вот пример работы этих свойств:

		let obj = {
		  a: 1,
		  b: 2,
		};

		Object.defineProperty(obj, 'a', {
		  enumerable: false,
		});

		let descriptor = Object.getOwnPropertyDescriptor(obj, 'a');

		console.log(descriptor);
		// вывод в консоль: {value: 1, writable: true, enumerable: false, configurable: true}

		for (let k in obj) {
		  console.log(k, obj[k]);
		}

		// вывод в консоль: b 2

===============================
hasOwnProperty()

	проверяет существует ли ключ в объекте и возвращает true/false. в отличие от in не проверяет наличие свойства в цепочке прототипа.

		let obj1 = {
		  a: 1,
		  b: 2,
		};

		let obj2 = {
		  c: 3,
		  d: 4,
		};

		obj2.__proto__ = obj1;

		console.log(obj2.hasOwnProperty('a'), obj2['a']);
		// false 1

		for (let x in obj2) {
		  console.log(x);
		}
		// c d a b

===============================
откуда свойства у всех сущностей?

	в JS все сущности являются объектами. эти объекты имеют иерархию предков. все эти объекты наследуются от Object. 

	срока получает в наследство метод length массив получает в наследство методы push() и т. д.

	когда происходит обращение к свойству/методу примитива, то он оборачивается в обёртку, которая является конструктором, создающим примитив. например для строкового рпимитива это String(). этот конструктор унаследованные имеет методы и свойства.

===============================
собственные объекты vs объекты хоста

	js имеет чётко определённый набор собственных объектов, которые доступны всегда: Math, Date, parseInt, Error и т. д.

	но JS используется в различных окружениях(браузер, node), у каждого из которых определён различный набор объектов хоста: window, document, setTimeout, getElementById  т.д.

===============================
методы массивов

	arr.push(...items) – добавляет элементы в конец,
	arr.pop() – извлекает элемент из конца,
	arr.shift() – извлекает элемент из начала,
	arr.unshift(...items) – добавляет элементы в начало.

	arr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент
	arr.slice([start], [end]) возвращает новый массив, в который копирует все элементы с индекса start до end 
	arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.

	includes()
	forEach()
	map()
	filter()
	reduce()
	find()

	sort получает кастомную функцию сравнения, получающую тоже 2 значения, которая будет возвращать 1, 0, -1

	reverse
	split
	join

===============================
push 

	добавляет элементы в конец массива

unshift

	добавляет элементы в начало массива. этот метод более затратен так какв памяти весь массив придётся сдвинуть по ячейкам, на это требуется больше ресурсов. 

===============================
как работает метод sort()

	если он отрабатывает без аргументов, то все элементы сортируеются на основе кодов символов в строке. 

	если аргументом передаётся функция, то она должна принимать 2 аргумента(a, b), которые будет сравнивать и возвращать:  1 0 -1. для учёт особенностей местного алфавита можно использовать для сравнения:

		'a'.localeCompare('b');

	Для числового сравнения, вместо строкового, функция сравнения может просто вычитать b из a

===============================
метод some()

	 проверяет наличие определённого элемента в массиве и возварщает true/false

		const arr = [1, 2, 3, 4, 5];
		const has = arr.some((x) => x === 2);
		console.log(has);	// true

метод every()

	позволяет узнать удовлетворяют ли все элементы массива условию и возвращает true/false

		const arr = [1, 2, -3, 4, 5];
		const con = arr.every((x) => x > 0);
		console.log(con);	// false

===============================
деструктуризация 

	это присваивание элементов массива или объекта переменным.

	для массива:

		const [a, b] = [1, 2];
		console.log(a, b);  // 1 2

	для объекта:

		const { a, b } = { a: 1, b: 2 };
		console.log(a, b); // 1 2	

		есть возможность переопределить имена переменных: const { a: x, b: y }.

	для строк:

		const [a, b] = 'qwe';
		console.log(a, b); // q w	

===============================
spread vs rest

	spread позволяет передавать итерируемые коллекции как аргументы или добавлять их в новый массив/объект. то есть этот оператор преобразует массив в набор значений.

		function f(a, b) {
		  console.log(a); // 1
		  console.log(b); // 2
		}
		const nums = [1, 2];
		f(...nums);

	или

		const coll = [1, 2];
		const arr = [...coll, 3, 4];
		console.log(arr);

	или 

		const obj1 = { a: 1, b: 2 };
		const obj2 = { c: 3 };
		const obj3 = { ...obj1, ...obj2, d: 4 };
		console.log(obj3);

	rest оператор применяется для того чтобы пометить остаточные параметры функции. например функция вызвана с 4 аргументами, но принимает только 2 именованных:

		function f(a, b, ...c) {
		  console.log(a, b, c);		// 1 2 [3,4]
		}
		f(1, 2, 3, 4);

===============================
ООП

	это подход в написании программ, в котором все сущности представляют из себя объекты со свойствами и методами.

	принципы:

		абстракция - способ выделить главное в объекте и забыть о не имеющем значения для понимания. например, есть объект Чайник, программисту важно знать что его можно включать и выключать, а каким именно способом он нагревает воду, точный вес, прочность и т.д. знать не нужно чтобы пользоваться чайником.

		инкапсуляция - способ ограничить доступ к составляющим объекта. например у чайника публичные методы это включение и выключение, остальные методы скрыты модификаторами доступа private или protected чтобы вредители не смогли попользоваться чайником и, уходя, изменить температуру нагрева до 50 градусов.

		наследование - способ организовывать классы в иерерхию таким образом, что наследник имеет доступ к методам и свойствам родителей. это позволяет избежать дублирования кода. наследование это принцип проектирования "от общего к частному", а композиция это принцип проектирования "от частного к общему". надо наследованию предпочитать композицию потому что не всегда понятно от какого именно родителя насд=логично унаследоваться. например, чайник с таймеров наследовать нужно от чайника или от таймера?

		полиморфизм - это способность метода/класса/функции выполнять различные операции в зависимости от получаемых данных. например объект истории хранит множество объектов типа Расход. но появилась необходимость кроме расходов хранить доходы. в этом случае создаётся класс Record, который принимает аргумент: type, amount. таким образом Record будет полиморфен, то есть в зависимости от аргумента type имеет различное значение и функционал.	

		также примером полиморфизма является:

			'ssssss'.length
			['a', 's', 'd'].length

		length унаследован от Object и обрабатывает строку и массив разными алгоритмами.

===============================
прототип

	это свойство объекта, которое содержит ссылку на родительский объект. таким образом в JS можно реализовать цепочку наследования.

	через прототип невозможно перезаписать свойства родителя.

===============================
в JS наследование одиночное поэтому каждый объект может иметь только один прототип.

===============================
что такое функциональное программирование?

	в ФП все сущности представляются в виде чистых функций, которые принимают стейт и возвращают копию изменённого стейта. эти функции объединяются в композицию потому что являются функциями высшего порядка.

	То есть функция — это отображение входных данных на выходные.

	Чистые функции, которые лежат в основе ФП, надёжны, потому что всегда выдают одинаковый результат при одинаковых входных данных.

	ссылочная прозрачность это возможность заменить вызов чистой функции на конкретный результат.

	При компиляции кода, который обладает ссылочной прозрачностью, некоторые его куски можно «выполнить» заранее и получить готовое значение.

	но создание полных копий стейта требует ресурсов.

	полезные программы не могут существовать без сайд-эффектов поэтому такие эффекты нужно грамотно встраивать в функциональные программы.

===============================
парадигмы программирования:

	1. функциональное программирование (конвейер чистых функций)
	2. ООП (классы аналоги объектов реального мира)
	3. процедурное (много функция, связанных беспорядочно)

===============================
встроенные прототипы

	все объекты объединены в иерархию. все подклассы наследуют методы суперклассов. самый верхний суперкласс это Object.

		любой объект имеет метод toString(), который представляет объект в виде строки.
		любой массив имеет свойство length и метод push(). он перезаписывает метод toString() на свой собственный, которые просто выводит элементы массива через папятую.

	при обращении к свойствам примитивов временно создаётся объект-обёртка, которая предоставляет методы и затем исчезает.

	Встроенные прототипы можно изменять. Например, если добавить метод к String.prototype, метод становится доступен для всех строк:

===============================
что такое ES классы

	это синтаксический сахар, на самом деле классы это функции. конструктор класса это тело функции, а методы класса добавляются через прототип функции.

		function User(name) {
		  this.name = name;
		}

		User.prototype.sayHi = function() {
		  alert(this.name);
		};

		let user = new User("Иван");
		user.sayHi();	

	Классы всегда используют use strict.

===============================
герреты/сеттеры
	
	в объекте есть свойства-данные, а есть свойства-аксессоры, которые являются методами, но вне объекта выглядят как свойства данные.

	при присваивании срабатывает метод set с аргументом. при считывании срабатывает меод get без аргумента.

	свойства-аксессоры применяют для оборачивания свойств-данных. например можно использовать предварительную проверку возраста.

===============================
способы расширения класса

	через наследование. наследовать можно от встроенных классов:

		class PowerArray extends Array {
		  isEmpty() {
		    return this.length === 0;
		  }
		}
		let arr = new PowerArray(1, 2, 5, 10, 50);
		alert(arr.isEmpty()); // false	

	то же самое через прототип:

		Array.prototype.isEmpty = function () {
		  return this.length === 0;
		};
		let arr = new Array();
		console.log(arr.isEmpty());	

	также класс можно расширять через композицию (включение другого класса чере зсвойство):

		class PowerArray {
		  isEmpty(n) {
		    return n.length === 0;
		  }
		}

		class Example {
		  constructor(x) {
		    this.a = new PowerArray();
		  }

		  start(n) {
		    const s = this.a.isEmpty(n);
		    console.log(s);
		  }
		}

		const example = new Example();
		example.start([1, 2]);
			
===============================
статические свойства и методы

	они принадлежат не экземпляру, а именно классу. this там равно конструктору класса. они наследуются через ссылку [[prototype]].

	статические методы используются для того чтобы хранить общий функционал. например, их можно использовать как фабрику экземпляров, которые немного отличаются от обычных экземпляров:

		class Article {
		  constructor(title, date) {
		    this.title = title;
		    this.date = date;
		  }

		  static createTodays() {
		    // помним, что this = Article
		    return new this("Сегодняшний дайджест", new Date());
		  }
		}	

	статические свойства используются для хранения общих констант и могут использоваться статическими методами. статический метод обращается к статическому свойству через this.

		class Money {
		  static rates = {
		    usd: {
		      eur: 0.7,
		    }
		  };

		  static setRate(from, to, value) {
		    this.rates[from][to] = value;
		  }
		}	

===============================
ключевоe слово new

	используется для создания объекта из конструктора. конструктором может выступать функция или класс.

	при использовании new происходит следующее:

		1. Создаётся новый пустой объект, и он присваивается this. (this = {})
		2. в путой объект добавляются свойства через this.
		3. Возвращается объект со свойствами.	

	цель конструкторов - предоставить возможность создания однотипных объектов.

===============================
super используется:

	1. в конструкторе дочернего класса для запуска конструктора родительского класса. super должно использоваться до первого this потому что не смысла объявлять переменную и сразу после этого её заменять на переменную из родителя:

		class Fish {
		  constructor(habitat, length) {
		    this.habitat = habitat
		    this.length = length
		  }
		  
		  renderProperties(element) {
		    element.innerHTML = JSON.stringify(this)
		  }
		}
		class Trout extends Fish {
		  constructor(habitat, length, variety) {
		    super(habitat, length)
		    this.variety = variety
		  }
		  
		   renderPropertiesWithSuper(element) {
		    element.className="green" 
		    super.renderProperties(element);
		  }
		}

	2. для вызова методов родительского класса

		см. пример выше

	3. для связывания объектных литералов (дочерний может вызвать метод родительского)

		var obj1 = {
		  method1() {
		    console.log('method 1');
		  }
		}

		var obj2 = {
		  method2() {
		    super.method1();
		  }
		}

		Object.setPrototypeOf(obj2, obj1);

	4. для вызова статических методов родительского класса

		class Rectangle {
		  static logNbSides() {
		    return 'У меня 4 стороны';
		  }
		}

		class Square extends Rectangle {
		  static logDescription() {
		    return super.logNbSides() + ', равные между собой';
		  }
		}	

===============================
класс это синтаксический сахар над обычной функцикй:

	class Hero {
		constructor(name, level) {
			this.name = name;
			this.level = level;
		}

		// Adding a method to the constructor
		greet() {
			return `${this.name} says hello.`;
	    }
	}	

	то же самое:

	function Hero(name, level) {
		this.name = name;
		this.level = level;
	}

	// Adding a method to the constructor
	Hero.prototype.greet = function() {
		return `${this.name} says hello.`;
	}	

===============================
promise vs async/await

	1. в промисах ошибки отлавливаются при помощи коллбеков, а в async\await при помощи try/catch
	2. запись async/await более напоминает синхронный код, хотя делает в принципе то же, что и промис.
	3. если в случае последовательного исполнения нескольких асинхронных операций происходит ошибка, то async/await предоставляет более подробную информацию.

		const makeRequest = async () => {
		  await callAPromise()
		  await callAPromise()
		  await callAPromise()
		  await callAPromise()
		  await callAPromise()
		  throw new Error("oops");
		}

		makeRequest()
		  .catch(err => {
		    console.log(err);
		    // output
		    // Error: oops at makeRequest (index.js:7:9)
		 })	

===============================
отлов ошибок в цепочках промиса 

	просиходит при помощи второго коллбека error или при помощи блока catch. при этом catch вообще может вернуть промис и работоспособность дальнейшей цепочки восстановится(то же самое можно сделать из коллбека error).

	catch может проверить ошибку через instancof и в зависимости от этого обоработать или пробросить дальше. если она пробрасывается дальше, то следующие блоки then пропускаются, а следующий блок catch срабатывает. 

	в промисе и блоках then/catch всегда есть неявный try/catch. это выражается в том, что если намеренно выбрасывается исключение 

		throw new Error("Ошибка!");

	, то оно заворачивается в reject.

===============================
статические методы класса Promise

	1. Promise.resolve - создаёт успешно выполненный промис
	2. Promise.reject - создаёт неуспешно выполненный промис
	3. Promise.all - получает несколько промисов, ждёт их завершения и отдаёт результаты в виде массива(или ошибку)
	4. Promise.allSettled - то же самое, но результаты отдаются при любом исходе в виде массива с элементами: {status:"fulfilled", value:результат}
	5. Promise.race - получает несколько промисов и ждёт первый выполнившийся(или ошибку)
	6. Promise.any - то же самое, но ждёт только первый успешный промис, ошибка игнорируется

===============================
можно ли отменить выполнение промиса?

	нет

===============================
что такое ajax?

	в одной из версий IE появился объект XMLHttpRequest. от него можно было создать экземпляр и затем повесить обработчики. этот объект стал использоваться для асинхронный действий, например, можно было отправить запрос на сервер, получить успешный ответ и обновить DOM, не перезагружая страницу.

		let xhr = new XMLHttpRequest();

		xhr.onload = function() {
		  alert(`Загружено: ${xhr.status} ${xhr.response}`);
		};

		xhr.onerror = function() { 
		  alert(`Ошибка соединения`);
		};

		xhr.onprogress = function(event) { // запускается периодически
		  alert(`Загружено ${event.loaded} из ${event.total}`);
		};		

	технологии, которые позволяли производить подобные действия называются AJAX. например fetch используется для отправки запросаов, promise для их обработки, js для изменения DOM.

	fetch - это часть браузерного апи. он выполняет запрос на сервер и возвращает промис, которые содержит объект ответа и дополнительные вещи типа статуса:

		let response = await fetch(url);
		if (response.ok) {
		  let json = await response.json();
		} else {
		  alert("Ошибка HTTP: " + response.status);
		}

	или так:

		fetch('http://jsonplaceholder.typicode.com/posts')
		  .then((response) => response.json())
		  .then((data) => data)	

	По умолчанию fetch() запросы не включают в себя cookies 

	axios ещё одна библиотека для работы с запросами. она как и fetch возвращает промис.

		axios.get('/path').then(res => {
		    console.log(res); 
		});

		axios.post('/path', {"Name": "Vova"}).then(res => {
		    console.log(res);	

===============================
чем observable отличается от промиса?

	1. генерирует поток значений, а промис отдаёт только одно значение
	2. observable можно отменить, а промис нельзя
	3. для использования observable нужно подключать библиотеку, а промис это нативная возможность js

===============================
промисификация 
	
	это преобразования асинхронной функции, которая работает на коллбеках в функцию, которая возвращает промис.

	то есть создаётся обертка над оригинальной функцией, эта обёртка возвращает промис, содержащий resolve или reject. 

		было:

			function getData(onSuccess, onError) {
			  setTimeout(function () {
			    const result = Math.random()
			    if (result > 0.5) {
			      onSuccess(result)
			    } else {
			      onError(new Error('Что-то пошло не так'))
			    }
			  }, 1000)
			}

		стало:

			function getData() {
			  return new Promise(function (resolve, reject) {
			    const result = getData(
			      function (result) {
			        resolve(result)
			      },
			      function (error) {
			        reject(error)
			      }
			    )
			  })
			}	

===============================
функция

	это набор последовательных команд, который можно переиспользовать. кроме того функция может содержать свойства (как обычный объект потому что функция это и есть объект), а так же переменный (объявленные через var). к переменным нельзя обратиться извне, а к свойствам можно.

		function foo() {
		  var count = 2;	// переменная
		  foo.count = 1;	// свойство
		  console.log(count); // 2
		  console.log(foo.count); // 1
		}

		foo();

		console.log(foo.count); // 1


================================
================================
================================
основы js
================================
что такое область видимости?

	область видимости это область программы, в пределах которой установлена связь между объявлением переменной и обращением к переменной. 
	Окружение для области видимости — это доступные из текущей области видимости внешние переменные.

	существуют лексические и динамические области видимости.

	  лексическая область видимости (связь между объявлением переменной и обращением к переменной) формируются на этапе лексического разбора, а не на этапе выполнения программы.

	  то есть если разработчик написал функцию IN, которая вложена в функцию OUT, то после запуска программы функция IN всегда будет искать переменную сначала в своей области видимости, а затем в области видимости функции OUT:

	    function OUT() {
	      let a = 1;
	      function IN() {
	        console.log(a);
	      }
	    }

	  динамическая область видимости формируется на этапе выполнения. то есть если вызванная функция на находит переменную, то она будет искать её у функции, которая находится в стеке вызовов ниже:

	    let value = 2;

	    function showValue() {
	     console.log("Value from showValue: " + value); // 3
	    }

	    function wrapper() {
	     let value = 3;
	     console.log("Value from wrapper: " + value); // 3
	     showValue();
	    }

	    wrapper();  

	Область видимости определяет доступность переменных. существует глобальная область видимости и локальная.

	глобально объявленная переменная доступна из любых функций и блоков. переменные, которые объявлены в функциях и блоках недоступны извне. важно понимать, что если переменная не найдена в текущей области видимости, то она ищется во внешней и т.д.

================================
что такое замыкание?

	Замыкание – это способность внутренней функции получить доступ к переенным внешней функции уже после того как внешняя функция отработала.

	понятие замыкания тесно с вязано с понятиями область видимости и лексическое окружение.
	на этапе лексического анализа создаётся объект лексического окружения, который содержит:

		1. все переменные функции с их значениями
		2. ссылку на лексическое окружение, в котором находится её определение.

	таким образом объекты лексических окружений выстраиваются в древовидную структуру. каждый узел этой структуры существует до тех пор пока хотя бы один из дочерних узлов на него ссылается. это ключевой момент.

	далее поиск переменных будет проходить сначала внутри ЛО этой функции, а затем в более внешних ЛО.

	рассмотрим пример:

		function outer() {
			const count = 10;
		  
			return function inner() {
				console.log(count);
			}
		}
		const count = 100;
		outer()();		// output: 10

	суть примера в том, что ЛО функции outer продолжает жить пока на неё ссылается хоты бы одно внутреннее ЛО. и поэтому функци inner будет искать недостающие переменные в ЛО функции outer

	важно понимать, что при каждом запуске одной той же функции создаётся новое ЛО (на основе написанного до запуска программы кода).

	--------------------------
	В C и большинстве других распространенных языков после возврата функции (оператор return или просто окончание работы) все локальные переменные становятся недоступными, так как фрейм стека уничтожается. В JavaScript они остаются в некотором смысле доступными.

	Замыкание — это фрейм стека, который выделяется, когда функция начинает свое работу, и не освобождается после ее возврата

	--------------------------
	в случае с коллбеками замыкания тоже действуют:

		let a = 111;

		function outer(cb) {
		  console.log('outer', a); // 111
		  cb();	// 22
		}

		function bla() {
		  let a = 22;

		  let f = function () {
		    console.log('a=', a); // 22
		  };

		  outer(f);
		}

		bla();

	важно понимать, что замыкания это применение правил области видимости для функции, которая выполняется вне своей лексической области видимости.

	Замыкание — это когда функция может запомнить и иметь доступ к своей лексической области видимости даже тогда, когда она вызывается вне своей лексической области видимости.

=======================
что такое лексическое окружение?

	если область видимости это набор правил, при помощи которых значения переменных ищутся в зависимости от места их объявления, то лексическое окружение это реализация этих правил.    

	технически лексическое окружение представляет из себя объект, который создаётся на этапе написания кода и содержит:

	  1. ссылку на родительское лексическое окружение
	  2. набор переменных и их значений, определённых в функции

	если в результате выполнения программы переменная не найдена в текущем ЛО, то она ищется во внешнем, и т.д.

	ЛО не удаляется сборщиком мусора до тех пока пока хотя бы одно внутреннее ЛО имеет ссылку на него. ЛО формируется на этапе написания кода и не может измениться после запуска программы.

	ЛО это объект, который создаётся для: 

		1. функции , 
		2. для блока (в частности для каждой итерации цикла или блоков тиа if), 
		3. для скрипта 

================================
что такое контекст выполнения функции?

	контекст выполнения это объект, из которого вызванная функция берёт свойства через ссылку this. обычно контекст указывают при вызове так:

	важно понимать, что контекст определяется объектом из котрого ВЫПОЛНЕНА функция, а лексическое окружение определяется функцией, внутри, которой ЗАПИСАНА функция.

	this.внутри функции указывает на контекст объекта, в котором она была выполнена:

		const obj = {
			a: 10,
			inner: function() {
				console.log('inner', this);
			}
		}

		const outer = function() {
			console.log('outer', this);
		}

		outer();							// window
		obj.inner();						// { a: 10, inner: f }
		inner = obj.inner;
		inner();							// window - потеря контекстал

	----------------------------

	привязка this происходит при каждом вызове функции, на основании ее точки вызова.

	точка вызова это место в коде, где была вызвана функция (не там, где она объявлена). точку вызова можно отследить по стеку вызванных функций.

	правила для определения привязанного контекста:

		1. привязка по умолчанию

			когда функция вызывается без применения последующих правил:

				function foo() {
					console.log( this.a );
				}
				var a = 2;
				foo(); // 2		

			важно понимать, что если функция выполнена из глобального уровня, то контекстом будет window или undefined(это зависит от 'strict mode').

		2. неявная привязка

			это когда перед функцией стоит владеющий объект:

				function foo() {
					console.log( this.a );
				}
				var obj = {
					a: 2,
					foo: foo
				};
				obj.foo(); // 2		

		3. явная привязка

			это использование call/apply

				function foo() {
					console.log( this.a );
				}
				var obj = {
					a: 2
				};
				foo.call( obj ); // 2		

			или использование bind

				function foo(something) {
					console.log( this.a, something );
					return this.a + something;
				}
				var obj = {
					a: 2
				};
				var bar = foo.bind( obj );
				var b = bar( 3 ); // 2 3
				console.log( b ); // 5

			по сути это вызов функции, которая внутри себя использует явную привязку

		4. new-привязка

			когда функция вызывается с указанием перед ней new, то:

				1. создаётся пустой объект {}
				2. this = {}
				3. этот объект заполняется через this.a = 123;
				4. функция возвращает сконструированный выше объект

			function foo(a) {
				this.a = a;
			}
			var bar = new foo( 2 );
			console.log( bar.a ); // 2	

=================
что такое стрелочная функция?

	СФ не имеет собственного контекста и ищет контекст вверх по иерархии лексического окружения, к которому принадлежит (но не берётся из объекта, к которому принадлежит потому что у объекта нет лексического окружения). 

	то есть контекст стрелочной функции определяется на этапе лексического анализа, а контекст обычной функции определяется на этапе вызова функции.

	отличия стрелочной функции от обычной.

		1. стрелочная функция не имеет собственного контекста. 
		2. не имеет названия
		3. не имеет псевдомассива arguments
		4. в ряде случаев можно не писать return
		5. Стрелочные функции нельзя использовать с new

		const obj = {
		  a: 10,
		  inner: () => {
		    console.log('inner', this);
		  }
		}

		obj.inner();					// window
		const f = obj.inner;
		f.call({a: 100});				// window

	то же самое для обычной функции:

		const obj = {
		  a: 10,
		  inner: function() {
		    console.log('inner', this);
		  }
		}
	  obj.inner();	// { a: 10, inner: f }

  	-------------------

		let group = {
		  title: "Our Group",
		  students: ["John", "Pete", "Alice"],

		  showList() {
		    this.students.forEach(
		      student => alert(this.title + ': ' + student)
		      // ошибки нет, хотя КАЖЕТСЯ, что СФ выполняется из контекста window
		    );
		  }
		};

		group.showList();	

		-----------------

		function greetWaitAndAgain() {
		  console.log(`Hello, ${this.name}!`)
		  setTimeout(() => {
		    console.log(`Hello again, ${this.name}!`)
		  })
		}

		const user = { name: 'Alex' }

		user.greetWaitAndAgain = greetWaitAndAgain;
		user.greetWaitAndAgain()

		// Hello, Alex!
		// Hello again, Alex!
		// setTimeout принадлежит функции greetWaitAndAgain, а та является частью объекта user. следовательно this стрелочной функции будет ссылаться на user.

================================
что такое промисы?

	промис это объект, который используется для выполнения асинхронного кода. он содержит функцию-экзекутор, которая выполняется сразу после создания промиса. в функции-экзекуторе происходит вызов resolve или reject. затем результат спискается по цепочке подписчиков.

		состояние до выполнения промиса - pending. после выполнения - filfilled или rejected.
		результат до выполнения - undefined. после выполнения value или error.

		console.log(1);
		const p = new Promise((resolve, reject) => {
		  console.log(2);
		  resolve('resolve!');	// reject('reject!');
		  console.log(3);
		});
		console.log(4);

		// вывод консоли будет: 1 2 3 4

	промис отдаёт thenable объект, на который можно подписаться при помощи двух коллбеков:

		p.then(
			success => console.log('success!'),
			error => console.log('error!')
		)

		then можно объединять в цепочки при этом важно помнить, что блок success или error должен вернуть тоже промис иначе в следующем блоке success будет undefined. то есть исполнение в любых случаях пройдёт по всем then в любом случае(даже после catch потому что catch это тот же then, но без первого коллбека).

			new Promise((resolve, reject) => resolve('resolve!'))
			  .then(
			    (success) => {
			      console.log('success!1', success);
			      reject();
			    },
			    (error) => console.log('error!1', error)
			  )
			  // .catch((error) => {
			  //   console.log('catch after 1', error);
			  //   return 444;
			  // })
			  // то же самое, что и...
			  .then(null, (error) => {
			    console.log('error after 1', error);
			    return 444;
			  })
			  .then(
			    (success) => {
			      console.log('success!2', success);
			      return 666;
			    },
			    (error) => console.log('error!2', error)
			  )
			  // finally никак не влияет на цепочку, но может вернуть reject()
			  .finally(() => {
			    console.log('fff');
			    return 777;
			  })
			  .then(
			    (success) => console.log('success!3', success),
			    (error) => console.log('error!3', error)
			  );

				// success!1 resolve!
				// error after 1 ReferenceError
				// success!2 444
				// fff
				// success!3 666

	-----------

	промисификация это переписывание функции, которая принимает 2 коллбека в промис. эта новая функция будет возвращать промис.

		было:

			function getData(onSuccess, onError) {
			  setTimeout(function () {
			    const result = Math.random()
			    if (result > 0.5) {
			      onSuccess(result)
			    } else {
			      onError(new Error('Что-то пошло не так'))
			    }
			  }, 1000)
			}

		стало:

			function getData() {
			  return new Promise(function (resolve, reject) {
			    getData(
			    	result => resolve(result),
			      error => reject(error)
			    )
			  })
			}

	------------

	Promise.all - аналог forkJoin. то есть ждёт завершения всех промисов и возвращает их результаты в виде массива. отклоняется, если хотя бы один из переданных промисов завершится с ошибкой.
	Promise.allSettled - аналог Promise.all, но результат возвращает в виде { status: "fulfilled", value: "^_^" }. не имеет значения завершились промисы успешно или с ошибкой.
	Promise.any - аналог all(), но возвращает значение первого успешно выполненного промиса. завершится с ошибкой, если все переданные промисы завершатся с ошибкой.
	Promise.race - возвращает значение первого выполнившегося промиса даже если он завершился с ошибкой.
	
================================
что такое hoisting?

	hoisting это процесс помещения переменных в лексическое окружение на этапе компиляции и присвоение им значений на этапе выполнения. при этом будет получена ошибка, если на этапе компиляции обратиться к let или const. для var значение будет undefined. function declaration и параметры функции будут доступны сразу.

		function f1() {
		  console.log('before', a);	// output: undefined
		  var a = 100;
		  console.log('after', a);	// output: 100
		}
		f1();

		function f2() {
		  console.log('before', a);	// output: ERROR
		  let a = 100;
		  console.log('after', a);	// output: 100
		}
		f2();

	классы нужно объявлять именно перед созданием инстанса.

	Назначение переменных имеет приоритет перед объявлением функции.
		var double = 22;
		function double(num) {
		  return (num*2);
		}
		console.log(typeof double); // Вывод: number


	Объявление функции имеет приоритет перед объявлением переменной.
		var double;
		function double(num) {
		  return (num*2);
		}
		console.log(typeof double); // Вывод: function

================================
что такое event-loop? как он работает?

	эвент луп(ЭЛ) это цикл, который обрабатывает поступающие в него задачи. задачи могут быть синхронными и асинхронными(событиями). синхронные заполняют стек, а асинхронные попадают в очередь. если к событию не привязан обработчик, то оно не обрабатвается циклом событий.

	когда функция начинает выполнение, то создаётся контекст выполнения. он помещается в стек. если эта функция вызывает другую функцию, то в стек попадает ещё один контекст. таким образом по мере выполнения синхронных задач стек загружается и разгружается.

	когда в стеке нет задач, то начинают выполняться асинхронные задачи из очереди. setTimeout помещает задачу в очередь по прошествиии времени, указанного во втором аргументе.

	любое событие, например клик, помещается в очередь асинхронных событий(если на клик повешен обработчик, конечно же).

	важно понимать, что очерель событий начинает работать только после того как весь код основного скрипта выполнился и поэтому js-движок перешёл в режим ожидания.

	очередь асинхронных событий состоит из микроадач(приоритетных) и макрозадач (не приоритетных). микрозадачи это промисы и события, макрозадачи это setTimeout. существует возможность принудительно микромизировать задачу при помощи queuMicrotask(f).

	после каждой макрозадачи начинается перерисовка экрана. но экран не перерисовывается после каждой микрозадачи, необходимо чтобы все микрозадачи выполнились.

================================
что такое иммутабельность?

	это состояние объекта, в котором его после инициализации невозможно изменить. результатом попытки любого изменения такого объекта будет новый объект. при этом старый объект остаётся без изменений.

	если объект имеет вложенную структуру, то все вложенные объекты, не подвергшиеся модификации, будут переиспользованы.

================================
что такое прототип?

	в js могут быть связаны: 

		1. объекты с объектами
		2. объекты с конструкторами
		3. конструкторы с конструкторами

	связь осуществляется через недоступное разработчику свойство [[prototype]]. таким образом если свойство или метод не найдены в объекте, то оно ищется вверх по цепочке прототипов.

	у конструкторов в отличие от объектов есть свойство prototype, оно представляет из себя объект. по негласному соглашению в него добавляются только методы, а свойства добавляются непосредственно в свойства конструктора.

	потомкам доступно содержимое и свойств родительского конструктора, и свойств родительского прототпа. причем порядок поиска такой:

		1. сначала поиск идёт по свойствам коструктора

			function A() {
			  this.qwe = 222;
			}
			A.prototype.qwe = 111;
			const a = new A();
			console.log(a.qwe);	// 222

		2. затем в свойствах прототипа

			function A() {
			  // this.qwe = 222;
			}
			A.prototype.qwe = 111;
			const a = new A();
			console.log(a.qwe);	// 111

	в js все конструкторы построены в иерархию в виде пирамиды. на самом верху находится конструктор Object(), у него [[prototype]] = null. этот конструктор имеет набор методов, которые доступны всем нижестоящим объектам: toString(), hasOwnProperty(), и т. д.

================================
как перебрать объект?

	// a 1 d 3
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		for (key in obj) {
		  console.log(key, obj[key]); 
		}

	// a 1
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		for (key in obj) {
		  if (obj.hasOwnProperty(key)) {
		    console.log(key, obj[key]); 
		  }
		}

	// a 1
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		const keys = Object.keys(obj);
		keys.forEach((key) => console.log(key, obj[key]));

	// 1
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		const keys = Object.values(obj);
		keys.forEach((value) => console.log(value));	

	// a 1
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		const keys = Object.entries(obj);
		keys.forEach(([key, value]) => console.log(key, value));

	// a 1
		let pro = {
		  d: 3,
		};
		let obj = {
		  a: 1,
		};
		obj.__proto__ = pro;
		const keys = Object.getOwnPropertyNames(obj); // массив перечисляемых и неперечисляемых свойств объекта
		keys.forEach((key) => console.log(key, obj[key]));

===============================
способы создания объекта

	1. var person = new Object();

	2. const obj = {}

	3. var person = Object.create(null);

	4. 
		const Construct = function () {
		  this.name = 'masha';
		};
		const person = new Construct();
		console.log(person);		

================================
способы копирования объектов:

	1. JSON.parse(JSON.stringify(obj))

		глубокая копия. методы не копируются. не работает для циклических объектов. кроме несериализуемых данных: undefined, symbol()

			JSON.parse(JSON.stringify(itemsInCart))


	2. Object.assign

		неглубокая копия. методы копируются

			const a = { name: 'Joe Bloggs' }
			const b = Object.assign(a, { age: 27 });
			console.log(a === b) //=> true

			но

			const a = { name: 'Joe Bloggs' };
			const b = Object.assign({}, a, { age: 27 });
			console.log(a === b); //=> flase		


	3. clone = { ...user };

		неглубокая копия. методы копируются

			const a = { name: 'Joe Bloggs' }
			const b = { ...a, age: 27 };
			console.log(a === b) //=> false		


	4. for (let key in user) {}

		неглубокая копия. методы копируются

			function copy(mainObj) {
			  let objCopy = {};

			  for (let key in mainObj) {
			    objCopy[key] = mainObj[key];
			  }
			  return objCopy;
			}

			const mainObj = {
			  a: function () {
			    console.log(123);
			  },
			  b: 5,
			  c: {
			    x: 7,
			  },
			};

			const copyObj = copy(mainObj);
			console.log(copyObj); // ok
			copyObj.a(); /// 123		


	5. рекурсивный обход

		глубокая рекурсия. методы не копируются

			function isPrimitive(obj) {
			  return (
			    obj == null ||
			    typeof obj === 'number' ||
			    typeof obj === 'string' ||
			    typeof obj === 'boolean'
			  );
			}

			function isArray(obj) {
			  return Array.isArray(obj);
			}

			function isObject(obj) {
			  return obj != null && typeof obj === 'object';
			}

			function deepClone(obj) {
			  if (isPrimitive(obj)) {
			    return obj;
			  } else if (isArray(obj)) {
			    return obj.map((val) => {
			      return deepClone(val);
			    });
			  } else if (isObject(obj)) {
			    let res = {};
			    for (let k in obj) {
			      res[k] = deepClone(obj[k]);
			    }
			    return res;
			  }
			}

			const obj1 = {
			  a: 10,
			  b: [{ a: 1 }, { b: 2 }],
			};

			const obj2 = deepClone(obj1);
			obj1.b[0].a = 100;
			console.log(obj1, obj2);


	6. lodash cloneDeep()

================================
что такое глубокая и мелкая копия объекта?

	если объект состоит из вложенных структур, то при создании копии копируются только приммитивы, а объекты ссылаются на одно и то же место в памяти.

		const itemsInCart = [
		  { product: 'Носки', quantity: 3 },
		  { product: 'Штаны', quantity: 1 },
		  { product: 'Кепка', quantity: 1 },
		];
		const clonedCart = [...itemsInCart];

		itemsInCart[0].quantity = 4;

		console.log(itemsInCart[0].quantity);
		console.log(clonedCart[0].quantity);

	глубокая копия это когда оригинал и копия полностью независимы. мелкая копия это когда копия и оригинал зависимы вложенными структурами.

================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
