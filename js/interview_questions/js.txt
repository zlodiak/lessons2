================================
================================
перечислить типы данных в js

null 
undefined
symbol	// let id = Symbol("id");
bigint	// const bigInt = 1234567890123456789012345678901234567890n;
number
string
boolean
object

================================
чем отличаются _proto_ и prototype

================================
описать hoisting

================================
что такое lexical enviroment?

================================
чем отличаются let, var, const?

================================
что такое:
function delaration
function expression

================================
что такое вычисляемое свойство?

================================
в чём разница между приммитивным и ссылочным типом?

================================
в чём разница между == и ===?

================================
есть ли в js возможность сделать свойство объекта приватным?

================================
Можно ли в js вызвать функцию до ее объявления? Как это работает? 

================================
что делает Object.create()?

// Объект, создаваемый при помощи Object.create(null) не имеет прототипа,
	var data = Object.create(null);
	data.text = "Привет";

================================
как добавить или изменить свойство объекта, не использую точечную нотацию или квадратные скобки?

	const o = {}; // Создаём новый объект
	Object.defineProperty(o, 'a', {
	  value: 37,
	  writable: true,
	  enumerable: true,
	  configurable: true
	});
	// Свойство 'a' существует в объекте o и имеет значение, равное 37

================================
рассказать о клонировании объектов:

1. JSON.parse(JSON.stringify(obj))
глубокая копия. методы не копируются. не работает для циклических объектов.

2. Object.assign
неглубокая копия. методы копируются

3. for (let key in user) {}
неглубокая копия. методы копируются

4. clone = { ...user };
неглубокая копия. методы копируются

5. рекурсивный обход
глубокая рекурсия. методы копируются

	const Y = deepClone(Z);
	function deepClone(obj) {
	  const clObj = {};
	  for(const i in obj) {
	    if (obj[i] instanceof Object) {
	      clObj[i] = deepClone(obj[i]);
	      continue;
	    }
	    clObj[i] = obj[i];
	  }
	  return clObj;
	}
	Y.addnlProp = { fd: 45 };
	console.log('Z object after cloning: ', Z);
	console.log('Y object: ', Y);

================================
что такое замыкание?

Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ даже после того как внешняя функция отработала. 

понятие замыкания тесно с вязано с понятиями область видимости и лексическое окружение.
на этапе выполнения функции для неё создаётся объект лексического окружения, который содержит:
1. все переменные функции
2. ссылку на лексическое окружение, в котором находится её определение.

далее поиск переменных будет проходить сначала внутри ЛО этой функции, а затем в более внешних ЛО.

рассмотрим пример:

	function outer() {
		const count = 10;
	  
		return function inner() {
			console.log(count);
		}
	}
	const count = 100;
	outer()();		// output: 10

суть примера в том, что ЛО функции outer продолжает жить пока на неё ссылается хоты бы одно внутреннее ЛО. и поэтому функци inner будет искать недостающие переменные в ЛО функции outer

важно понимать, что при каждом запуске одной той же функции создаётся новое ЛО.

================================
что такое лексическое окружение?

ЛО это объект, который создаётся для: 
1. функции на этапе выполнения, 
2. для блока кода на выполнения(в частности для каждой итерации цикла или блоков тиа if), 
3. для скрипта на этапе выполнения. 

ЛО состоит из переменных функции/блока и из ссылки на внешнее ЛО.

если в результате выполнения программы переменная не найдена в текущем ЛО, то она ищется во внешнем, и т.д.

ЛО не удаляется сборщиком мусора до тех пока пока хотя бы одно внутреннее ЛО имеет ссылку на него.

================================
что такое hoisting?

hoisting это процесс помещения переменных в лексическое окружение на этапе компиляции и присвоение им значений на этапе выполнения. при этом будет получена ошибка, если на этапе компиляции обратиться к let или const. для var значение будет undefined. function declaration и параметры функции будут доступны сразу.

	function f1() {
	  console.log('before', a);	// output: undefined
	  var a = 100;
	  console.log('after', a);	// output: 100
	}
	f1();

	function f2() {
	  console.log('before', a);	// output: ERROR
	  let a = 100;
	  console.log('after', a);	// output: 100
	}
	f2();

классы нужно объявлять именно перед созданием инстанса.

Назначение переменных имеет приоритет перед объявлением функции.
	var double = 22;
	function double(num) {
	  return (num*2);
	}
	console.log(typeof double); // Вывод: number


Объявление функции имеет приоритет перед объявлением переменной.
	var double;
	function double(num) {
	  return (num*2);
	}
	console.log(typeof double); // Вывод: function

================================
что такое контекст выполнения функции?

контекст выполнения это объект, в контексте которого произошёл вызов функции. обычно контекст указывают при вызове так:
contextObj.funcName();
или
funcName.call(contextObj);

важно понимать, что если функция выполнена из глобального уровня, то контекстом будет window или undefined(это зависит от 'strict mode').

важно понимать, что контекст определяется объектом из котрого ВЫПОЛНЕНА функция, а лексическое окружение пределяется функцией, внутри, которой ЗАПИСАНА функция

this.внутри функции указывает на контекст объекта, в котором она была выполнена:

	const obj = {
		a: 10,
		inner: function() {
			console.log('inner', this);
		}
	}

	const outer = function() {
		console.log('outer', this);
	}

	outer();							// window
	obj.inner();						// { a: 10, inner: f }
	inner = obj.inner;
	inner();							// window

================================
что такое стрелочная функция?

СФ это краткая запись функции. она не имеет arguments. она не имеет имени. не может быть вызвана с new.
она не имеет собственного контекста выполнения. то есть не важно какой объект при вызове ставить перед точкой или в аргументе call(), всё равно она будет иметь this = window или в строгом режиме this = undefined.

	const obj = {
	  a: 10,
	  inner: () => {
	    console.log('inner', this);
	  }
	}

	obj.inner();					// window
	const f = obj.inner;
	f.call({a: 100});				// window

то же самое для обычной функции:

	const obj = {
	  a: 10,
	  inner: function() {
	    console.log('inner', this);
	  }
	}
  	obj.inner();	// { a: 10, inner: f }


================================
что такое IIFE? приведите пример

================================
как можно запретить добавление и удаление свойств объекту?

Object.seal(obj);

================================
как сделать так чтобы свойства объекта стали неизменяемыми и при этом невозможно было ни добавить, ни удалить свойства?

Object.freeze(obj)

================================
что такое Named Function Expression? 

var f = function sayHi(...) { /* тело функции */ };
фцнкция sayHi может вызвать себя изнутри. это может понадобиться при рекурсии.

================================
чем отличаются _proto_ и .prototype?

Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__.

	var animal = {
	  eats: true
	};
	var rabbit = {
	  jumps: true
	};
	rabbit.__proto__ = animal;
	console.log(rabbit.eats)	// true

или 

	var animal = {
	  eats: true
	};
	function Rabbit(name) {
	  this.name = name;
	  this.__proto__ = animal;
	}
	var rabbit = new Rabbit("Кроль");
	console.log( rabbit.eats ); // true

Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.
При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора.

	var animal = {
	  eats: true
	};
	function Rabbit(name) {
	  this.name = name;
	}
	Rabbit.prototype = animal;
	var rabbit = new Rabbit("Кроль"); //  rabbit.__proto__ == animal
	console.log(rabbit.eats)	// true

================================
что такое ад коллбеков?

в js функция может принимать в качестве аргумента другую функцию. а та в свою очередь тоже может принимать функцию и т.д. такой способ написания кода приводит к большой вложенности.

это особенно опасно для асинхронного кода. в этом случае каждая переданная функция будет ждать некоторое время прежде чем запустится на выполнение. при этом основной поток программы уже пошёл дальше и, возможно, запустил ещё несколько асинхронных функций с коллбеками. 

чтобы избежать неоднозначности принято использовать промисы. промисы позволяют выполнять последующий колбек только  после того как отработает предыдущий. при этом визуально вместо лесенки код выстраивается в цепочки(chaining).

вместо промисов можно использовать конструкицию async/await

================================
упорядочены ли ключи в объекте?

если ключи могут быть преобразованы к числу, то упорядочены. в ином случае - нет

================================
чем отличается постфиксный инкремент от префиксного?

постфиксный выполняется поле приравнивания:

	let i = 0;
	let s = i++		// s = 0

	let i = 0;
	let s = ++i		// s = 1	

================================
как js-классу назначить свойства без использования конструктора?

	class MyClass {
	  a = 1;
	  b = 2;
	  c = 3;
	}

	const m = new MyClass();
	console.log(m.b);

================================
в чём разница между Object.assign() и spread-оператором?

spread-оператор всегда создаёт новый объект, а Object.assign лишь мутирует существующий. поэтому в случае со spread-оператором происходит перезапись объекта по ссылке.

	const a = { name: 'Joe Bloggs' }
	const b = { ...a, age: 27 };
	console.log(a === b) //=> false

	const a = { name: 'Joe Bloggs' }
	const b = Object.assign(a, { age: 27 });
	console.log(a === b) //=> true

================================
что такое event-loop? как он работает?

эвент луп(ЭЛ) это цикл, который обрабатывает поступающие в него задачи. задачи могут быть синхронными и асинхронными. синхронные заполняют стек, а асинхронные попадают в очередь. еслик задаче не привязан обработчик, то она не обрабатвается циклом событий.

когда функция начинает выполнение, то создаётся контекст выполнения. он помещается в стек. если эта функция вызывает другую функцию, то в стек попадает ещё один контекст. таким образом по мере выполнения чинхронных задач стек разгружается.

когда в стеке нет задач, то выполняются асинхронные задачи из очереди. setTimeout помещает задачу в очередь по прошествиее времени, указанного во втором аргументе.

================================
что такое модуль?

если подключить скрипт в станицу, то может произойти так, что переменные скрипта заместят переменные страницы(если у них одинаковые названия). чтобы этого не произошло код скрипта помещется в отдельную область видимости. переменные из этой области видимости экспортируеются при помощи return

	var lodash = (function() {

	  var version;
	  function assignDefaults() { ... }

	  return {
	    defaults: function() {  }
	  }

	})();

с момента появления es6 стало возможным использовать модули при помощи import/export

================================
что такое строгий режим?

СР влюучается в скрипте или функции. перед его объявлением не должно быть кода.

СР делает не прощает некоторые неоднозначности в js. например, не разрешает присвоить значение необъявленной переменной(будет ошибка). не разрешает перечилять в объекте свойства с одинаковыми именами. не разрешает использовать некоторые служебные слова, которые зарезервированя для будущего стандарта ES: private, yeld, interface etc.

================================
что такое webassembly?

это бинарный формат, который позволяет браузеру выполнять js быстрее. это не язык программирования, а просто виртуальная машина.

перед разработчиками wasm стоит ряд задач, связанных с безопасностью, кроссплатформенностью и отсустствием потребности использовать что-то кроме браузера. поэтому разработка wasm затянулась.

================================
что такое try/catch/finally?

это блоки для обработки исключений. каждое исключение должно быть  однозначно идентифицировано.ю если этого не произошло, то происходит проброс исключения. это техника, при которой неопознанное исключение из блока catch при помощи throw отправляется во внешний блок try/catch/finally

================================
что такое всплыте/погружение событий в DOM?

в DOM элементы имеют вложенную структуру. при клике на один из внутренних элементов происходит погружение события, а потом всплытие. обработчики работают только со стадией всплытия, но это можно изменить припомощи третьего аргумента addEventListener()

всплытие события можно пректатить на любом уровне при помощи e.stopPropagation(). 

если меню состоит из 10 пунктов, то не обязательно отлавливать клик на каждом из ни. достаточно назначить обработчик внешнему блоку. это называется делегирование событий.

================================
что такое spread и rest операторы?

spread позволяет разобрать перечислимый объект. например можно клонировать массив. или в вызове функции использовать один аргумент, в теле функции он будет разбит на несколько:

	var log = function(a, b, c) {
	  console.log(a, b, c);
	};
	log(...['Spread', 'Rest', 'Operator']);

rest делает обратное. например при помощи него функция может принять один rest-аргумет, но внутри функци разбить его на несколько. при этом отпадает надобность в arguments

================================
что такое Деструктурирующее присваивание?

это способ при помощи присвоить отдельным переменным каждое значение из итерируемого объекта.

	let myArray = [1,2,3];
	let [a, b, c] = myArray;
	console.log(a); // 1
	console.log(b); // 2
	console.log(c); // 3

для объекта:

	let myObject = { a: 1, b: 2, c: 3, d: 4};
	let {b, d} = myObject;
	console.log(b); // 2
	console.log(d); // 4

================================
что такое иммутабельность?

это объект, который после инициализации невозможно изменить. результатом любой модификации будет новый объект.

================================
что такое каррирование?

это преобразование функции, которая принимает несколько аргументов к набору функций, каждая из которых принимает по одному аргументу

	function curry(func) {
	  return function curried(...args) {
	    if (args.length >= func.length) {
	    	console.log('first', this)
	      return func.apply(this, args);
	    } else {
	    	console.log('second')
	      return function(...args2) {
	        return curried.apply(this, args.concat(args2));
	      }
	    }
	  };
	}

	function sum(a, b, c) {
	  return a + b + c;
	}
	let curriedSum = curry(sum);
	console.log( curriedSum(1)(2)(3) );

================================
что такое утиная типизация?

это проверка того, что объект реализует определённый интерфейс. при этом он может дополнительно иметь другие методы и свойства.

	def method(obj):
	   obj.start()
При утиной типизации мы не заботимся о типе объекта obj, нам лишь важно, что у него есть метод start. Если же такого метода нет, то исключение нас разочарует.

================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
