================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
rxjs это библиотека, которая реализует принципы реактивного программирования для js. то есть система обновляется автоматически при изменении потока данных, это достигается подписками. 

библиотека rxjs основана на взаимодействие объектов observable и объектов observer.


const sum = a + b
console.log(sum)
теперь если a или b изменится снова, то sum останется прежним. то есть программисту приходится придумывать механизм отследживания изменения. в реактивном программировании такой проблемы нет потому что используется подписка на поток данных.

================================
в чём отличие merge и concat в rxjs?

================================
в чём отличие of и from в rxjs?

================================
в чём отличие subject и observable в rxjs?

================================
в чём отличие combineLatest и forkJoin в rxjs?

================================
какие спосбы отписки существуют в rxjs?

1.	this.subscription.unsubscribe()

2.	takeUntil(notifier)
    notifier = new Subject();    
    ngOnInit () {
        const observable$ = Rx.Observable.interval(1000);
        observable$.pipe(takeUntil(this.notifier)).subscribe(x => console.log(x));
    }    
    ngOnDestroy() {
        this.notifier.next();
        this.notifier.complete();
    }

3.	.pipe(first())

4.	async pipe для angular
	Interval: {{observable$ | async}}
	

================================
в чём отличие timer и interval?

================================
в чём отличие scan и reduce?

	var obsScan = Observable.from([1,2,3,4,5,6]);
    var count1 = obsScan.scan((acc, one) => acc + one, 0);
    count1.subscribe(x => {
      console.log('scan shows incremental total', x);
    });

    var obsReduce = Observable.from([1,2,3,4,5,6]);
    var count2 = obsReduce.reduce((acc, one) => acc + one, 0);
    count2.subscribe(x => {
      console.log('reduce shows only total', x);
    });

================================
что делает оператор share?

share() преобразует холодный поток в горячий.

	import { of, from, interval } from 'rxjs'; 
	import { map, switchMap, pluck, share, tap } from 'rxjs/operators';
	import { ajax } from 'rxjs/ajax';


	const endpoint = 'https://hacker-news.firebaseio.com/v0/newstories.json?print=pretty';

	const obs1 = interval(4000).pipe(
	  switchMap(
	    () => {
	      return ajax({
	        url: endpoint,
	        responseType: 'json',
	        method: 'GET',
	      })
	    }
	  ),
	  pluck('response'),
	  map(res => res.filter((_, index) => index < 6)),
	  tap((v) => {
	    console.log('tap')
	  }),
	  share(),
	)

	obs1.subscribe(v => {
	  console.log('sib1', v)
	});

	setTimeout(() => {
	  obs1.subscribe(v => {
	    console.log('sub2', v)
	  });
	}, 2000);

если бы в этом примере не было оператора share(), то tap срабатывал бы для каждого подписчика. а сейчас тут он срабатывает один раз для обоих подписчиков.


================================
что такой холодные и горячие observables?

холодные потоки производят всю последовательность данных сами. каждому новому подписчику отдаётся новая отдельная последовательность.

	const s = interval(1000);
	s.subscribe(v => { console.log('first', v); });
	setTimeout(() => {
		s.subscribe(v => { console.log('second', v); });
	}, 2500)

горячие потоки производят последовательность данных не сами, а просто получают их, например, при клике по экрану. горячие потоки отдают каждому новому подписчику одну и ту же последовательность.

	const s = interval(1000);
	s.subscribe(v => { console.log('first', v); });
	setTimeout(() => {
	  s.subscribe(v => { console.log('second', v); });
	}, 2500)  

================================
что такое subject? какие виды subject существуют?

	subject 

		это observable, который может не только отдавать значения, но и принимать. кроме того для каждого нового подписчика он отдаёт не новый поток, а тот же самый.

	behaviourSubject:

		его можно инициализировать значением. кроме того каждому новому подписчику он отдаёт последнее значение.

		const subject = new BehaviorSubject(0);
		subject.subscribe(x => console.log(x)); // в консоли: 0
		subject.next(1); // в консоли: 1
		subject.next(2); // в консоли: 2
		subject.subscribe(x => console.log(x)); // в консоли: 2
		subject.complete();

	asyncSubject:

		отдаёт последнее значение подписчикам только после того как перейдёт в статус complete. в вслучае, если произойдёт ошибка, то подписчики получат только информацию об ошибке.

		const subject = new AsyncSubject();
		subject.subscribe(x => console.log(x));
		subject.next(1);
		subject.next(2);
		subject.complete(); // в консоли: 2

	replaySubject:

		каждому новому подписчику отдаёт все предыдущие значения. причём есть возможность ограничить количество предыдущих значений.

		const subject = new ReplaySubject();
		subject.subscribe(x => console.log(x));
		subject.next(1); // в консоли: 1
		subject.next(2); // в консоли: 2
		subject.subscribe(x => console.log(x));
		// в консоли:
		// 1
		// 2
		subject.complete();


================================
================================
map

	этот оператор работает почти так же как обычный джаваскриптовый map. то есть берёт каждый элемент потока, преобразует его и возвращает тоже поток.
	в джаваскриптовом map элементы результирующего массива можно получить при помощи синтаксиса квадратных скобок, а в реактивном map элементы результирующего потока можно получить при помощи синтаксиса .subscribe()

		const source = from([1,2,3,4,5,6,7]);
		const result = source.pipe(map(v => v+1));
		result.subscribe(v => console.log(v));

================================
concatMap для обработки стримов по очереди;
mergeMap для обработки стримов параллельно;
switchMap если нужно отменять стримы, созданные ранее;
exhaustMap для игнорирования создания новых стримов, если текущий стрим ещё не был завершён;

================================
отличие промиса от observable.

	observable это типизированный объект, который следит за событиями. на него можно подписаться, после этого он начнёт многократно отдавать значения.
	promise тоже следит за событием, но отдаёт результат только один раз.

================================
rxjs common operators

все операторы принимают поток, меняют его внутренности и возвращают изменённый поток чтобы потом можно было на него подписаться при помощи subscribe.

map:
	преобразует каждый элемент последовательности по определённому правилу.

concat:
	объединяет потоки последовательно. то есть по мере их регистрации, ане по мере выполнения.

merge:
	объединяет потоки по мере их выполнения. последовательность регистрации значения не имеет.

	практический пример: есть индикатор загрузки на странице, которая имеет resolver. требуется скрывать и показывать индикатор. дело в том, что резолвер возвращает не значения, а потоки. эти потоки можно привести к булевому типу и при помощи merge создать объединяющий поток, который будет сигнальным.

	  isLoading$!: Observable<boolean>;
	  private _showLoaderEvents$!: Observable<boolean>;
	  private _hideLoaderEvents$!: Observable<boolean>;
	  constructor(private router: Router) {}

	  ngOnInit(): void {
	    this._showLoaderEvents$ = this.router.events.pipe(
	      filter((e) => e instanceof ResolveStart),
	      mapTo(true)
	    );
	    this._hideLoaderEvents$ = this.router.events.pipe(
	      filter((e) => e instanceof ResolveEnd),
	      mapTo(false)
	    );
	    this.isLoading$ = merge(this._hideLoaderEvents$, this._showLoaderEvents$);
	  }
  	

mergeAll:
	если существует поток, элементами которого являются другие потоки, то этот оператор подписывается на каждый внутренний поток, получает его результат и возвращает только внешний поток, содержащий уже не потоки, а результаты. 

	таким образом этот оператор уменьшает вложенность потоков. порядок результатов внутри потока зависит от порядка в котором разрешилась подписка.

		import { interval } from 'rxjs';
		import { map, take } from 'rxjs/operators';
		const int$ = interval(1000).pipe(
		  take(2),
		  map(int => interval(500).pipe(take(3))
		);
		int$.subscribe(console.log);
		// Observable
		// Observable


		import { interval } from 'rxjs';
		import { map, take, mergeAll } from 'rxjs/operators';
		const int$ = interval(1000).pipe(
		  take(2),
		  map(int => interval(500).pipe(take(3)),
		  mergeAll()
		);
		int$.subscribe(console.log);
		// values


concatAll:
	 делает то же самое, но порядок результатов в потоке зависит от регистрации, а не от скорости разрешения подписок.

mergeMap:
	позволяет избежать подписки в подписке. для каждого элемента потока он создаёт новый поток, разрешает его и получает результат. таким образом на выходе получает поток, который содержит набор результатов. на него теперь нужно подписаться только один раз.

	порядок результатов в финальном потоке зависит от того в какой последовательности разрешались внутренние потоки.

	// OuterInterval:   ----o----o----o|
	//                      |    |    | 
	// innerInterval_1:     --0--1--2--3|
	//                           |    |
	// innerInterval_2:          --0--1--2--3|
	//                                |
	// innerInterval_3:               --0--1--2--3|
	//                  ------0--1-02-1302-13-2--3|	

concatMap:
	делает то же самое, но активна всегда только одна подписка. пока она не разрешится не произойдёт следующей подписки. таким образом поледовательно выполнятся все подписки

switchMap:
	похож на mergeMap, но при появлении нового потока внутри основного потока отменяет выполняющиеся в данный момент потоки. таким образом актуален всегда только последний внутренний поток.

exhaustMap:
	то же самое, но делает актуальным только первый поток, а запустившиеся позже отключает.


================================
custom pipe. это функция, которая принимает поток, изменяет его и возвращает поток.

создать пользовательский оператор можно двумя способами:
	1. с использованием pipe второго уровня,
	2. полностью создав новый поток с тремя коллбеками.


1:
	export function hmm(n: number) {
	  console.log(n);
	  return <T>(source$: Observable<T>) => {
	    return source$.pipe(tap(console.log, console.error));
	  };
	}
	 
	const source = of('World').pipe(
	  map((x) => `Hello ${x}!`),
	  hmm(111)
	);
	 
	source.subscribe();


	видно, что hmm это просто функция-обёртка, которая возвращает сам оператор. этото оператор подобен map(x => x + 1). разница только в том, что он принимает поток и обрабатывает его стандартным pipe(tap()).

	при желании в функцию обёртку можно передать аргумент n. в данном примере он передаётся, но не используется.

2:
	function custom() {
	  return (src) => {
	    return new Observable((sub) => {
	      return src.subscribe({
	        next(value) {
	          sub.next(value + '_extra');
	        },
	        error(error) {
	          console.log(error);
	        },
	        complete() {
	          console.log('complete');
	        },
	      });
	    });
	  };
	}

	const obs$ = of(1, 2, 3, 4, 5);

	obs$
	  .pipe(
	    map((x) => x + '___addition'),
	    custom()
	  )
	  .subscribe(console.log);


	  видно, что новый оператор представляет из себя обёртку над new Observable(), в котором происходит: подписка, изменение и next изменённого значения.
	  
================================
чем отличаются merge, mergeAll, mergeMap?

	import { interval, merge } from 'rxjs';
	import { take } form 'rxjs/operators';
	const intA$ = interval(750).pipe(take(3));
	const intB$ = interval(1000).pipe(take(3));
	merge(intA$, intB$)
	.subscribe(console.log);

	-------------
	import { interval } from 'rxjs';
	import { map, take } from 'rxjs/operators';
	const int$ = interval(1000).pipe(
	  take(2),
	  map(int => interval(500).pipe(take(3))
	);
	int$.subscribe(console.log);
	// Observable
	// Observable


	import { interval } from 'rxjs';
	import { map, take, mergeAll } from 'rxjs/operators';
	const int$ = interval(1000).pipe(
	  take(2),
	  map(int => interval(500).pipe(take(3)),
	  mergeAll()
	);
	int$.subscribe(console.log);

	-------------
	import { interval } from 'rxjs';
	import { take, mergeMap } from 'rxjs/operators';
	const int$ = interval(1000).pipe(
	  take(2),
	  mergeMap(int => interval(500).pipe(take(3))
	);
	int$.subscribe(console.log);

================================
================================
observable это поставщик данных.
observer это получатель данных.

  создадим observable

    var observable = Rx.Observable.create(function subscribe(observer) {
      var id = setInterval(() => {
        observer.next('hi')
      }, 1000);
    });

    здесь важно то, что инстанс класс Observable имеет метод subscribe. этот метод получил аргументом функцию, в теле которой происходит генерация значений при помощи .next().

    теперь когда произойдёт подписка:

      observable.subscribe(console.log)

     то метод subscribe будет запускать один из трёх коллбеков:

       next,
       error,
       complete

    , а эти коллбеки будут совершать полезное действие во внешней среде.

================================
forkJoin 
  
  ждёт complete всех внутренних потоков, после этого пакует их последние значенияи в массив и один раз отправляет результат в блок subscribe. 

zip 

  выкидывает упакованные в масиив значения из каждого потока каждый раз как получает по одному значению от каждого из внутренних потоков.

combineLatest

  выкидывает упакованные в масиив значения каждый раз как получает значение хотя бы от одного из внутренних потоков.

throttleTime

  выдаёт значения из источника не чаще определённого интервала времени например значения генерируются каждую секунду, но блок subscribe получает их не чаще чем раз в 2 секунды.

    interval(1000)
      .pipe(throttle((val) => throttleTime(2000)))
      .subscribe((val) => console.log(val));

debounceTime

  блок subscribe получает очередное значение только после того как пройдёт определённое время после последнего полученного значения

    fromEvent(document, 'click')
      .pipe(debounceTime(1000))
      .subscribe((x) => console.log(x));

debounce

	когда приходит новое значение, то запускается вложенный observable, происходит подписка на вложенный observable. когда из вложенного observable приходит значение или комплит, то значение из внешнего observable проходит дальше. при этом, если во время ожидания внутреннего observable приходит из внешнего новое значение, то старое значение исчезает.

	тут больше: https://indepth.dev/reference/rxjs/operators/debounce
      
================================
shareReplay(1) vs share()

	оба этих оператора делают поток горячим, но для новых подписчиков shareReplay(1) сразу отдаёт предыдущее значение.

================================
приведение каждого элемента последовательности к будевому значению

	const number$ = from([null, 2, 1, undefined, 5, false, 6, 7]);
	number$
	  .pipe(
	    filter<number>(Boolean),
	    filter((n) => n % 2 === 0)
	  )
	  .subscribe(console.log);
	// 2 6

конструктор Boolean() приводит любое значение к типу boolean. в данном примере фильтр отсеивает все неиснинные значения

================================
partition оператор

	действует как filter, но по условию не отсеивает, а разбивает на две части все элементы потока. затем обычно при помощи деструктурирующего присваивания эти части приравниваются к переменным.

		const [even, odd] = of(1, 2, 3, 4, 5, 6, 7, 8, 9).pipe(
		  partition((val) => val % 2 === 0)
		);
		even.subscribe((val) => console.log('even', val));
		odd.subscribe((val) => console.log('odd', val));	


================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================

================================
================================