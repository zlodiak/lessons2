done()

	прописывается в обработчике асинхронного события. посылает сигнал таск-раннеру о том, что асинхронная операция закончена.

		it('should wait for this promise to finish', done => {
		  const p = new Promise((resolve, reject) =>
		    setTimeout(() => resolve(`I'm the promise result`), 1000)
		  );

		  p.then(result => {
		    // following will display "I'm the promise result" after 1s
		    console.log(result);

		    // this let your test runner know that it can move forward
		    // because we're done here
		    // the test will take 1s due to the setTimeout at 1000ms
		    done();
		  });
		});

----

async

	прописывается перед асинхронной функцией, тем самым помещая этуфункция в зону. в результате после выполнения функция посылает сигнал таск-раннеру

		it(
		  'should wait for this promise to finish',
		  async(() => {
		    const p = new Promise((resolve, reject) =>
		      setTimeout(() => resolve(`I'm the promise result`), 1000)
		    );

		    p.then(result =>
		      // following will display "I'm the promise result" after 1s
		      console.log(result)
		    );

		    // notice that we didn't call `done` here thanks to async
		    // which created a special zone from zone.js
		    // this test is now aware of pending async operation and will wait
		    // for it before passing to the next one
		  })
		);

----

fakeAsync 

	прописывается перед асинхронной функцией. работает подобно async, но позвонляет экономить время, которое тратится на асинхронные операции при помощи flush(). то есть flush() полностью очищает очередь макрозадач.

		it(
		  'should wait for this promise to finish',
		  fakeAsync(() => {
		    const p = new Promise((resolve, reject) =>
		      setTimeout(() => resolve(`I'm the promise result`), 1000)
		    );

		    // simulates time moving forward and executing async tasks
		    flush();

		    p.then(result =>
		      // following will display "I'm the promise result" **instantly**
		      console.log(result)
		    );

		    // notice that we didn't call `done` here has there's no async task pending
		  })
		);	

----

flush() 

	полностью очищает очередь макрозадач и возвращает количесвто микросекунд, которое было в очереди.

      	it('should flush multiple tasks', fakeAsync(() => {
           let ran = false;
           let ran2 = false;
           setTimeout(() => { ran = true; }, 10);
           setTimeout(() => { ran2 = true; }, 30);

           let elapsed = flush();

           expect(ran).toEqual(true);
           expect(ran2).toEqual(true);
           expect(elapsed).toEqual(30);
         }));	

----

tick()

	переводит часы вперёд на заданное количество миллисекунд, тем самым выполняя все макротаски, которые принадлежат этому временному отрезку.

	если аргумент не передан, то часы переводятся на нулевую величину.

	tick() действует только в контексте fakeAsync

	второй аргумент отвечает за разрешение запускать вложенные асинхронные операции.

	функция обязательно должны быть предварена fakeAsync

=====================================
configureTestingModule

	создаёт и конфигурирует ngModule. то есть среду, в которой будут выполняться тесты. обычно используется в beforeEach


compileComponents

	связывается шаблон и стили с созданным компонентом.

createComponent

	создаёт компонент, который состоит из инстанса класса и соответствующего ему шаблона.

inject

	инжектирует сервис из текущего уровня инжектора.

nativeElement

	корневой элемент шаблона компонента

fixture.whenStable()

	возвращает промис, который разрешается после того ак очередь макрозадач полностью ощичается.

=====================================

CUSTOM_ELEMENTS_SCHEMA

	позволяет избежать ошибок, связанных с присутствием в шаблоне кастомных тегов компонентов. то есть эти теги являются зависимостями, которые не обязательно мокатьь

		@NgModule({
		    declarations: [ HeaderComponent ],
		    bootstrap:    [ HeaderComponent ],
		    imports: [ RouterModule, CommonModule, FormsModule ],
		    schemas: [ CUSTOM_ELEMENTS_SCHEMA ]
		})
		export class HeaderModule { }	

----

NO_ERRORS_SCHEMA

	действует так же, но просто срывает сообщения об ошибках

=====================================
если нужно проверить промис, то перед функцией ставим async, а внутри функции await. кроме того можно внутри функции использовать try/catch для вывода осмысленного сообщения об ошибке.

----

второй способ протестировать промис это написать .then() внутри тела текста. в этом .then() нужно прописать expect. при этом нужно не забыть поставить return внутри it

ошибка тестируется так же, но во втором коллбеке блока .then()

----

промис можно тестировать при помощи done(). для этого done нужно передать в it вторым аргументом и затем использовать done() в асинхронном блоке(например в then)

----

для тестирования observable и subject тоже можно использовать done

=====================================
можно использовать clock() чтобы имитировать её мгновенно fcby[hjyye. pflth;re.

	jasmine.clock().install()
	вызов асинхронной функции
	jasmine.clock().tick(60000);
	проверка ожиданий
	jasmine.clock().uninstall()

=====================================
вообще, можно тестировать код средствами jasmine и anguler.testbed

whenStable() дожидается выполнения всех асинхронных операций в очереди. он обязательно должен использоваться с waitForAsync

=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================
=====================================