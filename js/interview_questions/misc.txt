какие книги прочитал в последнее время?

	Эффективный TypeScript: 62 способа улучшить код.
		подробно рассказывается о системе типов. о дженериках. разных вариантах защитников типов.  описывается разница между типами и интерфейсами.

	Reactive Programming with RxJS. sergi mansilla
		рассматриваются основы rxjs. а также паттернов observer и iterator, которые лежат в основе этой библиотеки. приводится пример графической игры-стрелялки.

	рефакторинг. мартин фаулер
		выборочно

	сайт learn.javascript.ru

	rxjs-in-action. paul daniels, luis atencio
		расказывается об основах: синхронных и асинхронных потоках, функциональном подходе в контексте rx. сравниваются промисы и реактивный подход. рассматриваются различные способы отлова исключений.	

===============================
что изучил в последнее время?

	синтаксис async/await
	до этого использовал только промисы

	git rebase

	providers в angular

	grid css

	автономные компоненты в angular

===============================
какие ресурсы регулярно посещаете?

	learn.javascript.ru

	MDN: developer.mozilla.org

	дока


===============================
С какими техническими сложностями вы сталкивались в последнее время и как решили эту задачу?

	построить архитектуру для множества однотипных страниц, которая исключала бы дублирование кода.

	дублирование запросов при использовании asyncPipe без rxJs-share()

	нужно было наложить затемнение на правую часть горизонтального меню, но чтобы при этом все кнопки оставались кликабельными. я при помощи абсолютного позиционирования и наложил градиентный блок и прописал css-правило pointer-events


	добавить bearer для того чтобы сервер смог подтвердить смену пароля 


===============================
что делать, если увидел плохой кусок кода, который не относится к твоей задаче?

	1. сказать об этом на дейли и поместить в беклог
	2. предложить тимлиду отдать эту задачу тебе
	3. если задача совсем мелкая, то исправить самому

===============================
как оценить задачи, если несколькок раз сроки были сорваны?

	1. узнать список трудных для конкретного разработчика тем и далее назначать их другому разработчику.
	2. уволить разработчика
	3. увеличить частоту отчётов для конкретного разработчика

===============================
типы задач, которые приходилось решать?

	работа с API яндекс карт.
	доработка авторизации для входа в интернет-банк.
	вывод статистики при помощи библиотеки D3.
	разработка PWA
	реализация пуш-уведомлений.
	разработка системы управления заявками.
	написание тестов по безопасности js-приложений.

===============================
наиболее интересная задача.

	разработка виджета на основе яндекс карт. виджет отображал различные данные, полученные при помощи алгоритмов машинного обучения.

===============================
SOLID

1. принцип единой ответственности
	Класс должен иметь только одну ответственность. ("Класс должен иметь одну и только одну причину для изменений").

	например, есть класс, который описывает данные пользователя. если этот класс включает правила валидацтт email тоже, то этот класс нарушает принцип. 

	нужно вынести правила валидации email в отдельный класс.

2. принцип открытости-закрытости
	Программные сущности должны быть открыты для расширения и закрыты для модификации.

	например есть функция, которая на основе полученного экземпляра класса вычисляет площать фигуры. эта функция при помощи блока if определяет фигуру и вычисляет результат. проблема в том, что если появится новая фигура, то придётся изменять уже написанный функционал. 

	здесь необходимо в каждый класс фигуры добавить метод getArea. таким образом придётся функция будет вызывать метод получения площади у любого полученного экземпляра.

3. принцип подстановки Барбары Лисков.
	Необходимо, чтобы подклассы могли бы служить заменой для своих родительских классов.

	в предыдущем примере функция получала инстанс фигуры для вычисления площади. должно быть так чтобы она могла принимать любой инстанс, который реализует класс фигуры.

4. принцип разделения интерфейсов.
	Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.

	если есть несколько классов фигур и требуется описать их при помощи интерфейсов, то создавать один жирный интерфейс будт неправильно. нужно создать несколько и класс каждый фигуры имплементировать от нескольких мелких.

5. принцип инверсии зависимостей
	стараться использовать в качестве зависимостей интерфейсы а не конкретные их реализации. или модули верхних уровней не должны зависеть от модулей нижних уровней, оба типа модулей должны зависеть от абстракций.

	например, пусть компонент ангулара инжектирует сервис. внутренняя рализация сервиса может быть любой, но он реализует определённый интерфейс. реализация на низком уровне может измениться, но если интерфейс остался прежним, то компонент не почувствует разницы. потому что он не зависит от конкретной реализации.


	
===============================
===============================
===============================
===============================
===============================
===============================
===============================
===============================
===============================
===============================
===============================
===============================
===============================