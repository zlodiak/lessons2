================================
================================
описать паттерн декоратор

================================
что такое:
динамическая типизация,
	Статическая определяется тем, что конечные типы переменных и функций устанавливаются на этапе объявления. 
	В динамической типизации все типы выясняются уже во время выполнения программы.

сильная типизация,
	Сильная типизация выделяется тем, что язык не позволяет смешивать в выражениях различные типы и не выполняет автоматические неявные преобразования, например нельзя вычесть из строки множество.

явная типизация
	тип новых переменных / функций / их аргументов нужно задавать явно.

================================
что такое итератор

================================
что такое генератор

================================
что такое геттеры и сеттеры 

это методы установки и получения, которые привязаны к определённому свойству объекта. они срабатывают, когда пользователь работает со свойством.

	let user = {
	  name: "John",
	  surname: "Smith",
	  get fullName() {
	    return `${this.name} ${this.surname}`;
	  }
	};
	alert(user.fullName); // John Smith

================================
рассказать об основных принциипах ООП

Инкапсуляция — ограничение доступа к составляющим объект компонентам.
инкапсуляция  в js действует только на уровне соглашений. но в ES6 появился знак #, при помощи которого можно установить приватность переменной или метода.

наследование связывает классы. при этом потомок содержит все методы и свойства родителя.
самый верхний объект для классов это object. 

полиморфизм это когда в различных классах методы с одинаковыми названиями выполняют различные действия.

	'qwerty'.length
	6
	[1, 2, 3, 4].length
	4

================================
чем отличаются функциональный и ОО-подход?

в ООП все сущности представляются в виде объектов, которые похожи на объекты реального мира. они имеют свойства и методы. могут наследоваться и устанавливать правила доступа к своим составляющим.

в ФП все сущности представляются в виде чистых функций, которые принимают стейт и возвращают копию изменённого стейта. эти функции объединяются в композицию потому что являются функциями высшего порядка.

================================
что такое чистая функция?

это функция, которая:
1. при одинаковых входных параметрах всегда возвращает один и тот же результат.
2. которая не использует и не изменяет внешние переменные. не имеет сайд-эффектов

================================
описать формирование запросов после того как пользователь введёт адрес в адресную строку

Чтобы отобразить веб страницу, браузер отправляет начальный запрос для получения HTML-документа этой страницы. После этого браузер изучает этот документ, и запрашивает дополнительные файлы, необходимые для отбражения содержания веб-страницы (исполняемые скрипты, информацию о макете страницы - CSS таблицы стилей, дополнительные ресурсы в виде изображений и видео-файлов), которые непосредственно являются частью исходного документа, но расположены в других местах сети. Далее браузер соединяет все эти ресурсы для отображения их пользователю в виде единого документа — веб-страницы.

после ввода адреса в адресную строку формируется запрос, который состоит из 3 составляющих: 
	метод, 
	путь к ресурсу, 
	версия http-протокола,
	заголовки запроса,
	тело запроса (присутствует на всегда, зависит от метода запроса)

ответ сервера содержит: 
	версию http-протокола, 
	код ответа, 
	человекточитаемый статус ответа, 
	заголовки ответа, 
	тело ответа (присутствует на всегда, зависит от метода запроса)

Пример запроса:
    GET http://ya.ru/index.html HTTP/1.1

Пример ответа:
    HTTP/1.1 200 Ok


методы:
	OPTIONS - используется для проверки возможностей сервера. в частности для случая кроссдоменных запросов.
	GET - Используется для запроса содержимого указанного ресурса.
	HEAD - Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело.
	POST - предназначен для передачи данных на сервер. при повторении не обязательно возвращает одинаковые результаты. в контексте REST используется для изенения данных. предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого.
	PUT - 
	PATCH - 
	DELETE - удаляет ресурс.


Код состояния информирует клиента о результатах выполнения запроса. 
	1** - информационный
	2** - успешно
	3** - редирект
	4** - ошибка на строне клиента
	5** - ошибка на стороне сервера

	200 - ОК
	404 - not found
	401 - запрещено
	500 - ошибка сервера


Заголовок HTTP (HTTP Header) — это строка в HTTP-сообщении, содержащая разделённую двоеточием пару вида «параметр-значение

HTTP-заголовки разделяются на четыре основных группы:
General Headers (Основные заголовки) — должны включаться в любое сообщение клиента и сервера.
Request Headers (Заголовки запроса) — используются только в запросах клиента.
Response Headers (Заголовки ответа) — присутствуют только в ответах сервера.
Entity Headers (Заголовки сущности) — сопровождают каждую сущность сообщения.

Присутствие тела сообщения в запросе отмечается добавлением к заголовкам запроса поля заголовка Content-Length или Transfer-Encoding.

================================
рекурсия это когда функция вызывает саму себя. существует тип рекурсии когда две функции вызывают друг-друга по очереди.

	function sum(num){
	     if (num === 0) {
	         return 0;
	     } else {
	         return num + sum(--num)
	     }
	 }
	 sum(4);     //10

чтобы рекурсия не ушла в бесконечный цикл необходимо внутри рекурсивной функции определить условие выхода. в примере выше это проверка на ноль входящего параметра.

для случая хвостовой рекурсии используется второй аргумент, в октором происходит аккумуляция значений. при этом первый аргумент используется в качестве счётчика. как только счётчик достигает нуля(базового случая), то рекурсивная функция заканчивает работу и возвращает значение второго аргумента

	function tailrecsum(x, running_total=0) {
	    if (x===0) {
	        return running_total;
	    } else {
	        return tailrecsum(x-1, running_total+x);
	    }
	}

	// tailrecsum(5, 0)
	// tailrecsum(4, 5)
	// tailrecsum(3, 9)
	// tailrecsum(2, 12)
	// tailrecsum(1, 14)
	// tailrecsum(0, 15)
	// 15

================================
что такое О-большое?

О даёт представление насколько сложен алгоритм по отношению к входным данным. или это максимальное количество действий, которое совершит процессор для определённой операции.

например для того чтобы добавить в конец массива значение нужно одно действие О(1). а для того чтобы вставить значение в любое место массива нужно совершить О(n) действий, где n это количество элементов массива.

для объекта вставка будет описываться О(1) потому что ключи объекта не упорядочены.

сортировка обычно описывается значением О(n*n). но это зависит от алгоритма сортировки, бывает, что О(log(n))

чтобы посчитать О-большое для определенной программы, нужно напротив каждой строки написать О и в результате определить наихудшее О

================================
что такое rest архитектура?

rest это архитектурный стиль взаимодействия между компонентами распределённой системы. например клиент и сервер физически находятся в разных местах. обмен сигналами происходит через http-запросы. для клиента это значит, что если он хочет отправить сигнал на сервер, то должен будет использовать запрос, сформированный с url строго определённого типа.

действие запроса определяется тем какой он использует метод: get, post, delete put и т.д. некоторые из методов предполагают отправку данных(post), некоторые просто посылают сигнал(delete). 

например:
delete book/3 удаляет запись, соответствующую книге №3.
post book/3 записывает данные в книгу №3. при этом сами данные отправляются в теле запроса.

принципы:
клиент сервер разделены.
каждый запрос должен содержать в себе всю необходимую информацию потому что http не сохраняет состояние.
необходимо использовать кеширование для большей эффективности.
клиент может запрашивать скрипты и выполнять их. 

================================
что такое браузерное кеширование? как оно работает?

при первом запросе страницы клиент получает с сервера кроме самой страницы ещё заголовок Cache-Control, в котором указано сколько секунд ресурс на сервере не изменится. и контрольную сумму, которую сервер вычислил для отправляемой странички. в следующем запросе этого ресурса клиент сначала посмотрит кеш:
1. в случае если время, указанное в Cache-Control не истекло, то страница возьмётся из кеша браузера, а запрос не будет отправлен
2. в случае если время, указанное в Cache-Control истекло, то клиент в запросе, кроме всего прочего, отправляет контрольную сумму. сервер её сверяет и если она не изменилась, то он возвращает код 304. при этом клиент берёт страницу опять из кеша.

таким образом кеширование или вобще не отправляет запрос или отправляет, но получает ответ без тела, но с заголовком.

================================
чо такое кроссдоменный запрос? описать трудности и этапы.

js позволяет делать ajax-запросы. но если запрос идёт на другой домен, то сервер должен дать явное согласие чтобы обработать такой запрос. для этого клиент перед основным запросом отправляет OPTIONS-запрос, в заголовках которого перечисляет методы и заголовки, которые будет использовать:
Access-Control-Allow-Methods,
Access-Control-Allow-Headers

сервер может ответить согласием. в этом случае он вернёт список разрешённых методов и заголовков в:
Access-Control-Request-Method,
Access-Control-Request-Headers

после этого может отправиться основной запрос.

================================
что такое jsonp?

это способ загрузить json с другого домента. как известно, CORS этого не разрешает. но если динамически создать элемент script и в его scr поместить запрос, то кроссдоменный запрос отработает без проблем.

важно то, что к url нужно в виде get-параметра добавить коллбек, который выполнится сразу полу получения данных:

	var s = document.createElement("script");
	s.src = "demo_jsonp2.php?callback=myDisplayFunction";
	document.body.appendChild(s);

	function myDisplayFunction(myObj) {
		console.log(myObj.name);
	}

================================
что такое dom?

dom это представление html-дерева документа в виде объекта. при этом, если в html есть ошибки(например отсутствуют html, body), то dom исправляет их.

dom имеет api например можно создать элемент и добавить его в dom. при этом дерево html не изменится.

================================
что такое shadow dom?

SD это изолированное от DOM дерево элементов, которое существует внутри хост-элемента, и на которое не распространяется действие css-стилей. примером host-элемента может служить <input type="range">

чтобы управлять SD нужно использовать JS. например при помощи JS можно добавить элементы в SD, в том числе элементы style.

если внутри host-элемента существует обычные элементы и SD-элементы, то отображаются только SD-элементы. а обычные элементы представляют собой fallback для случая отсутствия SD-элементов.

в chrome dev tools можно включить отображение SD, если зайти в настройки и выбрать "show user agent shadow dom"

события из SD могу всплывать в DOM, это регулируется специальными флагами. при этом event.target изменяется, если клик произошёл на SD-элементе, но не меняется если клик произошёл на обычном элементе, который находится внутри SD-элемента.

================================
что такое indexDB?

это браузерная БД, в которой вместо таблиц используются хранилища, представляющие собой набор записей типа ключ:значение. транзакции поддерживаются. вместимость indexDB больше чем у кук и стораджей.

================================
что такое graphQL?

это дополнительный слой абстракции между клиентом и сервером. он представляет из себя синтаксис, с помощью которого можно агрегировать запросы из разных источников. при этом запросы могут иметь имена и переменные. кроме того graphQL это типизированный язык, поэтому узнать корректен запрос или нет можно ещё до отправки его.

чтобы пометить поле определённым типом нужно в схеме указать соответствие полей типам:

	type User {
	  id: ID!
	  name: String!
	  email: String!
	  age: Int
	}

например, данные о постах хранятся в mysql, а данные о лайках - в redis. чтобы отобразить страницу с постами в случае rest api приходилось бы делать в два раза больше запросов чем в случае с graphQL.


================================
в чём отличие scrum и kanban?

в канбане нет временных пределов, в пределах которых нужно выполнить задачу. в канбане просто задачи двигаются по доске, а разработчики переключаются с них в зависимости отприоритетов

канбан позволяет добавлять новые задачи на любом этапе разработки

канбан не требует ежедевных митингов

в канбан не обязательно делать оценку задач(хотя, можно)


================================
что такое viewport?

из-за того, что у смартфонов и планшетов экраны малого размера, страницы в них могут отображаться некорректно. при помощи viewport можно задать правила для отображения страниц, выходящих за пределы экрана. например, можно всю страницу поместить в пределы экрана смартфона и затем изменять её масштаб по мере надобности. или можно отобразить часть этой страницы и пользоваться только скроллом

================================
================================
================================
================================
================================
================================
================================
