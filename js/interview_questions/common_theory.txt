================================
================================
описать паттерн декоратор

================================
что такое:
динамическая типизация,
	Статическая определяется тем, что конечные типы переменных и функций устанавливаются на этапе объявления. 
	В динамической типизации все типы выясняются уже во время выполнения программы.

сильная типизация,
	Сильная типизация выделяется тем, что язык не позволяет смешивать в выражениях различные типы и не выполняет автоматические неявные преобразования, например нельзя вычесть из строки множество.

явная типизация
	тип новых переменных / функций / их аргументов нужно задавать явно.

================================
что такое итератор

================================
что такое генератор

================================
что такое геттеры и сеттеры 

это методы установки и получения, которые привязаны к определённому свойству объекта. они срабатывают, когда пользователь работает со свойством.

	let user = {
	  name: "John",
	  surname: "Smith",
	  get fullName() {
	    return `${this.name} ${this.surname}`;
	  }
	};
	alert(user.fullName); // John Smith

================================
рассказать об основных принциипах ООП

	Инкапсуляция — ограничение доступа к составляющим объект компонентам.
	инкапсуляция  в js действует только на уровне соглашений. но в ES6 появился знак #, при помощи которого можно установить приватность переменной или метода.

	наследование связывает классы. при этом потомок содержит все методы и свойства родителя.
	самый верхний объект для классов это object. 

	полиморфизм это когда в различных классах методы с одинаковыми названиями выполняют различные действия.

		'qwerty'.length
		6
		[1, 2, 3, 4].length
		4

	в TS инкапсуляция реализована при помощи модификаторов доступа: public, private, protected.
	В TypeScript наследование реализуется с помощью ключевого слова extends
	в TS полиморфизм доступен через несколько объявлений одной функции о одной реализации с максимально общим типом:
		function add(x: string, y: string): string;
		function add(x: number, y: number): number;
		function add(x: any, y: any): any {
		    return x + y;
		}
		 
		let result1 = add(5, 4);      // 9
		let result2 = add("5", "4");  // 54

================================
чем отличаются функциональный и ОО-подход?

в ООП все сущности представляются в виде объектов, которые похожи на объекты реального мира. они имеют свойства и методы. могут наследоваться и устанавливать правила доступа к своим составляющим.

в ФП все сущности представляются в виде чистых функций, которые принимают стейт и возвращают копию изменённого стейта. эти функции объединяются в композицию потому что являются функциями высшего порядка.

================================
что такое чистая функция?

это функция, которая:
1. при одинаковых входных параметрах всегда возвращает один и тот же результат.
2. которая не использует и не изменяет внешние переменные. не имеет сайд-эффектов

================================
HTTP. описать формирование запросов после того как пользователь введёт адрес в адресную строку

	Чтобы отобразить веб страницу, браузер отправляет начальный запрос для получения HTML-документа этой страницы. После этого браузер изучает этот документ, и запрашивает дополнительные файлы, необходимые для отбражения содержания веб-страницы (исполняемые скрипты, информацию о макете страницы - CSS таблицы стилей, дополнительные ресурсы в виде изображений и видео-файлов), которые непосредственно являются частью исходного документа, но расположены в других местах сети. Далее браузер соединяет все эти ресурсы для отображения их пользователю в виде единого документа — веб-страницы.

	после ввода адреса в адресную строку формируется запрос, который состоит из 3 составляющих: 
		метод, 
		путь к ресурсу, 
		версия http-протокола,
		заголовки запроса,
		тело запроса (присутствует на всегда, зависит от метода запроса)

	ответ сервера содержит: 
		версию http-протокола, 
		код ответа, 
		человекточитаемый статус ответа, 
		заголовки ответа, 
		тело ответа (присутствует на всегда, зависит от метода запроса)

	Пример запроса:
	    GET http://ya.ru/index.html HTTP/1.1

	Пример ответа:
	    HTTP/1.1 200 Ok


	методы:
		OPTIONS - используется для проверки возможностей сервера. в частности для случая кроссдоменных запросов.
		GET - Используется для запроса содержимого указанного ресурса.
		HEAD - Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело.
		POST - предназначен для передачи данных на сервер. при повторении не обязательно возвращает одинаковые результаты. в контексте REST используется для изенения данных. предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого.
		PUT - 
		PATCH - 
		DELETE - удаляет ресурс.


	Код состояния информирует клиента о результатах выполнения запроса. 
		1** - информационный
		2** - успешно
		3** - редирект
		4** - ошибка на строне клиента
		5** - ошибка на стороне сервера

		200 - ОК
		404 - not found
		401 - запрещено
		500 - ошибка сервера


	Заголовок HTTP (HTTP Header) — это строка в HTTP-сообщении, содержащая разделённую двоеточием пару вида «параметр-значение

	HTTP-заголовки разделяются на четыре основных группы:
	General Headers (Основные заголовки) — должны включаться в любое сообщение клиента и сервера.
	Request Headers (Заголовки запроса) — используются только в запросах клиента.
	Response Headers (Заголовки ответа) — присутствуют только в ответах сервера.
	Entity Headers (Заголовки сущности) — сопровождают каждую сущность сообщения.

	Присутствие тела сообщения в запросе отмечается добавлением к заголовкам запроса поля заголовка Content-Length или Transfer-Encoding.

================================
рекурсия это когда функция вызывает саму себя. существует тип рекурсии когда две функции вызывают друг-друга по очереди.

	function sum(num){
	     if (num === 0) {
	         return 0;
	     } else {
	         return num + sum(--num)
	     }
	 }
	 sum(4);     //10

чтобы рекурсия не ушла в бесконечный цикл необходимо внутри рекурсивной функции определить условие выхода. в примере выше это проверка на ноль входящего параметра.

для случая хвостовой рекурсии используется второй аргумент, в октором происходит аккумуляция значений. при этом первый аргумент используется в качестве счётчика. как только счётчик достигает нуля(базового случая), то рекурсивная функция заканчивает работу и возвращает значение второго аргумента

	function tailrecsum(x, running_total=0) {
	    if (x===0) {
	        return running_total;
	    } else {
	        return tailrecsum(x-1, running_total+x);
	    }
	}

	// tailrecsum(5, 0)
	// tailrecsum(4, 5)
	// tailrecsum(3, 9)
	// tailrecsum(2, 12)
	// tailrecsum(1, 14)
	// tailrecsum(0, 15)
	// 15

================================
что такое О-большое?

О даёт представление насколько сложен алгоритм по отношению к входным данным. или это максимальное количество действий, которое совершит процессор для определённой операции.

например для того чтобы добавить в конец массива значение нужно одно действие О(1). а для того чтобы вставить значение в любое место массива нужно совершить О(n) действий, где n это количество элементов массива.

для объекта вставка будет описываться О(1) потому что ключи объекта не упорядочены.

сортировка обычно описывается значением О(n*n). но это зависит от алгоритма сортировки, бывает, что О(log(n))

чтобы посчитать О-большое для определенной программы, нужно напротив каждой строки написать О и в результате определить наихудшее О

================================
что такое rest архитектура?

rest это архитектурный стиль взаимодействия между компонентами распределённой системы. например клиент и сервер физически находятся в разных местах. обмен сигналами происходит через http-запросы. для клиента это значит, что если он хочет отправить сигнал на сервер, то должен будет использовать запрос, сформированный с url строго определённого типа.

действие запроса определяется тем какой он использует метод: get, post, delete put и т.д. некоторые из методов предполагают отправку данных(post), некоторые просто посылают сигнал(delete). 

например:
delete book/3 удаляет запись, соответствующую книге №3.
post book/3 записывает данные в книгу №3. при этом сами данные отправляются в теле запроса.

принципы:
клиент сервер разделены.
каждый запрос должен содержать в себе всю необходимую информацию потому что http не сохраняет состояние.
необходимо использовать кеширование для большей эффективности.
клиент может запрашивать скрипты и выполнять их. 

================================
что такое браузерное кеширование? как оно работает?

при первом запросе страницы клиент получает с сервера кроме самой страницы ещё заголовок Cache-Control, в котором указано сколько секунд ресурс на сервере не изменится. и контрольную сумму, которую сервер вычислил для отправляемой странички. в следующем запросе этого ресурса клиент сначала посмотрит кеш:
1. в случае если время, указанное в Cache-Control не истекло, то страница возьмётся из кеша браузера, а запрос не будет отправлен
2. в случае если время, указанное в Cache-Control истекло, то клиент в запросе, кроме всего прочего, отправляет контрольную сумму. сервер её сверяет и если она не изменилась, то он возвращает код 304. при этом клиент берёт страницу опять из кеша.

таким образом кеширование или вобще не отправляет запрос или отправляет, но получает ответ без тела, но с заголовком.

================================
чо такое кроссдоменный запрос? описать трудности и этапы.

js позволяет делать ajax-запросы. но если запрос идёт на другой домен, то сервер должен дать явное согласие чтобы обработать такой запрос. для этого клиент перед основным запросом отправляет OPTIONS-запрос, в заголовках которого перечисляет методы и заголовки, которые будет использовать:
Access-Control-Allow-Methods,
Access-Control-Allow-Headers

сервер может ответить согласием. в этом случае он вернёт список разрешённых методов и заголовков в:
Access-Control-Request-Method,
Access-Control-Request-Headers

после этого может отправиться основной запрос.

================================
что такое jsonp?

это способ загрузить json с другого домента. как известно, CORS этого не разрешает. но если динамически создать элемент script и в его scr поместить запрос, то кроссдоменный запрос отработает без проблем.

важно то, что к url нужно в виде get-параметра добавить коллбек, который выполнится сразу полу получения данных:

	var s = document.createElement("script");
	s.src = "demo_jsonp2.php?callback=myDisplayFunction";
	document.body.appendChild(s);

	function myDisplayFunction(myObj) {
		console.log(myObj.name);
	}

================================
что такое dom?

dom это представление html-дерева документа в виде объекта. при этом, если в html есть ошибки(например отсутствуют html, body), то dom исправляет их.

dom имеет api например можно создать элемент и добавить его в dom. при этом дерево html не изменится.

================================
что такое shadow dom?

SD это изолированное от DOM дерево элементов, которое существует внутри хост-элемента, и на которое не распространяется действие css-стилей. примером host-элемента может служить <input type="range">

чтобы управлять SD нужно использовать JS. например при помощи JS можно добавить элементы в SD, в том числе элементы style.

если внутри host-элемента существует обычные элементы и SD-элементы, то отображаются только SD-элементы. а обычные элементы представляют собой fallback для случая отсутствия SD-элементов.

в chrome dev tools можно включить отображение SD, если зайти в настройки и выбрать "show user agent shadow dom"

события из SD могу всплывать в DOM, это регулируется специальными флагами. при этом event.target изменяется, если клик произошёл на SD-элементе, но не меняется если клик произошёл на обычном элементе, который находится внутри SD-элемента.

================================
что такое indexDB?

это браузерная БД, в которой вместо таблиц используются хранилища, представляющие собой набор записей типа ключ:значение. транзакции поддерживаются. вместимость indexDB больше чем у кук и стораджей.

================================
что такое graphQL?

это дополнительный слой абстракции между клиентом и сервером. он представляет из себя синтаксис, с помощью которого можно агрегировать запросы из разных источников. при этом запросы могут иметь имена и переменные. кроме того graphQL это типизированный язык, поэтому узнать корректен запрос или нет можно ещё до отправки его.

чтобы пометить поле определённым типом нужно в схеме указать соответствие полей типам:

	type User {
	  id: ID!
	  name: String!
	  email: String!
	  age: Int
	}

например, данные о постах хранятся в mysql, а данные о лайках - в redis. чтобы отобразить страницу с постами в случае rest api приходилось бы делать в два раза больше запросов чем в случае с graphQL.


================================
в чём отличие scrum и kanban?

в канбане нет временных пределов, в пределах которых нужно выполнить задачу. в канбане просто задачи двигаются по доске, а разработчики переключаются с них в зависимости отприоритетов

канбан позволяет добавлять новые задачи на любом этапе разработки

канбан не требует ежедевных митингов

в канбан не обязательно делать оценку задач(хотя, можно)


================================
что такое viewport?

из-за того, что у смартфонов и планшетов экраны малого размера, страницы в них могут отображаться некорректно. при помощи viewport можно задать правила для отображения страниц, выходящих за пределы экрана. например, можно всю страницу поместить в пределы экрана смартфона и затем изменять её масштаб по мере надобности. или можно отобразить часть этой страницы и пользоваться только скроллом

================================
в блоке HEAD страницы можно использовать подсказки браузеру для улучшения производительности. эти подсказки браузер может использовать по своему усмотрению поэтому наличие их не гарантирует улучшение производительности.

	<link rel="dns-prefetch" href="//google-analytics.com/">
	  
		преобразование DNS в IP занимает время. чтобы не ждать пока браузер столкнётся с необходимостью преобразования можно при старте анализа HTML сразу закешировать набор DNS, которые пригодятся позже. полезно в первую очередь для CDNs, Google Fonts

	<link rel="preconnect" href="//s3-us-west-2.amazonaws.com/s.cdpn.io/4273/">

		делает то же самое что и "dns-prefetch", но указывает точный путь к файлам не сервере. полезен если на странице есть встроенная песочница типа codePen, которая использует файлы, хранящиеся на определённом пути определённого ресурса.

	<link rel="prefetch" href="/190/Using-link-rel-to-preload-web-content-and-aid-accessibility">

		указывает ресурс, который с большой вероятностью понадобится пользователю на следующей странице(следующую страницу разработчик угадывает на основе анализа посещений). для этой стрницы в фоновом режиме в низком приоритете будет скачиваться этот ресурс.

	<link rel="prerender" href="/samples/polina.html">

		в фоновом режиме загружает всю стрнаицу с соответствующими ресурсами. разработчик угадывает страницу, на которую с большой вероятностью перейдёт пользователь в следующий момент.

	<link rel="preload" href="libertad.woff2" as="font">

		нестандартные  шрифты начинают подгружаться когда анализатор сталкивается с ними в css-файле. при помощи этого атрибута их можно загружать предварительно, с высоким приоритетом, не блокируя основные процессы.

	<link rel="prev" href="http://www.example.com/artykul-page1.html">
	<link rel="next" href="http://www.example.com/artykul-page3.html">

		применяется на странице, которая является частью статей: page1, page2, page3. это делается только для анализатора поисковых систем чтобы он понимал последовательную связь страниц.

	<link rel="canonical" href="https://example.com/dresses/green-dresses" />

		если существует страница, части которой дублируются на других страницах, то чтобы указать анализатору поисковой системы адрес оригинала используется canonical. для этого в HEAD каждой вторичной страницы нужно прописать путь к оригиналу.

================================
что такое <!DOCTYPE>?

	<!DOCTYPE> указывает, в соответствии с каким стандартом HTML написана ваша Web-страница.
	например, некоторые стандарты требуют обязательного:
		1. наличия кавычек у значений атрибутов, 
		2. нижнего регистра названий атрибутов, 
		3. закрытия даже единичных тегов, 
		4. строгую вложенность,
		5. полную форму для булевых атрибутов
		6. запрет вкладывать блочные элементы в строчные
		7. наличие описаний у картинок alt
		8. использовать собственные теги

	доктайп указывает как разрешать подобные конфликты.


================================
SOLID

	1. принцип единой ответственности
		Класс должен иметь только одну ответственность. ("Класс должен иметь одну и только одну причину для изменений").

		например, есть класс, который описывает данные пользователя. если этот класс включает правила валидацтт email тоже, то этот класс нарушает принцип. 

		нужно вынести правила валидации email в отдельный класс.

	2. принцип открытости-закрытости
		Программные сущности должны быть открыты для расширения и закрыты для модификации.

		например есть функция, которая на основе полученного экземпляра класса вычисляет площать фигуры. эта функция при помощи блока if определяет фигуру и вычисляет результат. проблема в том, что если появится новая фигура, то придётся изменять уже написанный функционал. 

		здесь необходимо в каждый класс фигуры добавить метод getArea. таким образом придётся функция будет вызывать метод получения площади у любого полученного экземпляра.

	3. принцип подстановки Барбары Лисков.
		Необходимо, чтобы подклассы могли бы служить заменой для своих родительских классов.

		в предыдущем примере функция получала инстанс фигуры для вычисления площади. должно быть так чтобы она могла принимать любой инстанс, который реализует класс фигуры.

	4. принцип разделения интерфейсов.
		Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.

		если есть несколько классов фигур и требуется описать их при помощи интерфейсов, то создавать один жирный интерфейс будт неправильно. нужно создать несколько и класс каждый фигуры имплементировать от нескольких мелких.

	5. принцип инверсии зависимостей
		стараться использовать в качестве зависимостей интерфейсы а не конкретные их реализации. или модули верхних уровней не должны зависеть от модулей нижних уровней, оба типа модулей должны зависеть от абстракций.

		например, пусть компонент ангулара инжектирует сервис. внутренняя рализация сервиса может быть любой, но он реализует определённый интерфейс. реализация на низком уровне может измениться, но если интерфейс остался прежним, то компонент не почувствует разницы. потому что он не зависит от конкретной реализации.


================================
внедрение зависимостей — это способ, с помощью которого объект получает другие объекты, от которых он зависит, называемые зависимостями, а не создает их сам.

	import { Engine } from './Engine';

	class Car {
	    private engine: Engine;

	    public constructor (engine: Engine) {
	        this.engine = engine;
	    }
	    
	    public startEngine(): void {
	        this.engine.fireCylinders();
	    }
	}



dependency injection делится на 3 вида:

	1. constructor injection. в этом случае зависимость передаётся через конструктор класса и далее присваивается свойству класса

		class A:
			def __init__(self, logger):
				self.logger = logger

	2. method injection. в этом случае зависимость передаётся через метод класса и в большинстве случаев на присваивается свойству класса, но присваивается локальной переменной метода

		class A:
			def set_logger(self, logger):
				logger_obj = logger
				logger_obj.write('blabla')

	3. property injection. в этом случае зависимость приравнивается свойству объекта

		a = A()
		a.prop = B()


================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
