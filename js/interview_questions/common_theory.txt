================================
================================
описать паттерн декоратор

================================
что такое:
динамическая типизация,
	Статическая определяется тем, что конечные типы переменных и функций устанавливаются на этапе объявления и не может меняться во время выполнения программы. 
	В динамической типизации все типы выясняются уже во время выполнения программы, то есть на этапе присваивания.

сильная типизация,
	Сильная типизация выделяется тем, что язык не позволяет смешивать в выражениях различные типы и не выполняет автоматические неявные преобразования, например нельзя вычислить 10 + 'str'

явная типизация
	тип новых переменных / функций / их аргументов нужно задавать явно. например, в TS Это делается так const a: string = 'str';

================================
что такое итератор

================================
что такое генератор

================================
что такое геттеры и сеттеры 

это методы установки и получения, которые привязаны к определённому свойству объекта. они срабатывают, когда пользователь работает со свойством.

	let user = {
	  name: "John",
	  surname: "Smith",
	  get fullName() {
	    return `${this.name} ${this.surname}`;
	  }
	};
	alert(user.fullName); // John Smith

================================
рассказать об основных принциипах ООП

	Инкапсуляция — ограничение доступа к составляющим объект компонентам.
	инкапсуляция  в js действует только на уровне соглашений. но в ES6 появился знак #, при помощи которого можно установить приватность переменной или метода.

	наследование связывает классы. при этом потомок содержит все методы и свойства родителя.
	самый верхний объект для классов это object. 

	полиморфизм это когда в различных классах методы с одинаковыми названиями выполняют различные действия.

		'qwerty'.length
		6
		[1, 2, 3, 4].length
		4

	в TS инкапсуляция реализована при помощи модификаторов доступа: public, private, protected.
	В TypeScript наследование реализуется с помощью ключевого слова extends
	в TS полиморфизм доступен через несколько объявлений одной функции о одной реализации с максимально общим типом:
		function add(x: string, y: string): string;
		function add(x: number, y: number): number;
		function add(x: any, y: any): any {
		    return x + y;
		}
		 
		let result1 = add(5, 4);      // 9
		let result2 = add("5", "4");  // 54

================================
чем отличаются функциональный и ОО-подход?

в ООП все сущности представляются в виде объектов, которые похожи на объекты реального мира. они имеют свойства и методы. могут наследоваться и устанавливать правила доступа к своим составляющим.

в ФП все сущности представляются в виде чистых функций, которые принимают стейт и возвращают копию изменённого стейта. эти функции объединяются в композицию потому что являются функциями высшего порядка.

================================
что такое чистая функция?

это функция, которая:
1. при одинаковых входных параметрах всегда возвращает один и тот же результат.
2. которая не использует и не изменяет внешние переменные. не имеет сайд-эффектов



================================
рекурсия это когда функция вызывает саму себя. существует тип рекурсии когда две функции вызывают друг-друга по очереди.

	function sum(num){
	     if (num === 0) {
	         return 0;
	     } else {
	         return num + sum(--num)
	     }
	 }
	 sum(4);     //10

чтобы рекурсия не ушла в бесконечный цикл необходимо внутри рекурсивной функции определить условие выхода. в примере выше это проверка на ноль входящего параметра.

для случая хвостовой рекурсии используется второй аргумент, в октором происходит аккумуляция значений. при этом первый аргумент используется в качестве счётчика. как только счётчик достигает нуля(базового случая), то рекурсивная функция заканчивает работу и возвращает значение второго аргумента

	function tailrecsum(x, running_total=0) {
	    if (x===0) {
	        return running_total;
	    } else {
	        return tailrecsum(x-1, running_total+x);
	    }
	}

	// tailrecsum(5, 0)
	// tailrecsum(4, 5)
	// tailrecsum(3, 9)
	// tailrecsum(2, 12)
	// tailrecsum(1, 14)
	// tailrecsum(0, 15)
	// 15

================================
что такое О-большое?

О даёт представление насколько сложен алгоритм по отношению к входным данным. или это максимальное количество действий, которое совершит процессор для определённой операции.

например для того чтобы добавить в конец массива значение нужно одно действие О(1). а для того чтобы вставить значение в любое место массива нужно совершить О(n) действий, где n это количество элементов массива.

для объекта вставка будет описываться О(1) потому что ключи объекта не упорядочены.

сортировка обычно описывается значением О(n*n). но это зависит от алгоритма сортировки, бывает, что О(log(n))

чтобы посчитать О-большое для определенной программы, нужно напротив каждой строки написать О и в результате определить наихудшее О


================================
что такое браузерное кеширование? как оно работает?

при первом запросе страницы клиент получает с сервера кроме самой страницы ещё заголовок Cache-Control, в котором указано сколько секунд ресурс на сервере не изменится. и контрольную сумму, которую сервер вычислил для отправляемой странички. в следующем запросе этого ресурса клиент сначала посмотрит кеш:
1. в случае если время, указанное в Cache-Control не истекло, то страница возьмётся из кеша браузера, а запрос не будет отправлен
2. в случае если время, указанное в Cache-Control истекло, то клиент в запросе, кроме всего прочего, отправляет контрольную сумму. сервер её сверяет и если она не изменилась, то он возвращает код 304. при этом клиент берёт страницу опять из кеша.

таким образом кеширование или вобще не отправляет запрос или отправляет, но получает ответ без тела, но с заголовком.

================================
чо такое кроссдоменный запрос? описать трудности и этапы.

js позволяет делать ajax-запросы. но если запрос идёт на другой домен, то сервер должен дать явное согласие чтобы обработать такой запрос. для этого клиент перед основным запросом отправляет OPTIONS-запрос, в заголовках которого перечисляет методы и заголовки, которые будет использовать:
Access-Control-Allow-Methods,
Access-Control-Allow-Headers

сервер может ответить согласием. в этом случае он вернёт список разрешённых методов и заголовков в:
Access-Control-Request-Method,
Access-Control-Request-Headers

после этого может отправиться основной запрос.



================================
что такое dom?

dom это представление html-дерева документа в виде объекта. при этом, если в html есть ошибки(например отсутствуют html, body), то dom исправляет их.

dom имеет api например можно создать элемент и добавить его в dom. при этом дерево html не изменится.

================================
что такое shadow dom?

SD это изолированное от DOM дерево элементов, которое существует внутри хост-элемента, и на которое не распространяется действие css-стилей. примером host-элемента может служить <input type="range">

чтобы управлять SD нужно использовать JS. например при помощи JS можно добавить элементы в SD, в том числе элементы style.

если внутри host-элемента существует обычные элементы и SD-элементы, то отображаются только SD-элементы. а обычные элементы представляют собой fallback для случая отсутствия SD-элементов.

в chrome dev tools можно включить отображение SD, если зайти в настройки и выбрать "show user agent shadow dom"

события из SD могу всплывать в DOM, это регулируется специальными флагами. при этом event.target изменяется, если клик произошёл на SD-элементе, но не меняется если клик произошёл на обычном элементе, который находится внутри SD-элемента.

================================
что такое indexDB?

это браузерная БД, в которой вместо таблиц используются хранилища, представляющие собой набор записей типа ключ:значение. транзакции поддерживаются. вместимость indexDB больше чем у кук и стораджей.

================================
что такое graphQL?

это дополнительный слой абстракции между клиентом и сервером. он представляет из себя синтаксис, с помощью которого можно агрегировать запросы из разных источников. при этом запросы могут иметь имена и переменные. кроме того graphQL это типизированный язык, поэтому узнать корректен запрос или нет можно ещё до отправки его.

чтобы пометить поле определённым типом нужно в схеме указать соответствие полей типам:

	type User {
	  id: ID!
	  name: String!
	  email: String!
	  age: Int
	}

например, данные о постах хранятся в mysql, а данные о лайках - в redis. чтобы отобразить страницу с постами в случае rest api приходилось бы делать в два раза больше запросов чем в случае с graphQL.


================================
в чём отличие scrum и kanban?

в канбане нет временных пределов, в пределах которых нужно выполнить задачу. в канбане просто задачи двигаются по доске, а разработчики переключаются с них в зависимости отприоритетов

канбан позволяет добавлять новые задачи на любом этапе разработки

канбан не требует ежедевных митингов

в канбан не обязательно делать оценку задач(хотя, можно)


================================
что такое viewport?

из-за того, что у смартфонов и планшетов экраны малого размера, страницы в них могут отображаться некорректно. при помощи viewport можно задать правила для отображения страниц, выходящих за пределы экрана. например, можно всю страницу поместить в пределы экрана смартфона и затем изменять её масштаб по мере надобности. или можно отобразить часть этой страницы и пользоваться только скроллом

================================
в блоке HEAD страницы можно использовать подсказки браузеру для улучшения производительности. эти подсказки браузер может использовать по своему усмотрению поэтому наличие их не гарантирует улучшение производительности.

	<link rel="dns-prefetch" href="//google-analytics.com/">
	  
		преобразование DNS в IP занимает время. чтобы не ждать пока браузер столкнётся с необходимостью преобразования можно при старте анализа HTML сразу закешировать набор DNS, которые пригодятся позже. полезно в первую очередь для CDNs, Google Fonts

	<link rel="preconnect" href="//s3-us-west-2.amazonaws.com/s.cdpn.io/4273/">

		делает то же самое что и "dns-prefetch", но указывает точный путь к файлам не сервере. полезен если на странице есть встроенная песочница типа codePen, которая использует файлы, хранящиеся на определённом пути определённого ресурса.

	<link rel="prefetch" href="/190/Using-link-rel-to-preload-web-content-and-aid-accessibility">

		указывает ресурс, который с большой вероятностью понадобится пользователю на следующей странице(следующую страницу разработчик угадывает на основе анализа посещений). для этой стрницы в фоновом режиме в низком приоритете будет скачиваться этот ресурс.

	<link rel="prerender" href="/samples/polina.html">

		в фоновом режиме загружает всю стрнаицу с соответствующими ресурсами. разработчик угадывает страницу, на которую с большой вероятностью перейдёт пользователь в следующий момент.

	<link rel="preload" href="libertad.woff2" as="font">

		нестандартные  шрифты начинают подгружаться когда анализатор сталкивается с ними в css-файле. при помощи этого атрибута их можно загружать предварительно, с высоким приоритетом, не блокируя основные процессы.

	<link rel="prev" href="http://www.example.com/artykul-page1.html">
	<link rel="next" href="http://www.example.com/artykul-page3.html">

		применяется на странице, которая является частью статей: page1, page2, page3. это делается только для анализатора поисковых систем чтобы он понимал последовательную связь страниц.

	<link rel="canonical" href="https://example.com/dresses/green-dresses" />

		если существует страница, части которой дублируются на других страницах, то чтобы указать анализатору поисковой системы адрес оригинала используется canonical. для этого в HEAD каждой вторичной страницы нужно прописать путь к оригиналу.

================================
что такое <!DOCTYPE>?

	<!DOCTYPE> указывает, в соответствии с каким стандартом HTML написана ваша Web-страница.
	например, некоторые стандарты требуют обязательного:
		1. наличия кавычек у значений атрибутов, 
		2. нижнего регистра названий атрибутов, 
		3. закрытия даже единичных тегов, 
		4. строгую вложенность,
		5. полную форму для булевых атрибутов
		6. запрет вкладывать блочные элементы в строчные
		7. наличие описаний у картинок alt
		8. использовать собственные теги

	доктайп указывает как разрешать подобные конфликты.


================================
SOLID

	1. принцип единой ответственности
		Класс должен решать только одну задачу.

		например, есть класс, который описывает данные пользователя. если этот класс включает правила валидации email тоже, то этот класс нарушает принцип. 

		нужно вынести правила валидации email в отдельный класс. и тот класс валидации при попощи композиции использовать в классе данных пользователя.

	2. принцип открытости-закрытости
		Программные сущности должны быть открыты для расширения и закрыты для модификации.

		например есть функция, которая на основе полученного экземпляра класса вычисляет площадь фигуры. эта функция при помощи блока if определяет фигуру и вычисляет результат. проблема в том, что если появится новая фигура, то придётся изменять уже написанный функционал. 

		здесь необходимо в каждый класс фигуры добавить метод getArea. таким образом придётся функция будет вызывать метод получения площади у любого полученного экземпляра.

	3. принцип подстановки Барбары Лисков.
		Необходимо, чтобы подклассы не переопределяли методы родительских классов.

		например, есть класс Person, он умеет думать и дышать. от Programmist наследуется класс ProgrammistJS, который имеет метод writeCode. унаследуем от Person класс ProgrammistPython, в котором метод writeCode будет переопределён и возвращает error. 

		все эти 3 класса мы теоретически можем передавать в аргументом в какую-нибудь функцию и ожидать, что программисты будут писать код. но ProgrammistPython не умеет писать код и если он нам нужен в таком виде, то: 

			1. или его не надо было насделовать от Programmist
			2. или в нём не надо было переопределять метод writeCode

		вывод: классы-наследники не должные перелопределять поведение классов-родителей.

	4. принцип разделения интерфейсов.
		Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.

		если есть несколько классов фигур и требуется описать их при помощи интерфейсов, то создавать один жирный интерфейс будт неправильно. нужно создать несколько и класс каждый фигуры имплементировать от нескольких мелких.

		вывод: нельзя имплементировать класс от интерфейса, если после этого класс будет содержать никогда неиспользуемые методы.

	5. принцип инверсии зависимостей
		стараться использовать в качестве зависимостей интерфейсы, а не конкретные их реализации. или модули верхних уровней не должны зависеть от модулей нижних уровней, оба типа модулей должны зависеть от абстракций.

		например, пусть компонент ангулара инжектирует сервис. внутренняя рализация сервиса может быть любой, но он реализует определённый интерфейс. реализация на низком уровне может измениться, но если интерфейс остался прежним, то компонент не почувствует разницы. потому что он не зависит от конкретной реализации. 

		то есть верхоуровневый компонент не зависит от низкоуровневого сервиса.

		второй пример. на зводе есть: рабочие, станки. допустим, мы заменили в станке деталь. после этого может оказаться, что  рабочие не могут работать с обновлённым стенком.

		решением будет создать пульт управления, в котором содной стороны будут работать рабочие, а сдругой он будет их действия преобразовывать с понятный станку язык. таким образом пуль никогда не меняется, а детали можно менять хоть каждую неделю.

		здесь рабочие это более высокоуровневый элемент, станок это более низкоуровневый элемент, а пульт это абстракция.


================================
внедрение зависимостей — это способ, с помощью которого объект получает другие объекты, от которых он зависит, называемые зависимостями, а не создает их сам.

	import { Engine } from './Engine';

	class Car {
	    private engine: Engine;

	    public constructor (engine: Engine) {
	        this.engine = engine;
	    }
	    
	    public startEngine(): void {
	        this.engine.fireCylinders();
	    }
	}



dependency injection делится на 3 вида:

	1. constructor injection. в этом случае зависимость передаётся через конструктор класса и далее присваивается свойству класса

		class A:
			def __init__(self, logger):
				self.logger = logger

	2. method injection. в этом случае зависимость передаётся через метод класса и в большинстве случаев на присваивается свойству класса, но присваивается локальной переменной метода

		class A:
			def set_logger(self, logger):
				logger_obj = logger
				logger_obj.write('blabla')

	3. property injection. в этом случае зависимость приравнивается свойству объекта

		a = A()
		a.prop = B()

================================
что такое оптимистические и пессимистические измененеия?

  // optimistic update
  // 1. update UI state
  // 2. call API

  // pessimistic update
  // 1. call API
  // 2. update UI state  

================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
