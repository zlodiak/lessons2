================================
================================
описать паттерн декоратор

================================
что такое:
динамическая типизация,
	Статическая определяется тем, что конечные типы переменных и функций устанавливаются на этапе объявления и не может меняться во время выполнения программы. 
	В динамической типизации все типы выясняются уже во время выполнения программы, то есть на этапе присваивания.

сильная типизация,
	Сильная типизация выделяется тем, что язык не позволяет смешивать в выражениях различные типы и не выполняет автоматические неявные преобразования, например нельзя вычислить 10 + 'str'

явная типизация
	тип новых переменных / функций / их аргументов нужно задавать явно. например, в TS Это делается так const a: string = 'str';

================================
что такое итератор

================================
что такое генератор

================================
что такое геттеры и сеттеры 

это методы установки и получения, которые привязаны к определённому свойству объекта. они срабатывают, когда пользователь работает со свойством. то есть извне объекта выглядят ка свойства, но по сути являются методами.

	let user = {
	  name: "John",
	  surname: "Smith",
	  get fullName() {
	    return `${this.name} ${this.surname}`;
	  }
	};
	alert(user.fullName); // John Smith

================================
рассказать об основных принциипах ООП

	Инкапсуляция — ограничение доступа к составляющим объект компонентам.
	инкапсуляция  в js действует только на уровне соглашений. но в ES6 появился знак #, при помощи которого можно установить приватность переменной или метода.

	наследование связывает классы. при этом потомок содержит все методы и свойства родителя.
	самый верхний объект для классов это object. 

	полиморфизм это когда в различных классах методы с одинаковыми названиями выполняют различные действия.

		'qwerty'.length
		6
		[1, 2, 3, 4].length
		4

	в TS инкапсуляция реализована при помощи модификаторов доступа: public, private, protected.
	В TypeScript наследование реализуется с помощью ключевого слова extends
	в TS полиморфизм доступен через несколько объявлений одной функции о одной реализации с максимально общим типом:
		function add(x: string, y: string): string;
		function add(x: number, y: number): number;
		function add(x: any, y: any): any {
		    return x + y;
		}
		 
		let result1 = add(5, 4);      // 9
		let result2 = add("5", "4");  // 54

================================
чем отличаются функциональный и ОО-подход?

в ООП все сущности представляются в виде объектов, которые похожи на объекты реального мира. они имеют свойства и методы. могут наследоваться и устанавливать правила доступа к своим составляющим.

в ФП все сущности представляются в виде чистых функций, которые принимают стейт и возвращают копию изменённого стейта. эти функции объединяются в композицию потому что являются функциями высшего порядка. ссылочная прозрачность это возможность заменить одну из таких функций на конкретный результат, тем самым сэкономир ресурсы процессора.

================================
что такое чистая функция?

это функция, которая:
1. при одинаковых входных параметрах всегда возвращает один и тот же результат.
2. которая не использует и не изменяет внешние переменные. не имеет сайд-эффектов



================================
рекурсия это когда функция вызывает саму себя. существует тип рекурсии когда две функции вызывают друг-друга по очереди.

	function sum(num){
	     if (num === 0) {
	         return 0;
	     } else {
	         return num + sum(--num)
	     }
	 }
	 sum(4);     //10

чтобы рекурсия не ушла в бесконечный цикл необходимо внутри рекурсивной функции определить условие выхода. в примере выше это проверка на ноль входящего параметра.

для случая хвостовой рекурсии используется второй аргумент, в октором происходит аккумуляция значений. при этом первый аргумент используется в качестве счётчика. как только счётчик достигает нуля(базового случая), то рекурсивная функция заканчивает работу и возвращает значение второго аргумента

	function tailrecsum(x, running_total=0) {
	    if (x===0) {
	        return running_total;
	    } else {
	        return tailrecsum(x-1, running_total+x);
	    }
	}

	// tailrecsum(5, 0)
	// tailrecsum(4, 5)
	// tailrecsum(3, 9)
	// tailrecsum(2, 12)
	// tailrecsum(1, 14)
	// tailrecsum(0, 15)
	// 15

================================
что такое О-большое?

О даёт представление насколько сложен алгоритм по отношению к входным данным. или это максимальное количество действий, которое совершит процессор для определённой операции.

например для того чтобы добавить в конец массива значение нужно одно действие О(1). а для того чтобы вставить значение в любое место массива нужно совершить О(n) действий, где n это количество элементов массива.

для объекта вставка будет описываться О(1) потому что ключи объекта не упорядочены.

сортировка обычно описывается значением О(n*n). но это зависит от алгоритма сортировки, бывает, что О(log(n))

чтобы посчитать О-большое для определенной программы, нужно напротив каждой строки написать О и в результате определить наихудшее О


================================
что такое браузерное кеширование? как оно работает?

при первом запросе страницы клиент получает с сервера кроме самой страницы ещё заголовок Cache-Control, в котором указано сколько секунд ресурс на сервере не изменится. и контрольную сумму, которую сервер вычислил для отправляемой странички. в следующем запросе этого ресурса клиент сначала посмотрит кеш:
1. в случае если время, указанное в Cache-Control не истекло, то страница возьмётся из кеша браузера, а запрос не будет отправлен
2. в случае если время, указанное в Cache-Control истекло, то клиент в запросе, кроме всего прочего, отправляет контрольную сумму. сервер её сверяет и если она не изменилась, то он возвращает код 304. при этом клиент берёт страницу опять из кеша.

таким образом кеширование или вобще не отправляет запрос или отправляет, но получает ответ без тела, но с заголовком.

================================
чо такое кроссдоменный запрос? описать трудности и этапы.

js позволяет делать ajax-запросы. но если запрос идёт на другой домен (не на тот, с которго был загруже скрипт), то сервер должен дать явное согласие чтобы обработать такой запрос. для этого клиент перед основным запросом отправляет OPTIONS-запрос, в заголовках которого перечисляет методы и заголовки, которые будет использовать:
Access-Control-Allow-Methods,
Access-Control-Allow-Headers

сервер может ответить согласием. в этом случае он вернёт список разрешённых методов и заголовков в:
Access-Control-Request-Method,
Access-Control-Request-Headers

после этого может отправиться основной запрос.

это делается из соображений безопасности. чтобы, например, сторонний сайт не мог заманить пользователя и при помощи поддельной формы отправить запрос на перевод денег с реальными куками пользователя.

================================
что такое dom?

dom это представление html-дерева документа в виде объекта. при этом, если в html есть ошибки(например отсутствуют html, body), то dom исправляет их.

dom имеет api например можно создать элемент и добавить его в dom. при этом дерево html не изменится.

================================
что такое shadow dom?

SD это изолированное от DOM дерево элементов, которое существует внутри хост-элемента, и на которое не распространяется действие внешних css-стилей. примером host-элемента может служить <input type="range">

чтобы управлять SD нужно использовать JS. например при помощи JS можно добавить элементы в SD, в том числе элементы style.

если внутри host-элемента существует обычные элементы и SD-элементы, то отображаются только SD-элементы. а обычные элементы представляют собой fallback для случая отсутствия SD-элементов.

в chrome dev tools можно включить отображение SD, если зайти в настройки и выбрать "show user agent shadow dom"

события из SD могу всплывать в DOM, это регулируется специальными флагами. при этом event.target изменяется, если клик произошёл на SD-элементе, но не меняется если клик произошёл на обычном элементе, который находится внутри SD-элемента.

================================
что такое indexDB?

это браузерная БД, в которой вместо таблиц используются хранилища, представляющие собой набор записей типа ключ:значение. транзакции поддерживаются. вместимость indexDB больше чем у кук и стораджей.

================================
что такое graphQL?

это дополнительный слой абстракции между клиентом и сервером. он представляет из себя синтаксис, с помощью которого можно агрегировать запросы из разных источников и получать не все поля, а определённый набор их. при этом запросы могут иметь имена и переменные. кроме того graphQL это типизированный язык, поэтому узнать корректен запрос или нет можно ещё до отправки его.

чтобы пометить поле определённым типом нужно в схеме указать соответствие полей типам:

	type User {
	  id: ID!
	  name: String!
	  email: String!
	  age: Int
	}

например, данные о постах хранятся в mysql, а данные о лайках - в redis. чтобы отобразить страницу с постами в случае rest api приходилось бы делать в два раза больше запросов чем в случае с graphQL.

кроме того эта технология позволяет запрашивать не все поля в запросе, а только необходимые, тем самым экономя трафик


================================
в чём отличие scrum и kanban?

в канбане нет временных пределов, в пределах которых нужно выполнить задачу. в канбане просто задачи двигаются по доске, а разработчики переключаются с них в зависимости отприоритетов

канбан позволяет добавлять новые задачи на любом этапе разработки

канбан не требует ежедевных митингов

в канбан не обязательно делать оценку задач(хотя, можно)


================================
что такое viewport?

из-за того, что у смартфонов и планшетов экраны малого размера, страницы в них могут отображаться некорректно. при помощи viewport можно задать правила для отображения страниц, выходящих за пределы мобильного экрана. например, можно всю страницу поместить в пределы экрана смартфона и затем изменять её масштаб по мере надобности. или можно отобразить часть этой страницы и пользоваться только скроллом

================================
в блоке HEAD страницы можно использовать подсказки браузеру для улучшения производительности. эти подсказки браузер может использовать по своему усмотрению поэтому наличие их не гарантирует улучшение производительности.

	<link rel="dns-prefetch" href="//google-analytics.com/">
	  
		преобразование DNS в IP занимает время. чтобы не ждать пока браузер столкнётся с необходимостью преобразования можно при старте анализа HTML сразу закешировать набор DNS, которые пригодятся позже. полезно в первую очередь для CDNs, Google Fonts

	<link rel="preconnect" href="//s3-us-west-2.amazonaws.com/s.cdpn.io/4273/">

		делает то же самое что и "dns-prefetch", но указывает точный путь к файлам не сервере. полезен если на странице есть встроенная песочница типа codePen, которая использует файлы, хранящиеся на определённом пути определённого ресурса.

	<link rel="prefetch" href="/190/Using-link-rel-to-preload-web-content-and-aid-accessibility">

		указывает ресурс, который с большой вероятностью понадобится пользователю на следующей странице(следующую страницу разработчик угадывает на основе анализа посещений). для этой стрницы в фоновом режиме в низком приоритете будет скачиваться этот ресурс.

	<link rel="prerender" href="/samples/polina.html">

		в фоновом режиме загружает всю стрнаицу с соответствующими ресурсами. разработчик угадывает страницу, на которую с большой вероятностью перейдёт пользователь в следующий момент.

	<link rel="preload" href="libertad.woff2" as="font">

		нестандартные  шрифты начинают подгружаться когда анализатор сталкивается с ними в css-файле. при помощи этого атрибута их можно загружать предварительно, с высоким приоритетом, не блокируя основные процессы.

	<link rel="prev" href="http://www.example.com/artykul-page1.html">
	<link rel="next" href="http://www.example.com/artykul-page3.html">

		применяется на странице, которая является частью статей: page1, page2, page3. это делается только для анализатора поисковых систем чтобы он понимал последовательную связь страниц.

	<link rel="canonical" href="https://example.com/dresses/green-dresses" />

		если существует страница, части которой дублируются на других страницах, то чтобы указать анализатору поисковой системы адрес оригинала используется canonical. для этого в HEAD каждой вторичной страницы нужно прописать путь к оригиналу.



================================
SOLID

	1. принцип единой ответственности
		Класс должен решать только одну задачу, все его методы должны быть связаны с этой ответственностью.

		например, есть класс, который создаёт пользователя. если этот же класс делает низкоуровневую запись в лог о создании пользователя, то это неправильно.

		нужно всё, что относится к записи в лог вынести в отдельный класс и затем инжектировать его в класс создания пользователя.

		правильно:

			class User {
				constructor (name, logger) {
					this.name = name;
					this.logger = logger;
				}

				create() {
					// низкоуровневая реализация создания пользователя
					this.logger.log(name);
				}
			}

			class Logger {
				constructor(name) {
					this.name = name;
				}

				log() {
					// низкоуровневая реализация записи в лог
				}
			}

		неправильно:

			class User {
				constructor (name) {
					this.name = name;
				}

				create() {
					// низкоуровневая реализация создания пользователя
					// низкоуровневая реализация записи в лог
				}
			}

		можно вместо инжектирования использовать наследования или другой подход.


	2. принцип открытости-закрытости
		Программные сущности должны быть открыты для расширения и закрыты для модификации.

		например есть функция, которая на основе полученного экземпляра класса вычисляет площадь фигуры. эта функция при помощи блока if определяет фигуру и вычисляет результат. проблема в том, что если появится новая фигура, то придётся изменять уже написанный функционал. 

		здесь необходимо в каждый класс фигуры добавить метод getArea. таким образом функция будет вызывать метод получения площади у любого полученного экземпляра.

		правильно:

			class Calc {
				constructor(shape) {
					this.shape = shape;
				}

				getArea() {
					this.shape.area();
				}
			}

			class Shape {
			  area() {
			    throw new Error('Area method should be implemented');
			  }
			}

			class Circle extends Shape {
			  constructor(radius) {
			    super();
			    this.radius = radius;
			  }

			  area() {
			    return Math.PI * this.radius * this.radius;
			  }
			}

			class Rectangle extends Shape {
			  constructor(width, height) {
			    super();
			    this.width = width;
			    this.height = height;
			  }

			  area() {
			    return this.width * this.height;
			  }
			}

		неправильно:

			class Calc {
			  constructor(shape) {
			    this.shape = shape;
			  }

			  getArea() {
			    if (this.shape.type === 'circle') {
			    	return 1;
			    }

			    if (this.shape === 'rectangle') {
			    	return 2;
			    }
			  }
			}



	3. принцип подстановки Барбары Лисков.
		Необходимо, чтобы подклассы не переопределяли СМЫСЛ методов родительских классов.

		например, есть класс Person, он умеет непрофессионально писать код на любых языках при помощи writeCode(). от Person наследуется класс ProgrammistJS, который профессионально умеет писать код при помощи метода writeCode(). унаследуем от Person класс ProgrammistPython, в котором метод writeCode() будет не профессионально писать код на python, а здороваться. 

		инстансы этих 3 классов мы теоретически можем передавать в аргументами в какую-нибудь функцию и ожидать, что люди будут писать код кто как умеет. но ProgrammistPython вместо написания кода будет зороваться. в нём не надо было переопределять СМЫСЛ метода writeCode

		вывод: классы-наследники не должные перелопределять СМЫСЛ поведения классов-родителей.

		неправильно:

			class Person {
				writeCode() {
					console.log('code');
				}
			}

			class ProgrammistJS extends Person {
				writeCode() {
					console.log('code JS');
				}
			}

			class ProgrammistPYTHON extends Person {
				writeCode() {
					console.log('hello guys');
				}
			}

			new Person().writeCode();
      		new ProgrammistJS().writeCode();
      		new ProgrammistPYTHON().writeCode();

		правильно:

			class Person {
				writeCode() {
					console.log('code');
				}
			}

			class ProgrammistJS extends Person {
				writeCode() {
					console.log('code JS');
				}
			}

			class ProgrammistPYTHON extends Person {
				writeCode() {
					console.log('code PYTHON');
				}
			}		

			new Person().writeCode();
      		new ProgrammistJS().writeCode();
      		new ProgrammistPYTHON().writeCode();	
      		
      	так же можно создать новый класс, который унаследовать от одного из трёх вышеприведённых. это тоже продемонстрируетневыгодность изменения СМЫСЛА поведения.		


	4. принцип разделения интерфейсов.
		Много интерфейсов, специально предназначенных для классов, лучше, чем один интерфейс общего назначения.

		если есть несколько классов фигур и требуется описать их при помощи интерфейсов, то создавать один жирный интерфейс будт неправильно. нужно создать несколько и класс каждый фигуры имплементировать от нескольких мелких.

		если этого не сделать, кто каждый класс обязан будет кроме необходимых методов реализовать лишние методы. при этом когда в интерфейс добавится информация о новой фигуре, то придётся изменять код во многих классах.

		вывод: нельзя имплементировать класс от интерфейса, если после этого класс будет содержать никогда неиспользуемые методы.

		неправильно:

			interface Shape {
			    drawCircle();
			    drawSquare();
			    drawRectangle();
			    // drawTriangle(); // добавится в будущем
			}		

			class Circle implements Shape {
			    drawCircle() {}
			    drawSquare() {}
			    drawRectangle() {}    
			}

			class Square implements Shape {
			    drawCircle() {}
			    drawSquare() {}
			    drawRectangle() {}    
			}

			class Rectangle implements Shape {
			    drawCircle() {}
			    drawSquare() {}
			    drawRectangle() {}    
			}

		правильно:

			interface ICircle {
			    drawCircle();
			}

			interface ISquare {
			    drawSquare();
			}

			interface IRectangle {
			    drawRectangle();
			}


			class Circle implements ICircle {
			    drawCircle() {}
			}

			class Square implements ISquare {
			    drawSquare() {}
			}

			class Rectangle implements IRectangle {
			    drawRectangle() {}    
			}		


	5. принцип инверсии зависимостей
		стараться использовать в качестве зависимостей интерфейсы, а не конкретные их реализации. или модули верхних уровней не должны зависеть от модулей нижних уровней, оба типа модулей должны зависеть от абстракций.

		например, пусть компонент ангулара инжектирует сервис. внутренняя рализация сервиса может быть любой, но он реализует определённый интерфейс. реализация на низком уровне может измениться, но если интерфейс остался прежним, то компонент не почувствует разницы. потому что он не зависит от конкретной реализации. 

		то есть верхнеуровневый компонент не зависит от низкоуровневого сервиса.

		второй пример. на зводе есть: рабочие, станки. допустим, мы заменили в станке деталь. после этого может оказаться, что  рабочие не могут работать с обновлённым станком.

		решением будет создать пульт управления, в котором с одной стороны будут работать рабочие, а сдругой он будет их действия преобразовывать с понятный станку язык. таким образом пульт никогда не меняется, а детали можно менять хоть каждую неделю.

		здесь рабочие это более высокоуровневый элемент, станок это более низкоуровневый элемент, а пульт это абстракция.


================================
внедрение зависимостей — это способ, с помощью которого объект получает другие объекты, от которых он зависит, называемые зависимостями, а не создает их сам.

	import { Engine } from './Engine';

	class Car {
	    private engine: Engine;

	    public constructor (engine: Engine) {
	        this.engine = engine;
	    }
	    
	    public startEngine(): void {
	        this.engine.fireCylinders();
	    }
	}



dependency injection делится на 3 вида:

	1. constructor injection. в этом случае зависимость передаётся через конструктор класса и далее присваивается свойству класса

		class A:
			def __init__(self, logger):
				self.logger = logger

	2. method injection. в этом случае зависимость передаётся через метод класса и в большинстве случаев не присваивается свойству класса, но присваивается локальной переменной метода. то есть используется в пределах метода:

		class A:
			def set_logger(self, logger):
				logger_obj = logger
				logger_obj.write('blabla')

	3. property injection. в этом случае зависимость приравнивается свойству объекта. не гибкий подход:

		a = A()
		a.prop = B()

================================
что такое оптимистические и пессимистические измененеия?

  // optimistic update
  // 1. update UI state
  // 2. call API

  // pessimistic update
  // 1. call API
  // 2. update UI state  

================================
контракт

	это описание входных и выходных данных для сущности (модуля, функции, инстанса и т.д.)

================================
идемпотентность

	Операция считается идемпотентной, если её многократное выполнение приводит к тому же результату, что и однократное выполнение. 

	в контексте http методы get и delete являются идемпотентными, а метод post не идемпотентным потому что он может привести к многократному изменению сущности при повторных запросах. один из способов этого избежать помечать запрос uuid, использование которого позволяет отличать повторные запросы от новых. 

	идемпотентность повышает надёжность системы, но связана с написанием дополнительного кода и проектированию.

	Идемпотентная операция — действие, многократное повторение которого эквивалентно однократному. 

================================
JWT

	JWT это токен, который представляет из себя строку, состоящую из 3 хэшей, разделённых точками. каждый хеш это закодированный объект:

		1. название алгоритма кодирования
		2. полезная нагрузка
		3. подпись (вычисляется на основе пункта 1)

	есть 3 участника:

		1. клиент
		2. сервер авторизации
		3. сервер приложения

	клиент вводит логин пароль, в ответ сервер атворизации высылает ему JWT и refreshToken. когда клиент идёт на сервер приложения, то он использует JWT многокрантно. но когда JWT протухает(401error - Unauthorized) клиент опять идёт на сервер авторизации, но уже пользователью не нужно вводить логин/пароль руками потому что одноразовый, но долгоживущий refreshToken делает это за него. в итоге клиент опять имеет свежие JWT и refreshToken

	суть такого типа авторизации в том, что сервер приложения и сервер авторизации знают друг о друге и следовательно сервер придолжения может попросить сервер авторизации проверить полученные от клиента токены.

================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
================================
