================
google page speed

  онлайн инструмент для оценки производительности страницы вне зависимости от качества интернет-соединения. даёт информацию о минимальном времени после которого:

    1. отрисуется первый графический объект
    2. отрисуется первый наиболее крупный графический объект
    3. пользователю станут доступны интерактивные элементы
    4. отрисуется весь контент
    5. насколько сильно смещается контент во время загрузки соседних элементов

  учитываются только не зависящие от типа интернет-соединения факторы: JavaScript, CSS, структура HTML, конфигурация сервера, размер изображений и т. д.

lighthouse

  подобный инструмент от компании google, тоже даёт оценку производительности и даёт рекомендации как её улучшить.

  способы использования:

    1. chromedevTools
    2. npm install -g lighthouse
    3. chrome plugin

  оценивает:

    1. доступность
    2. использования лучших практик
    3. может ли PWA работать без доступа в интернет
    4. скорость загрузки
    5. наличие адаптивной вёрстки

================
способы анимации в CSS

  transitions
    Смена свойств происходит при наступлении определенного события

    добавление в набор правил селектора свойства transition, котое имеет значением, например, background и набор параметров типа длительности и плавности

      transition-property — указывает список свойств, которые будут анимироваться; свойства

      transition-duration — задаёт значение продолжительности анимации

      transition-timing-function — мы можем ускорить анимацию в начале и замедлить в конце, либо наоборот.

      transition-delay — задаёт задержку времени до начала анимации

      transition — это общее свойство, которое позволяет перечислить первые четыре свойства в порядке: property, duration, timing-function, delay.

      div {
        width: 100px;
        height: 100px;
        background: red;
        transition: width 2s;
      }

      div:hover {
        width: 300px;
      }      

      в блоке :hover можно указывать transform для лучшей производительности.

  keyframes

    в отдельном участке кода прописываются шаги анимации и этому участку задаётся уникальное имя:

      @keyframes circle-to-square {
        from {
          background-color: #F498AD;
        }
        50% {
          background-color: #7F6EDB;
        }
        to {
          background-color: #2E9AFF;
        }
      } 

    затем это имя используется для определённого селектора: 

      .child-one {
        animation-name: circle-to-square;
      }     

    кроме имени существуют дополнительные параметры:

      длительность,
      задержка,
      кол-во повторений,
      признак обратного порядка,
      различные варианты плавности

  js-анимация

    просто средствами js получить доступ к элементам и добавлять свойства или стили.

  svg-анимация

    css

      добавить svg-тегам класс и использовать transitions, например, при :hover. 

      В целом логика работы CSS-анимаций в контексте SVG принципиально не отличается от HTML

    smil

      предполанает использование специфических тегов:

            <animate
                     attributeType='XML'
                     attributeName='stroke-dasharray'
                     from='0 1698'
                     to='1698 0'
                     dur='3s'
                     repeatCount='indefinite'
                     />

================
filter 

  позволяет применять к элементу такие графические эффекты, как размытие и смещение цвета.

    div {
      filter: contrast(175%) brightness(3%);
    }           

  это дорогая операция потому что: 

    1. преобразование происходит попиксельно и потому что 
    2. фильтр применяется после всех операций рендеригна.              

================
как браузер перерисовывает контент?

  существует 3 этапа перерисовки:

    1. вычисление свойств, которые влияют на внешний вид элемента
    2. вычисление положения элемента на экране и геометрии элемента
    3. перерисовка

  если изменяются свойства, которые относятся к геометрии и положению на экране элемента, то выполянются все 3 пункта.
  если изменяются свойства, которые затрагивают только внешний вид элемента (color), то выполняются только пункты 1 и 3
  если изменяются свойства, которые выносятся в отдельный слой, то выполняется только пункт 1

================
анимации

  можно пометить элемент директивой анимации и чередовать состояния:

    <div [@fade]=" show ? 'collapse' : 'expanded'">

    animations: [
      trigger('fade', [     // имя директивы
        state(
          'collapse',       // имя состояния
          style({...})
        ),
        state(
          'expanded',       // имя состояния
          style({...})
        ),
        transition('collapse => expanded', [...]),    // характеристики перехода состояний
        transition('expanded => collapse', [...]),    // характеристики перехода состояний
      ]),
    ],  

    живой пример: https://stackblitz.com/edit/angular-animation-enter-leave-dom-solution-test-lcub4j?file=src/app/app.component.ts

  есть возможность повесить анимацию на хост компонента:

    @HostBinding('@fade')
    public myStatusExp;

  отслеживать события на анимируемом элементе можно так:

    (@fade.start)="animationStarted($event)"
    (@fade.done)="animationDone($event)"  

  можно обойтись без state:

    trigger('todoAnimation', [
       transition(':enter', [         // момент появления элемента в DOM
          style({ height: 0 }),       // перед стартом
          animate('0.3s ease-in', style({ height: '*' }))   // после старта анимации появления
       ]),
       transition(':leave', [         // момент удаления элемента из DOM
          animate('0.3s ease-out', style({ transform: 'scale(0)' }))    // после старта анимации удаления
       ]),
    ])

  анимация дочерних элементов будет заблокирована. 

-------------------

Web Animations API

  позволяет работать с CSS-анимацией средствами JS. то есть у каждого элемента в DOM есть метод animate:

    const el = document.getElementById('cube');
    console.log(el);
    console.log('animate' in el);   // true 

  этому методу преедаётся объект, эмулирующий @keyframes и задающий повторяемость:

    document.getElementById('cube').animate(
        cubeRotating,
        cubeTiming
    ) 

    let cubeRotating = [
        {transform: 'rotate(0deg)', backgroundColor: 'pink'},
        {backgroundColor: 'purple', offset: 0.3},
        {transform: 'rotate(180deg)', backgroundColor: 'pink'}
    ] 

    let cubeTiming = {
        duration: 1000,
        iterations: Infinity
    } 


================
================
================
================
================
================
================
================
================
================
================
================
================
================
================
================
================