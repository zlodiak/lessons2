class Rectangle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }    

  calcArea() {
    return this.x * this.y;
  }
}


class Circle {
  constructor(r) {
    this.r = r;
  }    

  calcArea() {
    return Math.pow(this.r, 2) * Math.PI;
  }
}


class Summator {
    constructor(objects) {
        this.objects = objects;
    }

    getSum() {
        let sum = 0;
        this.objects.forEach(obj => {
            sum += obj.calcArea();
        })
        return sum;
    }
}


class Outputer {
    output(value) {
        console.log('Is calculated:', value);
    }
}


rectangle = new Rectangle(3, 4);
circle = new Circle(5);
summator = new Summator([rectangle, circle]);

sum = summator.getSum();

outputer = new Outputer();
outputer.output(sum);


// когда приложение начнёт расти, то класс Outputer может иметь 3 способа вывода:
// в консоль, во внешний сервис, в текстовый файл. если бы этот функционал по-прежнему содержался в Summator(), то сложность бы было контролировать сложнее 
// и кроме того может так случиться, что над способом вывода работает одна команда, а над вычислением суммы - другая. в этом случае Summator() мог бы иметь 2 причины для изменения, что противоречит принципу единой ответственности
// потому что в пределах одного класса функционалы вычисления суммы и вывода могут иметь общие процедуры, которые одна команда может изменить, не зная, что она используется в другой командой.
// однако 
//
//

у нового класса будет обязанность, отличная от обязанностей объектов, которые он в себя включает. Если говорить конкретно, то обязанность нового класса заключается в том, чтобы соединять вместе данные и алгоритм решения.

обязанность класса Summator более высокоуровневая, чем обязанности включаемых классов

Возьмем тип float. Его обязанность -- реализовывать работу с числами с плавающей точкой (представление, плюс базовые математические операции).
Используя тип float (т.е. используя композицию), вы пишете функцию расчета гипотенузы по заданным катетам. Обязанность этой функции -- считать гипотенузу.
Дальше вы включаете эту функцию в пакет PlanimetryAlgorithms. Обязанность этого пакета -- предоставлять различные алгоритмы, связанных с планиметрий (т.е. геометрией фигур на плоскости).
Пакет PlanimetryAlgorithms может, в свою очередь, входить в библиотеку Geometry, куда также будут входить пакеты для других разделов геометрии. Обязанность этой библиотеки -- предоставлять различные функции, касающиеся геометрии вообще.
Как видно, с повышением гранулярности обязанность становится более высокоуровневой, но при этом ее единственность соблюдается. Функция расчета гипотенузы не выдает нам заодно значения всех углов в этом треугольнике, пакет PlanimetryAlgorithms не содержит методов для рисования фигур, а библиотека Geometry не начинает вдруг заниматься физикой.

логирование это часть сумматора.
сумматор может быть частью математической библиотеки, которая суммирует, умножает и т.д.
таким образом имеем 3 уровня. при этом мат.модуль не содержит методов логирования, а занимаетсся только своим делом.

// при этом могу существовать объекты, в которых собраны различные функции, которые просто нужно держать в одном месте. в этом случае SRP не соблюдается, но нужно помнить о них.

// https://ru.stackoverflow.com/questions/508131/%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F-%D0%BD%D0%B5-%D0%BD%D0%B0%D1%80%D1%83%D1%88%D0%B0%D0%B5%D1%82-%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-%D0%B5%D0%B4%D0%B8%D0%BD%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9-%D0%BE%D0%B1%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8?rq=1
