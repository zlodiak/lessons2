каждый класс должен выполнять одну задачу. вследствие этого каждый класс должен иметь только одну причину для изменения.

рассмотрим s_wrong.js, s_right.js и s_right2.js

в первом скрипте нарушается SRP потому что класс Summator отвечает за расчёт суммы, и за вывод её.

во втором скрипте функционал вывода вынесен в отдельный класс. при этом обращение к Summator и Outputer происходит в клиентском коде. в результате каждый класс решает свою задачу и принцип SRP соблюдается.

в s_right2.js SRP тоже соблюдается, но клиентский код короче. это достигается за счёт использования композиции. то есть Outputer является частью Summator.

здесь важно то, что Summator и Outputer относятся к разным уровням абстракции. если бы вместо this.outputer.output(sum) был код реализации, то получилось бы так, что высокоуровневый класс вместо того чтобы посылать сигнал низкоуровневому, работает с  низкоуровневыми деталями и таким образом имеет более одной ответственности

аналогия: round() отвечает за округление числа, но эта функция используется в функции расчёта площадки круга. в свою очередь функция расчёта расчёта площади круга используется в библиотеке, которая рассчитывает площади различных геометрических фигур. а эта библиотека является частью пакета спутниковой навигации. и т.д.

таким образом спутниковая навигация решает задачу на своём уровне, не углубляясь в реализацию и т.д.

аналогия: человек > нога > палец ноги. 
человек идёт(это высокоуровнеая функция), при этом он не думает о движении ноги и пальца. если бы думал(углубление в реализацию), то система работата бы не эффективно.

можно представить ситуацию когда все эти составляющие не объединены композицией, а разнесены по отдельным классам и вызываются из клиентского кода как в примере s_right.js. в этом случае клиентскому коду не удастся избежать нарушения SRP.

тем не менее такой клиенский код может быть частью паттерна Фасад. нужно всегда искать компромисс.

кроме того, по принципу SRP должна быть только одна причина для изменения класса.
и эта причина может исходить только от одного актора.

полезно представить, что над функционалом суммирования и над функционалом вывода работают разные группы людей. как видно из s_right2.js, если группа Outputer изменит логику своего функционала, то это никак не повлияет на код группы Summator и наоборот. это следствие грамотного применения SRP.


===

план:

смешные вещи.
неосознанное применение, график фич.
