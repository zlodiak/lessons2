mergeMap делает то же самое что и merge(извлекает элементы всех последовательностей и помещает их в одну результирующую последовательность), но разница в том, что эти последовательности сразу в коде не даны. они являются элементами родительской последовательности. таким образом их нужно сначала по очереди извлечь из родительской и только потом(по мере извлечения) обрабатывать

[{}, {}, {}, {}, .....]

здесь [] - родительская последовательность
{} - дочерняя(значения из которой извлекаются и помещаются в результирующую последовательность)

=========================
запиьс в общем виде выглядит так:

var s = Rx.Observable.interval(1000).map(o => {
	console.log('___observable:', o);
	switch (o) {
		case 0: return Rx.Observable.interval(1000).map((v) => v * 100).take(3);
		case 1: return Rx.Observable.interval(1000).map((v) => v * 10).take(3);
		case 2: return Rx.Observable.interval(1000).map((v) => v * 1).take(3);
		default: return Rx.Observable.of('');
	}	  
}).take(3);

var sub = s.mergeMap((x) => {
  return x;
});

sub.subscribe(x => console.log(x));


здесь:
s - родительская последовательность
mergeMap((x) - сюда по очереди помещаются дочерние последовательности
sub.subscribe(x - сюда по очереди попадают элементы дочерней последовательности


=========================
в результате все элементы всех дочерних последовательностей оказываются в одной результирующей последовательности

=========================
важен случай "сложения" двух запросов:
var s = Rx.Observable.interval(1000).take(3);
var s1 = Rx.Observable.interval(1000).map(v => 'v' + v).take(3);

var sub = s.mergeMap((x) => {
	console.log('__observable', x);
  return s1;
});

sub.subscribe(x => console.log(x));


здесь после излучения каждого значения из родительской последовательности происходит излучение всех значений из дочерней.
этот процесс повторяется и зависит от количества элементов в родительской последовательности.

=========================

этот код можно записать так:
var s = Rx.Observable.interval(1000).take(3);

var sub = s.mergeMap((x) => {
	console.log('__observable', x);
  return Rx.Observable.interval(1000).map(v => 'v' + v).take(3);
});

sub.subscribe(x => console.log(x));

в этом случае мы получаем возможность изменять значения дочернего потока на основе текущего значения родительского потока:
return Rx.Observable.interval(1000).map(v => 'v' + v + x).take(3);

=========================
если в коде выше родительский поток возвращает только одно значение, то оно по сути служит сигналом для запуска второго потока. это важный частный случай

=========================
=========================
=========================
=========================
=========================
=========================
=========================
=========================
=========================
=========================
=========================
=========================