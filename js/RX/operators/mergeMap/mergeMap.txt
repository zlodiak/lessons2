mergeMap делает то же самое что и merge(извлекает элементы всех последовательностей и помещает их в одну результирующую последовательность), но разница в том, что эти последовательности сразу в коде не даны. они являются элементами родительской последовательности. таким образом их нужно сначала по очереди извлечь из родительской и только потом(по мере извлечения) обрабатывать

[{}, {}, {}, {}, .....]

здесь [] - родительская последовательность
{} - дочерняя(значения из которой извлекаются и помещаются в результирующую последовательность)

=========================
запиьс в общем виде выглядит так:

var s = Rx.Observable.interval(1000).map(o => {
	console.log('___observable:', o);
	switch (o) {
		case 0: return Rx.Observable.interval(1000).map((v) => v * 100).take(3);
		case 1: return Rx.Observable.interval(1000).map((v) => v * 10).take(3);
		case 2: return Rx.Observable.interval(1000).map((v) => v * 1).take(3);
		default: return Rx.Observable.of('');
	}	  
}).take(3);

var sub = s.mergeMap((x) => {
  return x;
});

sub.subscribe(x => console.log(x));


здесь:
s - родительская последовательность
mergeMap((x) - сюда по очереди помещаются дочерние последовательности
sub.subscribe(x - сюда по очереди попадают элементы дочерней последовательности


=========================
в результате все элементы всех дочерних последовательностей оказываются в одной результирующей последовательности

=========================
=========================
=========================
=========================
=========================
=========================
=========================
=========================
=========================
=========================
=========================
=========================
=========================
=========================