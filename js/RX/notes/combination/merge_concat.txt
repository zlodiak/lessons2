merge и concat складывают потоки, но разными способами.

если оба потока синхронные, то разницы между merge и concat нет. в блок subscribe сначала попадут все значения из первого потока, потом из второго и т.д.

если оба потока асинхронные, то в результате работы merge в блок subscribe будут попадать значения из всех потоков в порядке появления(грабли).

=======================================
ниже приведён код для всех вариантов(чтобы увидеть результат в источник нужно подставлять различные observables):

const s1 = interval(1000);
const s2 = interval(1000);

const s3 = generate(
  0,
  x => x <= 5,
  x => x + 1
);
const s4 = generate(
  10,
  x => x <= 15,
  x => x + 1
);

const s5 = range(1, 5);
const s6 = range(11, 5);

const s7 = interval(1000).pipe(take(5));
const s8 = interval(1000).pipe(take(5));

merge(
  s7,
  s8,
)
.subscribe(d => {
  console.log('merge', d)
})
// 00 11 22 33 44



concat(
  s7,
  s8,
)
.subscribe(d => {
  console.log('concat', d)
})
// 01234 01234



=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================
=======================================