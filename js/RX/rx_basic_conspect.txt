1. Подписка, отписка от Observable, ленивость Observable
2. Observable.create, события observer (next, error, complete)
3. Subject. Что это, его разновидности
4. Multicasting, ConnectableObservable и refCount(). Операторы multicast, publish и share.
5. Виды Observable (hot, warm, cold), как их создать, отличия
6. Операторы создания: defer, of, from, throw. 
7. Операторы трансформации: buffer, map, pairwise, scan. 
8. Операторы фильтрации: debounce, distinct, filter, first (last), take (skip)
9. Операторы комбинирования: отличия combineLatest и forkJoin, отличие merge и concat, startWith, switch, withLatestFrom. 
10. Операторы обработки ошибок: catch и retry. 
11. Utility операторы: do, delay, finally. 
12. Условные операторы: defaultIfEmpty, every, isEmpty. 
13. Отличие scan от reduce.
14. Операторы высокоуровневых Observable (High Order Observabale or Observabale of Observabales): mergeMap(flatMap), concatMap, swicthMap, expand, exhaustMap. Их отличие. Отличие mergeMap от map.
15. Планировщики (Schedulers). Что это и зачем? Операторы observeOn и subscribeOn.


===============================================
1:

Observable излучает последовательность значений. последовательность может быть бесконечной или конечной. на неё можно подписаться. подписчиков может быть несколько. так же эту последовательность можно остановить.

подписка осуществляется через .subscribe(next, error, complete). если подписчиков несколько, то для каждого из них создаётся свой экземпляр потока.
например: 
Observable.interval(1000).subscribe(next)
setTimeout(() => {
	Observable.interval(1000).subscribe(next)
}, 5000);
в результате в каждый наблюдатель излучится СВОЯ ОТДЕЛЬНАЯ последовательность 1,2,3,4,5,6,...


отписка осуществляется через .unsubscribe(). то есть нужно приравнять observable к переменной и затем отписаться так:
variable = Observable.subscribe(next);
variable.unsubscribe();

есть еще способ отписки:
import { Subject } from 'rxjs/Subject';
import 'rxjs/add/operator/takeUntil';
destroy$: Subject<void> = new Subject<void>();
Observable.takeUntil(destroy$).subscribe(next);
ngOnDestroy() {
  this.destroy$.next();
  this.destroy$.complete();
}

суть в том, что как только destroy$ излучит хотя бы одно значение, то из Observable больше ничего не поступает. тут больше: https://toster.ru/q/514267
существует оператор takeWhile(), который в качестве аргумента принимает не поток, а булево значение. его тоже можно использовать.

Observable ленивы. это значит, что пока на них не подпишется наблюдатель, то излучаемые значения видны не будут, соответственно обработать их невозможно

===============================================
2:

в angular Observable создаётся так:
this.data = new Observable(observer => {
  observer.next(42);
  observer.next(43);
});

в rxjs так:
const data = Observable.create(function(observer) {
  observer.next(42);
  observer.next(43);
});

observer принимает в качестве аргументов 3 коллбека: next, error, complete.
первый срабатывает когда приходит значение, второй - когда приходит объект исключения, третий - когда последовательность заканчивается. второй и третий останавливают последовательность.

===============================================
3:

Subject это прокси. по сути это Observable на который можно подписаться. но который может и сам принимать значения.
const subject = new Subject();
button.addEventListener(‘click’, () => subject.next('click');
subject.subscribe(x => console.log(x));

Subject - позволяет после момента подписки получать все значения, которые излучены после момента подписки. рпи этом значения, излучённые ДО момента подписки недоступны

ReplaySubject - позволяет новым подписчикам получить все ранее излучённые(до момента подписки) значения и все последующие. при этом, если излучение асинхронно, то ранее излучённые значения получатся синхронно, а остальные асинхронно.

BehaviorSubject - позволяет получить ОДНО ранее излучённое(то есть до момента подписки) значение и все последующие(то естьпосле момента подписки).

AsyncSubject - позволяет получить только последнее значение, излучённое ПОСЛЕ момента подписки. например студент пришёл в середине лекции, но хочет слушать только последнюю вещь, которую расскажет преподаватель

===============================================
===============================================
5:

горячие observable: излучают значения независимо подписан на них кто-нибудь или нет. важно понимать, что в этом случае излучаемые данные создаются вне observable. например изменение размера окна
const resize$ =
  Rx.Observable
    .fromEvent(window, 'resize');
const subscription =
  resize$.subscribe((event) => {
    let t = event.target;
    console.log(`${t.innerWidth}px x ${t.innerHeight}px`);
  });

холодные observable начинают излучать только после того как на них кто-нибудь подпишется. при повторной подписке(или добавлении нового подписчика) последовательность значений излучается с начала. важно понимать, что излучаемые данные создаются внутри observable 
const source$ = Rx.Observable.range(1, 5);
const subscription = source$.subscribe(
  (value) => { console.log(`Next: ${value}`); }
);

===============================================
6:

оператор of создаёт последовательность из своих аргументов(аргументы могут быть разного типа):
const source = Rx.Observable.of(1, 2, 3, 4, 5);
const subscribe = source.subscribe(val => console.log(val));

оператор from создаёт последовательность из объекта:
const source = Rx.Observable.from([1, 2, 3, 4, 5]);
const subscribe = source.subscribe(val => console.log(val));

оператор throw() прерывает последовательность и излучает объект исключения. соответственно отрабатывает коллбек error:
const source = Rx.Observable.from([1, 2, 3, 4, 5]).flatMap(Rx.Observable.throw(new Error('error!')));
const subscribe = source.subscribe(
	val => console.log(val),
	err => console.log('Error', err)
);

===============================================
7:

оператор map применяет функцию к каждому элементу коллекции. в резульате получается другая коллекция:
const source = from([1, 2, 3, 4, 5]);
const example = source.map(val => val + 10);
const subscribe = example.subscribe(val => console.log(val));
//output: 11,12,13,14,15

оператор pairwise разбивает последовательность на пары. было 1,2,3,4, стало 1,2; 2,3; 3,4; 4,5;
interval(1000)
  .pairwise(), take(5)
  .subscribe(console.log);
//Returns: [0,1], [1,2], [2,3], [3,4], [4,5]

оператор buffer разбивает поток на части, границы определяют события второго потока:
const myInterval = interval(1000);
const bufferBy = fromEvent(document, 'click')
myInterval.buffer(bufferBy).subscribe(val =>
  console.log(' Buffered Values:', val)
);
//ex. output: [1,2,3] ... [4,5,6,7,8]

оператор scan аккумулирует значения в последовательности на основе некоторой функции(аналог reduce() из нативного js):
const source = of(1, 2, 3);
const example = source.pipe(scan((acc, curr) => acc + curr, 0));
const subscribe = example.subscribe(val => console.log(val));
// output: 1,3,6
отличие от RXreduce в том, что reduce возвращает только последнее значение

===============================================
8:

оператор take берёт фиксированное количество значений из потока:
const source = of(1, 2, 3, 4, 5);
const example = source.take(1);
const subscribe = example.subscribe(val => console.log(val));
// 1

оператор skip пропускает фиксированное количество значений потока:
const source = interval(1000);
const example = source.skip(5);
const subscribe = example.subscribe(val => console.log(val));
//output: 5...6...7...8........

оператор first берёт только первое значение из потока:
const source = of(1, 2, 3, 4, 5);
const example = source.first();
const subscribe = example.subscribe(val => console.log(val));
// 1

оператор last берёт только последнее значение из потока(в случае бесконечно последовательности результата не будет):
const source = of(1, 2, 3, 4, 5);
const example = source.last();
const subscribe = example.subscribe(val => console.log(val));
// 5

оператор filter работает так же как filter в нативном js. то есть каждый элемент последовательности проверяет условием и возвращает только те, которые соответствуют true:
const source = from([1, 2, 3, 4, 5]);
const example = source.filter(num => num % 2 === 0);
const subscribe = example.subscribe(val => console.log(`Even number: ${val}`));
//output: "Even number: 2", "Even number: 4"

оператор distinct отсеивает неуникальные значения:
var source = Rx.Observable.of(42, 24, 42, 24).distinct();
var subscription = source.subscribe(function (x) { console.log('Next: %s', x); });
// => Next: 42
// => Next: 24

оператор debounce разбивает последовательность на части на основе временного промежутка и затем берёт последнее значение из каждой части:
var clicks = Rx.Observable.fromEvent(document, 'click');
var result = clicks.debounce(() => Rx.Observable.interval(1000));
result.subscribe(x => console.log(x));
// в резульатет если каждую секунду происходит несколько кликов, то будет браться только событие последнего клика в пределе промежутка

если основной поток синхронный, то сразу гарантированно возьмётся последнее значение:
const example = of('WAIT', 'ONE', 'SECOND', 'Last will display').debounce(() => timer(1000));
debouncedExample.subscribe(val => console.log(val)); 
// 'Last will display'

===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================